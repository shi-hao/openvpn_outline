!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACF_DISABLED	ssl_verify.c	835;"	d	file:
ACF_FAILED	ssl_verify.c	836;"	d	file:
ACF_SUCCEEDED	ssl_verify.c	834;"	d	file:
ACF_UNDEFINED	ssl_verify.c	833;"	d	file:
ACK_SIZE	reliable.c	210;"	d	file:
AC_MIN_BYTES	lzo.h	88;"	d
AC_OFF_SEC	lzo.h	94;"	d
AC_SAMP_SEC	lzo.h	87;"	d
AC_SAVE_PCT	lzo.h	91;"	d
ADD_CHECKSUM_32	proto.h	199;"	d
ADJUST_CHECKSUM	proto.h	184;"	d
ADVANCE	route.c	3574;"	d	file:
ADVANCE	route.c	3581;"	d	file:
ADVANCE	route.c	3801;"	d	file:
ADVANCE	route.c	3802;"	d	file:
AF_DID_PUSH	manage.c	312;"	d	file:
AF_DID_RESET	manage.c	313;"	d	file:
ALLOC_ARRAY	buffer.h	1023;"	d
ALLOC_ARRAY_CLEAR	buffer.h	1033;"	d
ALLOC_ARRAY_CLEAR_GC	buffer.h	1039;"	d
ALLOC_ARRAY_GC	buffer.h	1028;"	d
ALLOC_OBJ	buffer.h	1012;"	d
ALLOC_OBJ_CLEAR	buffer.h	1017;"	d
ALLOC_OBJ_CLEAR_GC	buffer.h	1054;"	d
ALLOC_OBJ_GC	buffer.h	1049;"	d
ALLOC_VAR_ARRAY_CLEAR_GC	buffer.h	1044;"	d
ANDROID_KEEP_OLD_TUN	manage.h	398;"	d
ANDROID_OPEN_AFTER_CLOSE	manage.h	399;"	d
ANDROID_OPEN_BEFORE_CLOSE	manage.h	400;"	d
ANDROID_TUNNAME	tun.c	1850;"	d	file:
ANY_OUT	forward.h	40;"	d
ARGV_H	argv.h	31;"	d
ARP_MAC_ADDR_TYPE	proto.h	67;"	d
ARP_REPLY	proto.h	75;"	d
ARP_REQUEST	proto.h	74;"	d
AR_INTERACT	options.h	803;"	d
AR_NOINTERACT	options.h	804;"	d
AR_NONE	options.h	802;"	d
ASSERT	error.h	221;"	d
ASSERT	error.h	223;"	d
AUTH_TOKEN_SIZE	ssl_common.h	364;"	d
AUTO_USERID	syshead.h	672;"	d
AUTO_USERID	syshead.h	674;"	d
BASE_N_EVENTS	init.h	33;"	d
BASIC_H	basic.h	25;"	d
BCAP	buffer.h	130;"	d
BDEF	buffer.h	128;"	d
BEND	buffer.h	125;"	d
BIG_TIMEOUT	common.h	50;"	d
BLAST	buffer.h	126;"	d
BLEN	buffer.h	127;"	d
BLOCK_DNS_IFACE_METRIC	block_dns.h	30;"	d
BOOL_CAST	basic.h	27;"	d
BOOTPC_PORT	dhcp.h	51;"	d
BOOTPS_PORT	dhcp.h	50;"	d
BOOTREPLY	dhcp.h	55;"	d
BOOTREQUEST	dhcp.h	54;"	d
BPTR	buffer.h	124;"	d
BSTR	buffer.h	129;"	d
BUFFER_H	buffer.h	25;"	d
BUF_INIT_TRACKING	buffer.h	42;"	d
BUF_SIZE	mtu.h	194;"	d
BUF_SIZE_MAX	buffer.h	30;"	d
CAPI_DATA	cryptoapi.c	/^} CAPI_DATA;$/;"	t	typeref:struct:_CAPI_DATA	file:
CAS_FAILED	openvpn.h	463;"	d
CAS_PARTIAL	openvpn.h	464;"	d
CAS_PENDING	openvpn.h	462;"	d
CAS_SUCCEEDED	openvpn.h	461;"	d
CCD_DEFAULT	common.h	73;"	d
CC_ALNUM	buffer.h	877;"	d
CC_ALPHA	buffer.h	878;"	d
CC_ANY	buffer.h	874;"	d
CC_ASCII	buffer.h	879;"	d
CC_ASTERISK	buffer.h	907;"	d
CC_AT	buffer.h	901;"	d
CC_BACKSLASH	buffer.h	891;"	d
CC_BLANK	buffer.h	887;"	d
CC_CNTRL	buffer.h	880;"	d
CC_COLON	buffer.h	896;"	d
CC_COMMA	buffer.h	895;"	d
CC_CR	buffer.h	889;"	d
CC_CRLF	buffer.h	911;"	d
CC_DASH	buffer.h	893;"	d
CC_DIGIT	buffer.h	881;"	d
CC_DOT	buffer.h	894;"	d
CC_DOUBLE_QUOTE	buffer.h	899;"	d
CC_EQUAL	buffer.h	902;"	d
CC_EXCLUDE	buffer.c	1090;"	d	file:
CC_GC_FREE	init.h	105;"	d
CC_GREATER_THAN	buffer.h	904;"	d
CC_HARD_USR1_TO_HUP	init.h	107;"	d
CC_INCLUDE	buffer.c	1089;"	d	file:
CC_LESS_THAN	buffer.h	903;"	d
CC_NAME	buffer.h	910;"	d
CC_NEWLINE	buffer.h	888;"	d
CC_NO_CLOSE	init.h	108;"	d
CC_NULL	buffer.h	875;"	d
CC_PIPE	buffer.h	905;"	d
CC_PRINT	buffer.h	882;"	d
CC_PUNCT	buffer.h	883;"	d
CC_QUESTION_MARK	buffer.h	906;"	d
CC_REPLACE	buffer.c	1091;"	d	file:
CC_REVERSE_QUOTE	buffer.h	900;"	d
CC_SINGLE_QUOTE	buffer.h	898;"	d
CC_SLASH	buffer.h	897;"	d
CC_SPACE	buffer.h	884;"	d
CC_UNDERBAR	buffer.h	892;"	d
CC_USR1_TO_HUP	init.h	106;"	d
CC_XDIGIT	buffer.h	885;"	d
CERT_STORE_OPEN_EXISTING_FLAG	cryptoapi.c	69;"	d	file:
CERT_STORE_READONLY_FLAG	cryptoapi.c	66;"	d	file:
CERT_SYSTEM_STORE_CURRENT_USER	cryptoapi.c	63;"	d	file:
CERT_SYSTEM_STORE_CURRENT_USER_ID	cryptoapi.c	60;"	d	file:
CERT_SYSTEM_STORE_LOCATION_SHIFT	cryptoapi.c	57;"	d	file:
CE_DISABLED	options.h	125;"	d
CE_MAN_QUERY_PROXY	options.h	126;"	d
CE_MAN_QUERY_REMOTE_ACCEPT	options.h	129;"	d
CE_MAN_QUERY_REMOTE_MASK	options.h	132;"	d
CE_MAN_QUERY_REMOTE_MOD	options.h	130;"	d
CE_MAN_QUERY_REMOTE_QUERY	options.h	128;"	d
CE_MAN_QUERY_REMOTE_SHIFT	options.h	133;"	d
CE_MAN_QUERY_REMOTE_SKIP	options.h	131;"	d
CE_MAN_QUERY_REMOTE_UNDEF	options.h	127;"	d
CF_INIT_TLS_AUTH_STANDALONE	init.c	64;"	d	file:
CF_INIT_TLS_MULTI	init.c	63;"	d	file:
CF_LOAD_PERSISTED_PACKET_ID	init.c	62;"	d	file:
CHECK_ERROR	block_dns.c	124;"	d	file:
CHKACC_ACPTSTDIN	options.c	3053;"	d	file:
CHKACC_DIRPATH	options.c	3050;"	d	file:
CHKACC_FILE	options.c	3049;"	d	file:
CHKACC_FILEXSTWR	options.c	3051;"	d	file:
CHKACC_INLINE	options.c	3052;"	d	file:
CHKACC_PRIVATE	options.c	3054;"	d	file:
CIPHER_ENABLED	openvpn.h	589;"	d
CIPHER_ENABLED	openvpn.h	591;"	d
CIRC_LIST	circ_list.h	31;"	d
CIRC_LIST_ALLOC	circ_list.h	64;"	d
CIRC_LIST_FREE	circ_list.h	74;"	d
CIRC_LIST_H	circ_list.h	25;"	d
CIRC_LIST_INDEX	circ_list.h	50;"	d
CIRC_LIST_ITEM	circ_list.h	55;"	d
CIRC_LIST_PUSH	circ_list.h	40;"	d
CIRC_LIST_RESET	circ_list.h	58;"	d
CIRC_LIST_SIZE	circ_list.h	47;"	d
CLEAR	basic.h	33;"	d
CLINAT_H	clinat.h	25;"	d
CM_CHILD_TCP	openvpn.h	521;"	d
CM_CHILD_UDP	openvpn.h	520;"	d
CM_P2P	openvpn.h	517;"	d
CM_TOP	openvpn.h	518;"	d
CM_TOP_CLONE	openvpn.h	519;"	d
CN_DNAT	clinat.h	36;"	d
CN_INCOMING	clinat.h	32;"	d
CN_OUTGOING	clinat.h	31;"	d
CN_SNAT	clinat.h	35;"	d
COMMAND_EXIT	ps.c	49;"	d	file:
COMMAND_REDIRECT	ps.c	48;"	d	file:
COMMON_H	common.h	25;"	d
COMMON_NAME_CHAR_CLASS	ssl_verify.c	57;"	d	file:
COMPAT_FLAG_QUERY	misc.h	302;"	d
COMPAT_FLAG_SET	misc.h	303;"	d
COMPAT_NAMES	misc.h	304;"	d
COMPAT_NO_NAME_REMAPPING	misc.h	305;"	d
COMPRESS_THRESHOLD	comp.h	96;"	d
COMP_ALGV2_INDICATOR_BYTE	comp.h	78;"	d
COMP_ALGV2_LZ4	comp.h	48;"	d
COMP_ALGV2_LZ4_BYTE	comp.h	80;"	d
COMP_ALGV2_LZO_BYTE	comp.h	81;"	d
COMP_ALGV2_SNAPPY_BYTE	comp.h	82;"	d
COMP_ALGV2_UNCOMPRESSED	comp.h	47;"	d
COMP_ALGV2_UNCOMPRESSED_BYTE	comp.h	79;"	d
COMP_ALG_LZ4	comp.h	43;"	d
COMP_ALG_LZO	comp.h	41;"	d
COMP_ALG_SNAPPY	comp.h	42;"	d
COMP_ALG_STUB	comp.h	40;"	d
COMP_ALG_UNDEF	comp.h	39;"	d
COMP_EXTRA_BUFFER	comp.h	91;"	d
COMP_F_ADAPTIVE	comp.h	55;"	d
COMP_F_ADVERTISE_STUBS_ONLY	comp.h	58;"	d
COMP_F_ASYM	comp.h	56;"	d
COMP_F_SWAP	comp.h	57;"	d
COMP_PREFIX_LEN	comp.h	64;"	d
CONNECTION_ESTABLISHED	forward-inline.h	339;"	d
CONNECTION_LIST_SIZE	options.h	145;"	d
CONNECT_NONBLOCK	syshead.h	665;"	d
CONSOLE_H	console.h	27;"	d
CONTROL_SEND_ACK_MAX	ssl.h	76;"	d
CO_IGNORE_PACKET_ID	crypto.h	255;"	d
CO_MUTE_REPLAY_WARNINGS	crypto.h	261;"	d
CO_PACKET_ID_LONG_FORM	crypto.h	248;"	d
CO_USE_IV	crypto.h	251;"	d
CRYPTOAPI_F_CERT_FIND_CERTIFICATE_IN_STORE	cryptoapi.c	79;"	d	file:
CRYPTOAPI_F_CERT_OPEN_SYSTEM_STORE	cryptoapi.c	78;"	d	file:
CRYPTOAPI_F_CRYPT_ACQUIRE_CERTIFICATE_PRIVATE_KEY	cryptoapi.c	80;"	d	file:
CRYPTOAPI_F_CRYPT_CREATE_HASH	cryptoapi.c	81;"	d	file:
CRYPTOAPI_F_CRYPT_GET_HASH_PARAM	cryptoapi.c	82;"	d	file:
CRYPTOAPI_F_CRYPT_SET_HASH_PARAM	cryptoapi.c	83;"	d	file:
CRYPTOAPI_F_CRYPT_SIGN_HASH	cryptoapi.c	84;"	d	file:
CRYPTOAPI_F_GET_PROC_ADDRESS	cryptoapi.c	86;"	d	file:
CRYPTOAPI_F_LOAD_LIBRARY	cryptoapi.c	85;"	d	file:
CRYPTOAPI_F_NCRYPT_SIGN_HASH	cryptoapi.c	87;"	d	file:
CRYPTOAPI_str_functs	cryptoapi.c	/^static ERR_STRING_DATA CRYPTOAPI_str_functs[] = {$/;"	v	file:
CRYPTOAPIerr	cryptoapi.c	77;"	d	file:
CRYPTO_BACKEND_H_	crypto_backend.h	30;"	d
CRYPTO_H	crypto.h	124;"	d
CRYPTO_MBEDTLS_H_	crypto_mbedtls.h	30;"	d
CRYPTO_OPENSSL_H_	crypto_openssl.h	30;"	d
CRYPT_ERROR	crypto.h	268;"	d
CR_ECHO	misc.h	198;"	d
CR_RESPONSE	misc.h	199;"	d
CvtHex	httpdigest.c	/^CvtHex($/;"	f	file:	signature:( IN HASH Bin, OUT HASHHEX Hex )
DAF_CONNECTION_CLOSED	manage.h	48;"	d
DAF_CONNECTION_ESTABLISHED	manage.h	47;"	d
DAF_INITIAL_AUTH	manage.h	49;"	d
DEBUG_LEVEL_USEC_TIME	errlevel.h	33;"	d
DECODE_ERROR	base64.c	120;"	d	file:
DECODE_MUTE_LEVEL	error.h	124;"	d
DECRYPT_KEY_ENABLED	ssl_verify.h	91;"	d
DEFAULT_SEQ_BACKTRACK	packet_id.h	107;"	d
DEFAULT_TIME_BACKTRACK	packet_id.h	116;"	d
DES_KEY_LENGTH	crypto_mbedtls.h	76;"	d
DES_KEY_LENGTH	crypto_openssl.h	77;"	d
DEV_TYPE_NULL	proto.h	36;"	d
DEV_TYPE_TAP	proto.h	38;"	d
DEV_TYPE_TUN	proto.h	37;"	d
DEV_TYPE_UNDEF	proto.h	35;"	d
DHCPACK	dhcp.h	44;"	d
DHCPDECLINE	dhcp.h	43;"	d
DHCPDISCOVER	dhcp.h	40;"	d
DHCPINFORM	dhcp.h	47;"	d
DHCPNAK	dhcp.h	45;"	d
DHCPOFFER	dhcp.h	41;"	d
DHCPRELEASE	dhcp.h	46;"	d
DHCPREQUEST	dhcp.h	42;"	d
DHCP_END	dhcp.h	37;"	d
DHCP_H	dhcp.h	25;"	d
DHCP_MSG_TYPE	dhcp.h	36;"	d
DHCP_OPTIONS_BUFFER_SIZE	dhcp.h	78;"	d
DHCP_PAD	dhcp.h	34;"	d
DHCP_ROUTER	dhcp.h	35;"	d
DHCP_STATUS_DISABLED	tun.c	4574;"	d	file:
DHCP_STATUS_ENABLED	tun.c	4573;"	d	file:
DHCP_STATUS_UNDEF	tun.c	4572;"	d	file:
DSA_bits	openssl_compat.h	/^DSA_bits(const DSA *dsa)$/;"	f	signature:(const DSA *dsa)
DSA_get0_pqg	openssl_compat.h	/^DSA_get0_pqg(const DSA *dsa, const BIGNUM **p,$/;"	f	signature:(const DSA *dsa, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
DUP_CN	pool.c	544;"	d	file:
D_ALIGN_DEBUG	errlevel.h	138;"	d
D_ALIGN_ERRORS	errlevel.h	70;"	d
D_ARGV	errlevel.h	75;"	d
D_ARGV_PARSE_CMD	errlevel.h	144;"	d
D_AUTH	errlevel.h	85;"	d
D_AUTO_USERID	errlevel.h	142;"	d
D_CLIENT_NAT	errlevel.h	115;"	d
D_CLOSE	errlevel.h	73;"	d
D_COMP	errlevel.h	161;"	d
D_COMP_ERRORS	errlevel.h	61;"	d
D_COMP_LOW	errlevel.h	125;"	d
D_CONNECTION_LIST	errlevel.h	126;"	d
D_CRYPTO_DEBUG	errlevel.h	145;"	d
D_CRYPT_ERRORS	errlevel.h	58;"	d
D_DHCP_OPT	errlevel.h	98;"	d
D_EVENT_ERRORS	errlevel.h	66;"	d
D_EVENT_WAIT	errlevel.h	157;"	d
D_FRAG_DEBUG	errlevel.h	120;"	d
D_FRAG_ERRORS	errlevel.h	69;"	d
D_GENKEY	errlevel.h	79;"	d
D_GREMLIN	errlevel.h	78;"	d
D_GREMLIN_VERBOSE	errlevel.h	155;"	d
D_HANDSHAKE	errlevel.h	72;"	d
D_HANDSHAKE_VERBOSE	errlevel.h	151;"	d
D_IFCONFIG_POOL	errlevel.h	84;"	d
D_IMPORT_ERRORS	errlevel.h	64;"	d
D_INIT_MEDIUM	errlevel.h	105;"	d
D_INTERVAL	errlevel.h	153;"	d
D_LINK_ERRORS	errlevel.h	57;"	d
D_LINK_RW	errlevel.h	112;"	d
D_LINK_RW_VERBOSE	errlevel.h	166;"	d
D_LOG_RW	errlevel.h	110;"	d
D_LOW	errlevel.h	97;"	d
D_MANAGEMENT	errlevel.h	88;"	d
D_MANAGEMENT_DEBUG	errlevel.h	134;"	d
D_MBUF	errlevel.h	99;"	d
D_MSS	errlevel.h	124;"	d
D_MTU_DEBUG	errlevel.h	122;"	d
D_MTU_INFO	errlevel.h	106;"	d
D_MULTI_DEBUG	errlevel.h	123;"	d
D_MULTI_DROPPED	errlevel.h	102;"	d
D_MULTI_ERRORS	errlevel.h	65;"	d
D_MULTI_LOW	errlevel.h	86;"	d
D_MULTI_MEDIUM	errlevel.h	103;"	d
D_MULTI_TCP	errlevel.h	158;"	d
D_OPENSSL_LOCK	errlevel.h	174;"	d
D_OSBUF	errlevel.h	91;"	d
D_PACKET_CONTENT	errlevel.h	163;"	d
D_PACKET_TRUNC_DEBUG	errlevel.h	139;"	d
D_PACKET_TRUNC_ERR	errlevel.h	100;"	d
D_PF_DEBUG	errlevel.h	148;"	d
D_PF_DROPPED	errlevel.h	101;"	d
D_PF_DROPPED_BCAST	errlevel.h	147;"	d
D_PF_INFO	errlevel.h	93;"	d
D_PID_DEBUG	errlevel.h	146;"	d
D_PID_DEBUG_LOW	errlevel.h	107;"	d
D_PID_DEBUG_MEDIUM	errlevel.h	108;"	d
D_PID_PERSIST	errlevel.h	68;"	d
D_PID_PERSIST_DEBUG	errlevel.h	165;"	d
D_PING	errlevel.h	140;"	d
D_PKCS11_DEBUG	errlevel.h	169;"	d
D_PLUGIN	errlevel.h	87;"	d
D_PLUGIN_DEBUG	errlevel.h	135;"	d
D_PROXY	errlevel.h	74;"	d
D_PS_PROXY	errlevel.h	92;"	d
D_PS_PROXY_DEBUG	errlevel.h	141;"	d
D_PUSH	errlevel.h	83;"	d
D_PUSH_DEBUG	errlevel.h	149;"	d
D_PUSH_ERRORS	errlevel.h	67;"	d
D_READ_WRITE	errlevel.h	162;"	d
D_REGISTRY	errlevel.h	173;"	d
D_REL_DEBUG	errlevel.h	156;"	d
D_REL_LOW	errlevel.h	119;"	d
D_REPLAY_ERRORS	errlevel.h	62;"	d
D_RESOLVE_ERRORS	errlevel.h	60;"	d
D_RESTART	errlevel.h	82;"	d
D_ROUTE	errlevel.h	80;"	d
D_ROUTE_DEBUG	errlevel.h	129;"	d
D_ROUTE_QUOTA	errlevel.h	90;"	d
D_SCHEDULER	errlevel.h	154;"	d
D_SCHED_EXIT	errlevel.h	89;"	d
D_SCRIPT	errlevel.h	127;"	d
D_SEMAPHORE	errlevel.h	132;"	d
D_SEMAPHORE_LOW	errlevel.h	131;"	d
D_SHAPER_DEBUG	errlevel.h	171;"	d
D_SHOW_KEYS	errlevel.h	117;"	d
D_SHOW_KEY_SOURCE	errlevel.h	118;"	d
D_SHOW_NET	errlevel.h	128;"	d
D_SHOW_OCC	errlevel.h	96;"	d
D_SHOW_PARMS	errlevel.h	95;"	d
D_SHOW_PKCS11	errlevel.h	137;"	d
D_SOCKET_DEBUG	errlevel.h	136;"	d
D_STREAM_DEBUG	errlevel.h	167;"	d
D_STREAM_ERRORS	errlevel.h	63;"	d
D_TAP_WIN_DEBUG	errlevel.h	114;"	d
D_TEST_FILE	errlevel.h	133;"	d
D_TLS_DEBUG	errlevel.h	160;"	d
D_TLS_DEBUG_LOW	errlevel.h	77;"	d
D_TLS_DEBUG_MED	errlevel.h	152;"	d
D_TLS_ERRORS	errlevel.h	59;"	d
D_TLS_KEYSELECT	errlevel.h	143;"	d
D_TLS_NO_SEND_KEY	errlevel.h	164;"	d
D_TLS_STATE_ERRORS	errlevel.h	130;"	d
D_TUNTAP_INFO	errlevel.h	81;"	d
D_TUN_RW	errlevel.h	113;"	d
D_WIN32_IO	errlevel.h	168;"	d
D_WIN32_IO_LOW	errlevel.h	121;"	d
D_X509_ATTR	errlevel.h	104;"	d
DigestCalcHA1	httpdigest.c	/^DigestCalcHA1($/;"	f	signature:( IN char *pszAlg, IN char *pszUserName, IN char *pszRealm, IN char *pszPassword, IN char *pszNonce, IN char *pszCNonce, OUT HASHHEX SessionKey )
DigestCalcHA1	httpdigest.h	/^void DigestCalcHA1($/;"	p	signature:( IN char *pszAlg, IN char *pszUserName, IN char *pszRealm, IN char *pszPassword, IN char *pszNonce, IN char *pszCNonce, OUT HASHHEX SessionKey )
DigestCalcResponse	httpdigest.c	/^DigestCalcResponse($/;"	f	signature:( IN HASHHEX HA1, IN char *pszNonce, IN char *pszNonceCount, IN char *pszCNonce, IN char *pszQop, IN char *pszMethod, IN char *pszDigestUri, IN HASHHEX HEntity, OUT HASHHEX Response )
DigestCalcResponse	httpdigest.h	/^void DigestCalcResponse($/;"	p	signature:( IN HASHHEX HA1, IN char *pszNonce, IN char *pszNonceCount, IN char *pszCNonce, IN char *pszQop, IN char *pszMethod, IN char *pszDigestUri, IN HASHHEX HEntity, OUT HASHHEX Response )
EC_GROUP_order_bits	openssl_compat.h	/^EC_GROUP_order_bits(const EC_GROUP *group)$/;"	f	signature:(const EC_GROUP *group)
EKS_INPUT	manage.h	293;"	d
EKS_READY	manage.h	294;"	d
EKS_SOLICIT	manage.h	292;"	d
EKS_UNDEF	manage.h	291;"	d
EMPTY_ARRAY_SIZE	syshead.h	393;"	d
EMPTY_ARRAY_SIZE	syshead.h	394;"	d
ENABLE_CLIENT_CR	syshead.h	681;"	d
ENABLE_CRYPTOAPI	syshead.h	619;"	d
ENABLE_DEF_AUTH	syshead.h	547;"	d
ENABLE_FEATURE_EXECVE	syshead.h	509;"	d
ENABLE_FEATURE_SHAPER	syshead.h	658;"	d
ENABLE_IP_PKTINFO	syshead.h	429;"	d
ENABLE_IP_PKTINFO	syshead.h	431;"	d
ENABLE_MEMSTATS	syshead.h	703;"	d
ENABLE_OCC	syshead.h	595;"	d
ENABLE_PF	syshead.h	580;"	d
ENABLE_PREDICTION_RESISTANCE	syshead.h	559;"	d
ENABLE_PUSH_PEER_INFO	syshead.h	688;"	d
ENCODE_MUTE_LEVEL	error.h	123;"	d
EPOLL	syshead.h	635;"	d
EPOLL	syshead.h	637;"	d
ERRLEVEL_H	errlevel.h	25;"	d
ERROR_H	error.h	25;"	d
ERR_BUF_SIZE	error.h	37;"	d
ERR_BUF_SIZE	error.h	39;"	d
ERR_LIB_CRYPTOAPI	cryptoapi.c	76;"	d	file:
ERR_MAP_SZ	cryptoapi.c	151;"	d	file:
ES_ERROR	openvpn.h	244;"	d
ES_TIMEOUT	openvpn.h	245;"	d
ETHERNET_MTU	mtu.h	54;"	d
ETT_DEFAULT	interval.h	213;"	d
EVENT_H	event.h	25;"	d
EVENT_LOOP_CHECK_SIGNAL	openvpn.h	553;"	d
EVENT_METHOD_FAST	event.h	42;"	d
EVENT_METHOD_US_TIMEOUT	event.h	41;"	d
EVENT_READ	event.h	36;"	d
EVENT_UNDEF	event.h	35;"	d
EVENT_WRITE	event.h	37;"	d
EVP_MD_CTX_free	openssl_compat.h	/^EVP_MD_CTX_free(EVP_MD_CTX *ctx)$/;"	f	signature:(EVP_MD_CTX *ctx)
EVP_MD_CTX_new	openssl_compat.h	/^EVP_MD_CTX_new(void)$/;"	f	signature:(void)
EVP_MD_CTX_reset	openssl_compat.h	/^EVP_MD_CTX_reset(EVP_MD_CTX *ctx)$/;"	f	signature:(EVP_MD_CTX *ctx)
EVP_PKEY_get0_DSA	openssl_compat.h	/^EVP_PKEY_get0_DSA(EVP_PKEY *pkey)$/;"	f	signature:(EVP_PKEY *pkey)
EVP_PKEY_get0_EC_KEY	openssl_compat.h	/^EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey)$/;"	f	signature:(EVP_PKEY *pkey)
EVP_PKEY_get0_RSA	openssl_compat.h	/^EVP_PKEY_get0_RSA(EVP_PKEY *pkey)$/;"	f	signature:(EVP_PKEY *pkey)
EVP_PKEY_id	openssl_compat.h	/^EVP_PKEY_id(const EVP_PKEY *pkey)$/;"	f	signature:(const EVP_PKEY *pkey)
EXIT_FATAL	error.h	147;"	d
EXPANDED_SIZE	mtu.h	172;"	d
EXPANDED_SIZE_DYNAMIC	mtu.h	173;"	d
EXPANDED_SIZE_MIN	mtu.h	174;"	d
EXPONENTIAL_BACKOFF	reliable.h	46;"	d
EXTENDED_SOCKET_ERROR_CAPABILITY	syshead.h	419;"	d
EXTENDED_SOCKET_ERROR_CAPABILITY	syshead.h	421;"	d
EXTRA_FRAME	mtu.h	145;"	d
FAILURE	ssl_verify_backend.h	/^typedef enum { SUCCESS = 0, FAILURE = 1 } result_t;$/;"	e	enum:__anon9
FD_MISC_H	fdmisc.h	25;"	d
FD_SET	fdmisc.h	47;"	d
FHE_CAPS	buffer.h	493;"	d
FHE_SPACE_BREAK_MASK	buffer.h	492;"	d
FILE_CLOSED	openvpn.h	251;"	d
FIREWALL_NAME	block_dns.c	/^static WCHAR *FIREWALL_NAME = L"OpenVPN";$/;"	v	file:
FORWARD_H	forward.h	32;"	d
FORWARD_INLINE_H	forward-inline.h	25;"	d
FRAGMENT_H	fragment.h	25;"	d
FRAG_ERR	fragment.c	39;"	d	file:
FRAG_EXTRA_MASK	fragment.h	250;"	d
FRAG_EXTRA_SHIFT	fragment.h	252;"	d
FRAG_ID_MASK	fragment.h	223;"	d
FRAG_ID_SHIFT	fragment.h	225;"	d
FRAG_MAP_MASK	fragment.h	71;"	d
FRAG_SEQ_ID_MASK	fragment.h	219;"	d
FRAG_SEQ_ID_SHIFT	fragment.h	221;"	d
FRAG_SIZE_MASK	fragment.h	237;"	d
FRAG_SIZE_ROUND_MASK	fragment.h	242;"	d
FRAG_SIZE_ROUND_SHIFT	fragment.h	241;"	d
FRAG_SIZE_SHIFT	fragment.h	239;"	d
FRAG_TEST	fragment.h	214;"	d
FRAG_TTL_SEC	fragment.h	54;"	d
FRAG_TYPE_MASK	fragment.h	202;"	d
FRAG_TYPE_SHIFT	fragment.h	204;"	d
FRAG_WAKEUP_INTERVAL	fragment.h	57;"	d
FRAG_WHOLE	fragment.h	206;"	d
FRAG_YES_LAST	fragment.h	211;"	d
FRAG_YES_NOTLAST	fragment.h	208;"	d
FRAME_HEADROOM	mtu.h	187;"	d
FRAME_HEADROOM_ADJ	mtu.h	188;"	d
FRAME_HEADROOM_BASE	mtu.h	186;"	d
FRAME_HEADROOM_MARKER_DECRYPT	mtu.h	129;"	d
FRAME_HEADROOM_MARKER_FRAGMENT	mtu.h	130;"	d
FRAME_HEADROOM_MARKER_READ_LINK	mtu.h	131;"	d
FRAME_HEADROOM_MARKER_READ_STREAM	mtu.h	132;"	d
FULL_SYNC	ssl.c	2108;"	d	file:
FWPM_SESSION_FLAG_DYNAMIC	block_dns.c	52;"	d	file:
GETADDR_CACHE_MASK	socket.h	533;"	d
GETADDR_DATAGRAM	socket.h	531;"	d
GETADDR_FATAL	socket.h	521;"	d
GETADDR_FATAL_ON_SIGNAL	socket.h	524;"	d
GETADDR_HOST_ORDER	socket.h	522;"	d
GETADDR_MENTION_RESOLVE_RETRY	socket.h	523;"	d
GETADDR_MSG_VIRT_OUT	socket.h	526;"	d
GETADDR_PASSIVE	socket.h	530;"	d
GETADDR_RANDOMIZE	socket.h	529;"	d
GETADDR_RESOLVE	socket.h	520;"	d
GETADDR_TRY_ONCE	socket.h	527;"	d
GETADDR_UPDATE_MANAGEMENT_STATE	socket.h	528;"	d
GETADDR_WARN_ON_SIGNAL	socket.h	525;"	d
GET_USER_PASS_DYNAMIC_CHALLENGE	misc.h	235;"	d
GET_USER_PASS_INLINE_CREDS	misc.h	239;"	d
GET_USER_PASS_MANAGEMENT	misc.h	227;"	d
GET_USER_PASS_NEED_OK	misc.h	230;"	d
GET_USER_PASS_NEED_STR	misc.h	232;"	d
GET_USER_PASS_NOFATAL	misc.h	231;"	d
GET_USER_PASS_PASSWORD_ONLY	misc.h	229;"	d
GET_USER_PASS_PREVIOUS_CREDS_FAILED	misc.h	233;"	d
GET_USER_PASS_STATIC_CHALLENGE	misc.h	236;"	d
GET_USER_PASS_STATIC_CHALLENGE_ECHO	misc.h	237;"	d
GREMLIN_CONNECTION_FLOOD_LEVEL	gremlin.h	52;"	d
GREMLIN_CONNECTION_FLOOD_MASK	gremlin.h	34;"	d
GREMLIN_CONNECTION_FLOOD_SHIFT	gremlin.h	33;"	d
GREMLIN_CORRUPT_LEVEL	gremlin.h	54;"	d
GREMLIN_CORRUPT_MASK	gremlin.h	40;"	d
GREMLIN_CORRUPT_SHIFT	gremlin.h	39;"	d
GREMLIN_DROP_LEVEL	gremlin.h	56;"	d
GREMLIN_DROP_MASK	gremlin.h	48;"	d
GREMLIN_DROP_SHIFT	gremlin.h	47;"	d
GREMLIN_H	gremlin.h	25;"	d
GREMLIN_PACKET_FLOOD_LEVEL	gremlin.h	53;"	d
GREMLIN_PACKET_FLOOD_MASK	gremlin.h	37;"	d
GREMLIN_PACKET_FLOOD_SHIFT	gremlin.h	36;"	d
GREMLIN_UP_DOWN_LEVEL	gremlin.h	55;"	d
GREMLIN_UP_DOWN_MASK	gremlin.h	43;"	d
GREMLIN_UP_DOWN_SHIFT	gremlin.h	42;"	d
HANDLE_DEFINED	win32.h	60;"	d
HASH	httpdigest.h	/^typedef unsigned char HASH[HASHLEN];$/;"	t
HASHHEX	httpdigest.h	/^typedef unsigned char HASHHEX[HASHHEXLEN+1];$/;"	t
HASHHEXLEN	httpdigest.h	28;"	d
HASHLEN	httpdigest.h	26;"	d
HAVE_CPP_VARARG_MACRO_GCC	syshead.h	391;"	d
HAVE_CPP_VARARG_MACRO_ISO	syshead.h	392;"	d
HAVE_GETTIMEOFDAY_NANOSECONDS	syshead.h	412;"	d
HAVE_VARARG_MACROS	error.h	150;"	d
HAVE_VARARG_MACROS	error.h	158;"	d
HELPER_H	helper.h	29;"	d
HMAC_CTX_free	openssl_compat.h	/^HMAC_CTX_free(HMAC_CTX *ctx)$/;"	f	signature:(HMAC_CTX *ctx)
HMAC_CTX_new	openssl_compat.h	/^HMAC_CTX_new(void)$/;"	f	signature:(void)
HMAC_CTX_reset	openssl_compat.h	/^HMAC_CTX_reset(HMAC_CTX *ctx)$/;"	f	signature:(HMAC_CTX *ctx)
HTTP_AUTH_BASIC	proxy.h	32;"	d
HTTP_AUTH_DIGEST	proxy.h	33;"	d
HTTP_AUTH_N	proxy.h	36;"	d
HTTP_AUTH_NONE	proxy.h	31;"	d
HTTP_AUTH_NTLM	proxy.h	34;"	d
HTTP_AUTH_NTLM2	proxy.h	35;"	d
IA_EMPTY_IF_UNDEF	socket.h	393;"	d
IA_NET_ORDER	socket.h	394;"	d
IEC_CERTIFICATE	manage.h	283;"	d
IEC_CLIENT_AUTH	manage.h	280;"	d
IEC_CLIENT_PF	manage.h	281;"	d
IEC_RSA_SIGN	manage.h	282;"	d
IEC_UNDEF	manage.h	279;"	d
IER_NEW	manage.c	853;"	d	file:
IER_RESET	manage.c	852;"	d	file:
IFCONFIG_AFTER_TUN_OPEN	tun.h	287;"	d
IFCONFIG_BEFORE_TUN_OPEN	tun.h	286;"	d
IFCONFIG_DEFAULT	tun.h	289;"	d
IFCONFIG_POOL_30NET	pool.h	37;"	d
IFCONFIG_POOL_INDIV	pool.h	38;"	d
IFCONFIG_POOL_MAX	pool.h	34;"	d
IFCONFIG_POOL_MIN_NETBITS	pool.h	35;"	d
IF_NAMESIZE	socket.c	2877;"	d	file:
IN	httpdigest.h	30;"	d
IN	httpdigest.h	32;"	d
IN6_ARE_ADDR_EQUAL	win32.h	44;"	d
INCR_ERROR	ssl.c	106;"	d	file:
INCR_ERROR	ssl.c	91;"	d	file:
INCR_GENERATED	ssl.c	104;"	d	file:
INCR_GENERATED	ssl.c	89;"	d	file:
INCR_SENT	ssl.c	103;"	d	file:
INCR_SENT	ssl.c	88;"	d	file:
INCR_SUCCESS	ssl.c	105;"	d	file:
INCR_SUCCESS	ssl.c	90;"	d	file:
INETD_NONE	socket.h	191;"	d
INETD_NOWAIT	socket.h	193;"	d
INETD_SOCKET_DESCRIPTOR	misc.h	35;"	d
INETD_WAIT	socket.h	192;"	d
INFO_CALLBACK_SSL_CONST	ssl_openssl.c	180;"	d	file:
INIT_H	init.h	25;"	d
INLINE_FILE_TAG	common.h	97;"	d
INOTIFY_EVENT_BUFFER_SIZE	multi.c	32;"	d	file:
INTEGER_H	integer.h	25;"	d
INTERVAL_DEBUG	interval.h	35;"	d
INTERVAL_H	interval.h	31;"	d
IN_TREE	schedule.h	77;"	d
IOSTATE_IMMEDIATE_RETURN	win32.h	197;"	d
IOSTATE_INITIAL	win32.h	195;"	d
IOSTATE_QUEUED	win32.h	196;"	d
IOSTAT_EAGAIN_ON_READ	ps.c	59;"	d	file:
IOSTAT_EAGAIN_ON_WRITE	ps.c	60;"	d	file:
IOSTAT_GOOD	ps.c	63;"	d	file:
IOSTAT_READ_ERROR	ps.c	61;"	d	file:
IOSTAT_WRITE_ERROR	ps.c	62;"	d	file:
IOW_CHECK_RESIDUAL	forward.h	55;"	d
IOW_FRAG	forward.h	56;"	d
IOW_MBUF	forward.h	57;"	d
IOW_READ	forward.h	61;"	d
IOW_READ_LINK	forward.h	53;"	d
IOW_READ_TUN	forward.h	52;"	d
IOW_READ_TUN_FORCE	forward.h	58;"	d
IOW_SHAPER	forward.h	54;"	d
IOW_TO_LINK	forward.h	51;"	d
IOW_TO_TUN	forward.h	50;"	d
IOW_WAIT_SIGNAL	forward.h	59;"	d
IPV4_INVALID_ADDR	socket.h	428;"	d
IPV4_NETMASK_HOST	basic.h	35;"	d
IPV6_V6ONLY	socket.c	1366;"	d	file:
IPW32_SET_ADAPTIVE	tun.h	56;"	d
IPW32_SET_ADAPTIVE_DELAY_WINDOW	tun.h	45;"	d
IPW32_SET_ADAPTIVE_TRY_NETSH	tun.h	46;"	d
IPW32_SET_DHCP_MASQ	tun.h	55;"	d
IPW32_SET_IPAPI	tun.h	54;"	d
IPW32_SET_MANUAL	tun.h	52;"	d
IPW32_SET_N	tun.h	57;"	d
IPW32_SET_NETSH	tun.h	53;"	d
IP_MCAST_NETWORK	mroute.h	36;"	d
IP_MCAST_SUBNET_MASK	mroute.h	35;"	d
IPv4_TCP_HEADER_SIZE	socket.h	594;"	d
IPv4_UDP_HEADER_SIZE	socket.h	593;"	d
IPv6_TCP_HEADER_SIZE	socket.h	596;"	d
IPv6_UDP_HEADER_SIZE	socket.h	595;"	d
ISC_ERRORS	init.h	116;"	d
ISC_SERVER	init.h	117;"	d
IS_SIG	sig.h	50;"	d
IS_TYPE_BUF	options.c	4390;"	d	file:
IS_TYPE_FP	options.c	4389;"	d	file:
IVM_LEVEL_1	init.h	49;"	d
IVM_LEVEL_2	init.h	50;"	d
InitializeIpInterfaceEntry	block_dns.c	/^InitializeIpInterfaceEntry(PMIB_IPINTERFACE_ROW Row);$/;"	p	file:	signature:(PMIB_IPINTERFACE_ROW Row)
KEY_DIRECTION_BIDIRECTIONAL	crypto.h	176;"	d
KEY_DIRECTION_INVERSE	crypto.h	178;"	d
KEY_DIRECTION_NORMAL	crypto.h	177;"	d
KEY_EXPANSION_ID	ssl.h	49;"	d
KEY_METHOD_MASK	ssl.h	118;"	d
KEY_METHOD_MAX	ssl.h	115;"	d
KEY_METHOD_MIN	ssl.h	114;"	d
KEY_SCAN_SIZE	ssl_common.h	462;"	d
KMDA_DEF	ssl_verify.c	1233;"	d	file:
KMDA_ERROR	ssl_verify.c	1230;"	d	file:
KMDA_SUCCESS	ssl_verify.c	1231;"	d	file:
KMDA_UNDEF	ssl_verify.c	1232;"	d	file:
KS_LAME_DUCK	ssl_common.h	358;"	d
KS_PRIMARY	ssl_common.h	357;"	d
KS_SIZE	ssl_common.h	360;"	d
LINK_MTU_DEFAULT	mtu.h	65;"	d
LINK_OUT	forward.h	39;"	d
LIST_H	list.h	25;"	d
LOGLEV	error.h	136;"	d
LOG_ECHO_TO_LOG	manage.h	116;"	d
LOG_FATAL_NOTIFY	manage.h	110;"	d
LOG_OPENVPN	error.c	48;"	d	file:
LOG_PRINT_CRLF	manage.h	109;"	d
LOG_PRINT_ECHO_PREFIX	manage.h	101;"	d
LOG_PRINT_INTVAL	manage.h	112;"	d
LOG_PRINT_INT_DATE	manage.h	104;"	d
LOG_PRINT_LOCAL_IP	manage.h	107;"	d
LOG_PRINT_LOG_PREFIX	manage.h	100;"	d
LOG_PRINT_MSG_FLAGS	manage.h	105;"	d
LOG_PRINT_REMOTE_IP	manage.h	114;"	d
LOG_PRINT_STATE	manage.h	106;"	d
LOG_PRINT_STATE_PREFIX	manage.h	102;"	d
LOG_RW	errlevel.h	46;"	d
LR_ERROR	route.c	1479;"	d	file:
LR_MATCH	route.c	1478;"	d	file:
LR_NOMATCH	route.c	1477;"	d	file:
LS_MODE_DEFAULT	socket.h	196;"	d
LS_MODE_TCP_ACCEPT_FROM	socket.h	198;"	d
LS_MODE_TCP_LISTEN	socket.h	197;"	d
LZ4_COMPRESS_BYTE	comp.h	73;"	d
LZO_COMPRESS	lzo.h	61;"	d
LZO_COMPRESS_BYTE	comp.h	72;"	d
LZO_DECOMPRESS	lzo.h	72;"	d
LZO_LIB_VER_STR	options.c	4120;"	d	file:
LZO_LIB_VER_STR	options.c	4128;"	d	file:
LZO_WORKSPACE	lzo.h	68;"	d
MANAGEMENT_DEF_AUTH	syshead.h	544;"	d
MANAGEMENT_ECHO_BUFFER_SIZE	manage.h	37;"	d
MANAGEMENT_ECHO_FLAGS	manage.c	55;"	d	file:
MANAGEMENT_ECHO_FLAGS	manage.c	57;"	d	file:
MANAGEMENT_ECHO_PULL_INFO	manage.c	52;"	d	file:
MANAGEMENT_IN_EXTRA	syshead.h	567;"	d
MANAGEMENT_LOG_HISTORY_INITIAL_SIZE	manage.h	36;"	d
MANAGEMENT_N_PASSWORD_RETRIES	manage.h	35;"	d
MANAGEMENT_PF	syshead.h	577;"	d
MANAGEMENT_READ	openvpn.h	247;"	d
MANAGEMENT_STATE_BUFFER_SIZE	manage.h	38;"	d
MANAGEMENT_VERSION	manage.h	34;"	d
MANAGEMENT_WRITE	openvpn.h	248;"	d
MANAGE_H	manage.h	25;"	d
MANAGMENT_EXTERNAL_KEY	syshead.h	554;"	d
MANSIG_IGNORE_USR1_HUP	manage.h	241;"	d
MANSIG_MAP_USR1_TO_HUP	manage.h	242;"	d
MANSIG_MAP_USR1_TO_TERM	manage.h	243;"	d
MAN_CLIENT_AUTH_ENABLED	options.h	687;"	d
MAN_CLIENT_AUTH_ENABLED	options.h	689;"	d
MAPF_IA_EMPTY_IF_UNDEF	mroute.h	157;"	d
MAPF_SHOW_ARP	mroute.h	158;"	d
MAPF_SUBNET	mroute.h	156;"	d
MAX_CERT_DEPTH	ssl_verify.h	53;"	d
MAX_CIPHER_KEY_LENGTH	crypto_backend.h	193;"	d
MAX_CLIENT_NAT	clinat.h	29;"	d
MAX_CUSTOM_HTTP_HEADER	proxy.h	43;"	d
MAX_FRAGS	fragment.h	73;"	d
MAX_FRAG_PKT_SIZE	fragment.h	154;"	d
MAX_HMAC_KEY_LENGTH	crypto_backend.h	470;"	d
MAX_PARMS	options.h	53;"	d
MAX_PEER_ID	openvpn.h	595;"	d
MAX_PLUGINS	plugin.h	43;"	d
MAX_RW_SIZE_LINK	mtu.h	181;"	d
MAX_RW_SIZE_TUN	mtu.h	180;"	d
MAX_SEQ_BACKTRACK	packet_id.h	106;"	d
MAX_SUBJECT_LENGTH	ssl_verify_mbedtls.c	47;"	d	file:
MAX_TIME_BACKTRACK	packet_id.h	115;"	d
MBUF_H	mbuf.h	25;"	d
MBUF_INDEX	mbuf.h	41;"	d
MCF_SERVER	manage.h	158;"	d
MC_MULTI_THREADED_MASTER	multi.h	134;"	d
MC_MULTI_THREADED_SCHEDULER	multi.h	136;"	d
MC_MULTI_THREADED_WORKER	multi.h	135;"	d
MC_SINGLE_THREADED	multi.h	133;"	d
MC_UNDEF	multi.h	132;"	d
MC_WORK_THREAD	multi.h	137;"	d
MD4_DIGEST_LENGTH	crypto_mbedtls.h	72;"	d
MD4_DIGEST_LENGTH	crypto_openssl.h	78;"	d
MD5SUM	openvpn.h	583;"	d
MD5SUM	openvpn.h	585;"	d
MD5_DIGEST_LENGTH	crypto_mbedtls.h	73;"	d
MD_SHA1	crypto_backend.h	/^    MD_SHA1,$/;"	e	enum:__anon15
MD_SHA256	crypto_backend.h	/^    MD_SHA256$/;"	e	enum:__anon15
MEMDBG_H	memdbg.h	25;"	d
METRIC_NOT_USED	route.c	54;"	d	file:
MF_CLIENT_AUTH	manage.h	344;"	d
MF_CLIENT_PF	manage.h	347;"	d
MF_CONNECT_AS_CLIENT	manage.h	342;"	d
MF_EXTERNAL_CERT	manage.h	356;"	d
MF_EXTERNAL_KEY	manage.h	351;"	d
MF_FORGET_DISCONNECT	manage.h	341;"	d
MF_HOLD	manage.h	339;"	d
MF_QUERY_PASSWORDS	manage.h	338;"	d
MF_QUERY_PROXY	manage.h	355;"	d
MF_QUERY_REMOTE	manage.h	354;"	d
MF_SERVER	manage.h	337;"	d
MF_SIGNAL	manage.h	340;"	d
MF_UNICAST	mbuf.h	48;"	d
MF_UNIX_SOCK	manage.h	349;"	d
MF_UP_DOWN	manage.h	353;"	d
MIB_TCP_STATE	syshead.h	/^typedef int MIB_TCP_STATE;$/;"	t
MIN_SEQ_BACKTRACK	packet_id.h	105;"	d
MIN_TIME_BACKTRACK	packet_id.h	114;"	d
MISC_H	misc.h	25;"	d
MN_AT_LEAST	manage.c	1158;"	d	file:
MODE_CLIENTS	pf.c	184;"	d	file:
MODE_POINT_TO_POINT	options.h	178;"	d
MODE_SERVER	options.h	179;"	d
MODE_SUBNETS	pf.c	185;"	d	file:
MODE_UNDEF	pf.c	183;"	d	file:
MPP_CLOSE_ON_SIGNAL	multi.h	258;"	d
MPP_CONDITIONAL_PRE_SELECT	multi.h	257;"	d
MPP_PRE_SELECT	multi.h	256;"	d
MPP_RECORD_TOUCH	multi.h	259;"	d
MROUTE_EXTRACT_BCAST	mroute.h	41;"	d
MROUTE_EXTRACT_IGMP	mroute.h	43;"	d
MROUTE_EXTRACT_MCAST	mroute.h	42;"	d
MROUTE_EXTRACT_SUCCEEDED	mroute.h	40;"	d
MROUTE_H	mroute.h	25;"	d
MROUTE_SEC_EXTRACT_BCAST	mroute.h	46;"	d
MROUTE_SEC_EXTRACT_IGMP	mroute.h	48;"	d
MROUTE_SEC_EXTRACT_MCAST	mroute.h	47;"	d
MROUTE_SEC_EXTRACT_SUCCEEDED	mroute.h	45;"	d
MROUTE_SEC_SHIFT	mroute.h	50;"	d
MR_ADDR_ETHER	mroute.h	63;"	d
MR_ADDR_IPV4	mroute.h	64;"	d
MR_ADDR_IPV6	mroute.h	65;"	d
MR_ADDR_MASK	mroute.h	66;"	d
MR_ADDR_NONE	mroute.h	62;"	d
MR_ARP	mroute.h	75;"	d
MR_HELPER_NET_LEN	mroute.h	125;"	d
MR_MAX_ADDR_LEN	mroute.h	57;"	d
MR_WITH_NETBITS	mroute.h	72;"	d
MR_WITH_PORT	mroute.h	69;"	d
MSG_NOSIGNAL	socket.h	256;"	d
MSSFIX_DEFAULT	mtu.h	80;"	d
MSS_H	mss.h	25;"	d
MSTATS_ACTIVE	mstats.h	40;"	d
MSTATS_EXPIRED	mstats.h	41;"	d
MSTATS_UNDEF	mstats.h	39;"	d
MS_CC_WAIT_READ	manage.h	257;"	d
MS_CC_WAIT_WRITE	manage.h	258;"	d
MS_INITIAL	manage.h	255;"	d
MS_LISTEN	manage.h	256;"	d
MTCP_FILE_CLOSE_WRITE	mtcp.c	69;"	d	file:
MTCP_H	mtcp.h	29;"	d
MTCP_MANAGEMENT	mtcp.c	65;"	d	file:
MTCP_N	mtcp.c	72;"	d	file:
MTCP_SIG	mtcp.c	63;"	d	file:
MTCP_SOCKET	mtcp.c	61;"	d	file:
MTCP_TUN	mtcp.c	62;"	d	file:
MTP_LINK_OUT	mtcp.c	532;"	d	file:
MTP_NONE	mtcp.c	530;"	d	file:
MTP_TUN_OUT	mtcp.c	531;"	d	file:
MTUDISC_NOT_SUPPORTED_MSG	mtu.c	166;"	d	file:
MTU_H	mtu.h	25;"	d
MTU_TO_MSS	proto.h	217;"	d
MUDP_H	mudp.h	29;"	d
MULTI_CACHE_ROUTE_TTL	multi.h	537;"	d
MULTI_CHECK_SIG	multi.h	648;"	d
MULTI_H	multi.h	29;"	d
MULTI_PREFIX_MAX_LENGTH	multi.h	44;"	d
MULTI_ROUTE_AGEABLE	multi.h	203;"	d
MULTI_ROUTE_CACHE	multi.h	202;"	d
MUST_BE_UNDEF	options.c	2712;"	d	file:
MUST_BE_UNDEF	options.c	2761;"	d	file:
MUTE_LEVEL_MASK	error.h	121;"	d
MUTE_LEVEL_SHIFT	error.h	120;"	d
MWCC_HOLD_WAIT	manage.c	3286;"	d	file:
MWCC_OTHER_WAIT	manage.c	3287;"	d	file:
MWCC_PASSWORD_WAIT	manage.c	3285;"	d	file:
M_CLIENT	error.h	112;"	d
M_DEBUG	error.h	97;"	d
M_DEBUG_LEVEL	error.h	92;"	d
M_ERR	error.h	110;"	d
M_ERRNO	error.h	99;"	d
M_FATAL	error.h	94;"	d
M_INFO	errlevel.h	55;"	d
M_MSG_VIRT_OUT	error.h	104;"	d
M_NOIPREFIX	error.h	107;"	d
M_NOLF	error.h	106;"	d
M_NOMUTE	error.h	101;"	d
M_NONFATAL	error.h	95;"	d
M_NOPREFIX	error.h	102;"	d
M_OPTERR	error.h	105;"	d
M_USAGE	error.h	111;"	d
M_USAGE_SMALL	error.h	103;"	d
M_VERB0	errlevel.h	53;"	d
M_WARN	error.h	96;"	d
NE32_PERSIST_EVENT	win32.h	80;"	d
NE32_WRITE_EVENT	win32.h	81;"	d
NETSH_PATH_SUFFIX	win32.h	32;"	d
NEXTADDR	route.c	3569;"	d	file:
NEXTADDR	route.c	3576;"	d	file:
NI_IP_NETMASK	tun.c	63;"	d	file:
NI_OPTIONS	tun.c	64;"	d	file:
NI_TEST_FIRST	tun.c	62;"	d	file:
NM_QUOTE_HINT	options.c	4846;"	d	file:
NONCE_SECRET_LEN_MAX	crypto.h	435;"	d
NONCE_SECRET_LEN_MIN	crypto.h	432;"	d
NO_COMPRESS_BYTE	comp.h	74;"	d
NO_COMPRESS_BYTE_SWAP	comp.h	75;"	d
NS_CERT_CHECK_CLIENT	ssl_verify.h	218;"	d
NS_CERT_CHECK_NONE	ssl_verify.h	214;"	d
NS_CERT_CHECK_SERVER	ssl_verify.h	216;"	d
NTLM	syshead.h	601;"	d
NTLM	syshead.h	603;"	d
NTLM_H	ntlm.h	2;"	d
N_DHCP_ADDR	tun.h	82;"	d
N_FRAG_BUF	fragment.h	49;"	d
N_ROUTE_BYPASS	route.h	54;"	d
N_SEQ_ID	fragment.h	142;"	d
OCC_EXIT	occ.h	69;"	d
OCC_H	occ.h	25;"	d
OCC_INLINE_H	occ-inline.h	25;"	d
OCC_INTERVAL_SECONDS	occ.h	48;"	d
OCC_MTU_LOAD	occ.h	55;"	d
OCC_MTU_LOAD_INTERVAL_SECONDS	occ.h	64;"	d
OCC_MTU_LOAD_REQUEST	occ.h	54;"	d
OCC_MTU_REPLY	occ.h	58;"	d
OCC_MTU_REQUEST	occ.h	56;"	d
OCC_N_TRIES	occ.h	49;"	d
OCC_REPLY	occ.h	39;"	d
OCC_REQUEST	occ.h	38;"	d
OCC_STRING_SIZE	occ.h	32;"	d
OIA_ERROR	socket.h	462;"	d
OIA_HOSTNAME	socket.h	460;"	d
OIA_IP	socket.h	461;"	d
OPENSSL_COMPAT_H_	openssl_compat.h	35;"	d
OPENVPN_AEAD_MIN_IV_LEN	crypto.h	275;"	d
OPENVPN_AEAD_TAG_LENGTH	crypto_backend.h	41;"	d
OPENVPN_BLOCK_DNS_H	block_dns.h	27;"	d
OPENVPN_COMP_H	comp.h	29;"	d
OPENVPN_COMP_LZ4_H	comp-lz4.h	26;"	d
OPENVPN_DEBUG_FILE	error.h	69;"	d
OPENVPN_ERROR_FP	error.h	49;"	d
OPENVPN_ETH_ALEN	proto.h	54;"	d
OPENVPN_ETH_P_ARP	proto.h	62;"	d
OPENVPN_ETH_P_IPV4	proto.h	60;"	d
OPENVPN_ETH_P_IPV6	proto.h	61;"	d
OPENVPN_EXECVE_ERROR	misc.h	61;"	d
OPENVPN_EXECVE_FAILURE	misc.h	63;"	d
OPENVPN_EXECVE_NOT_ALLOWED	misc.h	62;"	d
OPENVPN_EXIT_STATUS_CANNOT_OPEN_DEBUG_FILE	error.h	58;"	d
OPENVPN_EXIT_STATUS_ERROR	error.h	56;"	d
OPENVPN_EXIT_STATUS_GOOD	error.h	55;"	d
OPENVPN_EXIT_STATUS_USAGE	error.h	57;"	d
OPENVPN_H	openvpn.h	25;"	d
OPENVPN_IPH_GET_LEN	proto.h	86;"	d
OPENVPN_IPH_GET_VER	proto.h	85;"	d
OPENVPN_IPPROTO_IGMP	proto.h	98;"	d
OPENVPN_IPPROTO_TCP	proto.h	99;"	d
OPENVPN_IPPROTO_UDP	proto.h	100;"	d
OPENVPN_IP_OFFMASK	proto.h	93;"	d
OPENVPN_KU_REQUIRED	ssl_verify.h	221;"	d
OPENVPN_LZO_H	lzo.h	25;"	d
OPENVPN_MAX_CIPHER_BLOCK_SIZE	crypto_backend.h	44;"	d
OPENVPN_MAX_HMAC_SIZE	crypto_backend.h	47;"	d
OPENVPN_MAX_IV_LENGTH	crypto_mbedtls.h	52;"	d
OPENVPN_MAX_IV_LENGTH	crypto_openssl.h	53;"	d
OPENVPN_MEMSTATS_H	mstats.h	29;"	d
OPENVPN_MODE_CBC	crypto_mbedtls.h	55;"	d
OPENVPN_MODE_CBC	crypto_openssl.h	56;"	d
OPENVPN_MODE_CFB	crypto_mbedtls.h	61;"	d
OPENVPN_MODE_CFB	crypto_openssl.h	62;"	d
OPENVPN_MODE_GCM	crypto_mbedtls.h	64;"	d
OPENVPN_MODE_GCM	crypto_openssl.h	67;"	d
OPENVPN_MODE_OFB	crypto_mbedtls.h	58;"	d
OPENVPN_MODE_OFB	crypto_openssl.h	59;"	d
OPENVPN_MSG_FP	error.h	48;"	d
OPENVPN_OP_DECRYPT	crypto_mbedtls.h	70;"	d
OPENVPN_OP_DECRYPT	crypto_openssl.h	75;"	d
OPENVPN_OP_ENCRYPT	crypto_mbedtls.h	67;"	d
OPENVPN_OP_ENCRYPT	crypto_openssl.h	72;"	d
OPENVPN_PF_H	pf.h	27;"	d
OPENVPN_PKCS11_H	pkcs11.h	25;"	d
OPENVPN_PLUGIN_H	plugin.h	29;"	d
OPENVPN_PORT	socket.h	41;"	d
OPENVPN_SSL_H	ssl.h	30;"	d
OPENVPN_STATE_ADD_ROUTES	manage.h	496;"	d
OPENVPN_STATE_ASSIGN_IP	manage.h	495;"	d
OPENVPN_STATE_AUTH	manage.h	503;"	d
OPENVPN_STATE_CLIENT_BASE	manage.h	508;"	d
OPENVPN_STATE_CONNECTED	manage.h	497;"	d
OPENVPN_STATE_CONNECTING	manage.h	494;"	d
OPENVPN_STATE_EXITING	manage.h	499;"	d
OPENVPN_STATE_GET_CONFIG	manage.h	504;"	d
OPENVPN_STATE_INITIAL	manage.h	493;"	d
OPENVPN_STATE_RECONNECTING	manage.h	498;"	d
OPENVPN_STATE_RESOLVE	manage.h	505;"	d
OPENVPN_STATE_TCP_CONNECT	manage.h	506;"	d
OPENVPN_STATE_WAIT	manage.h	502;"	d
OPENVPN_TCPH_ACK_MASK	proto.h	150;"	d
OPENVPN_TCPH_CWR_MASK	proto.h	153;"	d
OPENVPN_TCPH_ECE_MASK	proto.h	152;"	d
OPENVPN_TCPH_FIN_MASK	proto.h	146;"	d
OPENVPN_TCPH_GET_DOFF	proto.h	143;"	d
OPENVPN_TCPH_PSH_MASK	proto.h	149;"	d
OPENVPN_TCPH_RST_MASK	proto.h	148;"	d
OPENVPN_TCPH_SYN_MASK	proto.h	147;"	d
OPENVPN_TCPH_URG_MASK	proto.h	151;"	d
OPENVPN_TCPOLEN_MAXSEG	proto.h	164;"	d
OPENVPN_TCPOPT_EOL	proto.h	161;"	d
OPENVPN_TCPOPT_MAXSEG	proto.h	163;"	d
OPENVPN_TCPOPT_NOP	proto.h	162;"	d
OPENVPN_WIN32_H	win32.h	26;"	d
OPTIONS_H	options.h	30;"	d
OPTION_LINE_SIZE	options.h	59;"	d
OPTION_PARM_SIZE	options.h	58;"	d
OPT_P_COMP	options.h	631;"	d
OPT_P_CONFIG	options.h	639;"	d
OPT_P_CONNECTION	options.h	648;"	d
OPT_P_DEFAULT	options.h	651;"	d
OPT_P_ECHO	options.h	641;"	d
OPT_P_EXPLICIT_NOTIFY	options.h	640;"	d
OPT_P_GENERAL	options.h	621;"	d
OPT_P_INHERIT	options.h	642;"	d
OPT_P_INSTANCE	options.h	638;"	d
OPT_P_IPWIN32	options.h	624;"	d
OPT_P_MESSAGES	options.h	632;"	d
OPT_P_MTU	options.h	635;"	d
OPT_P_NCP	options.h	633;"	d
OPT_P_NICE	options.h	636;"	d
OPT_P_PEER_ID	options.h	649;"	d
OPT_P_PERSIST	options.h	629;"	d
OPT_P_PERSIST_IP	options.h	630;"	d
OPT_P_PLUGIN	options.h	645;"	d
OPT_P_PULL_MODE	options.h	644;"	d
OPT_P_PUSH	options.h	637;"	d
OPT_P_ROUTE	options.h	623;"	d
OPT_P_ROUTE_EXTRAS	options.h	643;"	d
OPT_P_SCRIPT	options.h	625;"	d
OPT_P_SETENV	options.h	626;"	d
OPT_P_SHAPER	options.h	627;"	d
OPT_P_SOCKBUF	options.h	646;"	d
OPT_P_SOCKFLAGS	options.h	647;"	d
OPT_P_TIMER	options.h	628;"	d
OPT_P_TLS_PARMS	options.h	634;"	d
OPT_P_UP	options.h	622;"	d
OS_SPECIFIC_DIRSEP	syshead.h	477;"	d
OS_SPECIFIC_DIRSEP	syshead.h	479;"	d
OTIME_H	otime.h	25;"	d
OUT	httpdigest.h	31;"	d
OUT	httpdigest.h	33;"	d
O_BINARY	syshead.h	470;"	d
P2MP	syshead.h	517;"	d
P2MP	syshead.h	519;"	d
P2MP_SERVER	syshead.h	523;"	d
P2MP_SERVER	syshead.h	525;"	d
P2P_CHECK_SIG	openvpn.c	42;"	d	file:
P2P_ERROR_DELAY_MS	errlevel.h	41;"	d
PACKET_ID_H	packet_id.h	33;"	d
PACKET_ID_MAX	packet_id.h	52;"	d
PACKET_ID_WRAP_TRIGGER	packet_id.h	60;"	d
PACKET_ID_WRAP_TRIGGER	packet_id.h	85;"	d
PARSE_DATA	crypto.c	1271;"	d	file:
PARSE_DATA_COMPLETE	crypto.c	1272;"	d	file:
PARSE_FINISHED	crypto.c	1274;"	d	file:
PARSE_FOOT	crypto.c	1273;"	d	file:
PARSE_HEAD	crypto.c	1270;"	d	file:
PARSE_INITIAL	crypto.c	1269;"	d	file:
PAR_ALL	proxy.h	49;"	d
PAR_NCT	proxy.h	50;"	d
PAR_NO	proxy.h	48;"	d
PASSTOS_CAPABILITY	syshead.h	403;"	d
PASSTOS_CAPABILITY	syshead.h	405;"	d
PAYLOAD_ALIGN	mtu.h	86;"	d
PAYLOAD_SIZE	mtu.h	165;"	d
PAYLOAD_SIZE_DYNAMIC	mtu.h	166;"	d
PA_BRACKET	buffer.h	146;"	d
PCT_DEST	pf-inline.h	32;"	d
PCT_SRC	pf-inline.h	31;"	d
PD_SHOW_DATA	ssl.h	575;"	d
PD_TLS	ssl.h	576;"	d
PD_TLS_AUTH_HMAC_SIZE_MASK	ssl.h	574;"	d
PD_VERBOSE	ssl.h	577;"	d
PERF_BIO_READ_CIPHERTEXT	perf.h	40;"	d
PERF_BIO_READ_PLAINTEXT	perf.h	38;"	d
PERF_BIO_WRITE_CIPHERTEXT	perf.h	41;"	d
PERF_BIO_WRITE_PLAINTEXT	perf.h	39;"	d
PERF_EVENT_LOOP	perf.h	44;"	d
PERF_H	perf.h	31;"	d
PERF_IO_WAIT	perf.h	43;"	d
PERF_MULTI_BCAST	perf.h	48;"	d
PERF_MULTI_CLOSE_INSTANCE	perf.h	46;"	d
PERF_MULTI_CREATE_INSTANCE	perf.h	45;"	d
PERF_MULTI_MCAST	perf.h	49;"	d
PERF_MULTI_SHOW_STATS	perf.h	47;"	d
PERF_N	perf.h	58;"	d
PERF_PROC_IN_LINK	perf.h	52;"	d
PERF_PROC_IN_TUN	perf.h	54;"	d
PERF_PROC_OUT_LINK	perf.h	55;"	d
PERF_PROC_OUT_TUN	perf.h	56;"	d
PERF_PROC_OUT_TUN_MTCP	perf.h	57;"	d
PERF_READ_IN_LINK	perf.h	51;"	d
PERF_READ_IN_TUN	perf.h	53;"	d
PERF_SCRIPT	perf.h	50;"	d
PERF_TLS_MULTI_PROCESS	perf.h	42;"	d
PF_INLINE_H	pf-inline.h	25;"	d
PF_MAX_LINE_LEN	pf.h	32;"	d
PING_EXIT	options.h	259;"	d
PING_H	ping.h	25;"	d
PING_INLINE_H	ping-inline.h	25;"	d
PING_RESTART	options.h	260;"	d
PING_STRING_SIZE	ping.h	38;"	d
PING_UNDEF	options.h	258;"	d
PIPV4_CLIENT_NAT	forward.h	256;"	d
PIPV4_EXTRACT_DHCP_ROUTER	forward.h	255;"	d
PIPV4_OUTGOING	forward.h	254;"	d
PIPV4_PASSTOS	forward.h	252;"	d
PIP_MSSFIX	forward.h	253;"	d
PKCS11_BACKEND_H_	pkcs11_backend.h	30;"	d
PKTINFO_BUF_SIZE	socket.c	3350;"	d	file:
PKTINFO_BUF_SIZE	socket.c	3353;"	d	file:
PLATFORM_H	platform.h	25;"	d
PLUGIN_DEF_AUTH	syshead.h	541;"	d
PLUGIN_OPTION_LIST	options.h	681;"	d
PLUGIN_OPTION_LIST	options.h	683;"	d
PLUGIN_PF	syshead.h	574;"	d
PLUGIN_SYM	plugin.c	271;"	d	file:
PLUGIN_SYMBOL_REQUIRED	plugin.c	50;"	d	file:
POLL	syshead.h	626;"	d
POLL	syshead.h	628;"	d
POOL_H	pool.h	25;"	d
PORT_SHARE	syshead.h	532;"	d
PORT_SHARE	syshead.h	534;"	d
PRE_PULL_INITIAL_PING_RESTART	ping.h	33;"	d
PRNG_NONCE_RESET_BYTES	crypto.h	438;"	d
PROCESS_SIGNAL_P2P	openvpn.c	130;"	d	file:
PROTO_DUMP	openvpn.h	572;"	d
PROTO_DUMP	openvpn.h	579;"	d
PROTO_DUMP_FLAGS	openvpn.h	571;"	d
PROTO_H	proto.h	25;"	d
PROTO_N	socket.h	/^    PROTO_N$/;"	e	enum:proto_num
PROTO_NONE	socket.h	/^    PROTO_NONE,     \/* catch for uninitialized *\/$/;"	e	enum:proto_num
PROTO_TCP	socket.h	/^    PROTO_TCP,$/;"	e	enum:proto_num
PROTO_TCP_CLIENT	socket.h	/^    PROTO_TCP_CLIENT,$/;"	e	enum:proto_num
PROTO_TCP_SERVER	socket.h	/^    PROTO_TCP_SERVER,$/;"	e	enum:proto_num
PROTO_UDP	socket.h	/^    PROTO_UDP,$/;"	e	enum:proto_num
PROXY_CONNECTION_BUFFER_SIZE	ps.c	45;"	d	file:
PROXY_DIGEST_AUTH	syshead.h	610;"	d
PROXY_DIGEST_AUTH	syshead.h	612;"	d
PROXY_H	proxy.h	25;"	d
PS_DISABLED	socket.h	143;"	d
PS_DONT_SHOW_ADDR	socket.h	348;"	d
PS_DONT_SHOW_FAMILY	socket.h	349;"	d
PS_ENABLED	socket.h	144;"	d
PS_FOREIGN	socket.h	145;"	d
PS_H	ps.h	25;"	d
PS_INITIAL	perf.c	66;"	d	file:
PS_METER_INTERRUPTED	perf.c	68;"	d	file:
PS_METER_RUNNING	perf.c	67;"	d	file:
PS_SHOW_PKTINFO	socket.h	347;"	d
PS_SHOW_PORT	socket.h	346;"	d
PS_SHOW_PORT_IF_DEFINED	socket.h	345;"	d
PUF_TYPE_ACCEPT	options.c	920;"	d	file:
PUF_TYPE_IGNORE	options.c	921;"	d	file:
PUF_TYPE_REJECT	options.c	922;"	d	file:
PUF_TYPE_UNDEF	options.c	919;"	d	file:
PULL_DEFINED	options.h	654;"	d
PULL_DEFINED	options.h	661;"	d
PUSHLIST_H	pushlist.h	25;"	d
PUSH_BUNDLE_SIZE	common.h	86;"	d
PUSH_DEFINED	options.h	656;"	d
PUSH_DEFINED	options.h	665;"	d
PUSH_H	push.h	25;"	d
PUSH_MSG_ALREADY_REPLIED	push.h	37;"	d
PUSH_MSG_AUTH_FAILURE	push.h	35;"	d
PUSH_MSG_CONTINUATION	push.h	36;"	d
PUSH_MSG_ERROR	push.h	31;"	d
PUSH_MSG_REPLY	push.h	33;"	d
PUSH_MSG_REQUEST	push.h	32;"	d
PUSH_MSG_REQUEST_DEFERRED	push.h	34;"	d
PUSH_REQUEST_INTERVAL	common.h	91;"	d
P_ACK_V1	ssl.h	60;"	d
P_CONTROL_HARD_RESET_CLIENT_V1	ssl.h	56;"	d
P_CONTROL_HARD_RESET_CLIENT_V2	ssl.h	65;"	d
P_CONTROL_HARD_RESET_SERVER_V1	ssl.h	57;"	d
P_CONTROL_HARD_RESET_SERVER_V2	ssl.h	66;"	d
P_CONTROL_SOFT_RESET_V1	ssl.h	58;"	d
P_CONTROL_V1	ssl.h	59;"	d
P_DATA_V1	ssl.h	61;"	d
P_DATA_V2	ssl.h	62;"	d
P_FIRST_OPCODE	ssl.h	69;"	d
P_KEY_ID_MASK	ssl.h	52;"	d
P_LAST_OPCODE	ssl.h	70;"	d
P_OPCODE_SHIFT	ssl.h	53;"	d
QUERY_USER_NUMSLOTS	console.h	42;"	d
REAP_DIVISOR	multi.h	529;"	d
REAP_MAX	multi.h	531;"	d
REAP_MAX_WAKEUP	multi.h	528;"	d
REAP_MIN	multi.h	530;"	d
RELIABLE_ACK_SIZE	reliable.h	48;"	d
RELIABLE_CAPACITY	reliable.h	53;"	d
RELIABLE_H	reliable.h	34;"	d
RESOLV_RETRY_INFINITE	socket.h	47;"	d
RESPONSE_INIT_FAILED	ps.c	53;"	d	file:
RESPONSE_INIT_SUCCEEDED	ps.c	52;"	d	file:
RGI_ADDR_DEFINED	route.h	146;"	d
RGI_HWADDR_DEFINED	route.h	148;"	d
RGI_IFACE_DEFINED	route.h	149;"	d
RGI_NETMASK_DEFINED	route.h	147;"	d
RGI_N_ADDRESSES	route.h	168;"	d
RGI_N_ADDRESSES	route.h	196;"	d
RGI_ON_LINK	route.h	151;"	d
RGI_OVERFLOW	route.h	150;"	d
RG_AUTO_LOCAL	route.h	89;"	d
RG_BLOCK_LOCAL	route.h	90;"	d
RG_BYPASS_DHCP	route.h	86;"	d
RG_BYPASS_DNS	route.h	87;"	d
RG_DEF1	route.h	85;"	d
RG_ENABLE	route.h	83;"	d
RG_LOCAL	route.h	84;"	d
RG_REROUTE_GW	route.h	88;"	d
RH_HOST_LEN	options.h	162;"	d
RH_PORT_LEN	options.h	164;"	d
RKF_INLINE	crypto.h	278;"	d
RKF_MUST_SUCCEED	crypto.h	277;"	d
RL_DID_LOCAL	route.h	203;"	d
RL_DID_REDIRECT_DEFAULT_GATEWAY	route.h	202;"	d
RL_ROUTES_ADDED	route.h	204;"	d
ROUNDUP	route.c	3561;"	d	file:
ROUNDUP	route.c	3564;"	d	file:
ROUTE_AFTER_TUN	tun.h	314;"	d
ROUTE_BEFORE_TUN	tun.h	313;"	d
ROUTE_DELETE_FIRST	route.h	49;"	d
ROUTE_H	route.h	29;"	d
ROUTE_METHOD_ADAPTIVE	route.h	39;"	d
ROUTE_METHOD_EXE	route.h	41;"	d
ROUTE_METHOD_IPAPI	route.h	40;"	d
ROUTE_METHOD_MASK	route.h	43;"	d
ROUTE_METHOD_SERVICE	route.h	42;"	d
ROUTE_OPTION_FLAGS	options.h	669;"	d
ROUTE_OPTION_FLAGS	options.h	671;"	d
ROUTE_ORDER_DEFAULT	tun.h	315;"	d
ROUTE_REF_GW	route.h	50;"	d
RSA_F_RSA_OSSL_PRIVATE_ENCRYPT	openssl_compat.h	681;"	d
RSA_bits	openssl_compat.h	/^RSA_bits(const RSA *rsa)$/;"	f	signature:(const RSA *rsa)
RSA_get0_key	openssl_compat.h	/^RSA_get0_key(const RSA *rsa, const BIGNUM **n,$/;"	f	signature:(const RSA *rsa, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
RSA_meth_free	openssl_compat.h	/^RSA_meth_free(RSA_METHOD *meth)$/;"	f	signature:(RSA_METHOD *meth)
RSA_meth_get0_app_data	openssl_compat.h	/^RSA_meth_get0_app_data(const RSA_METHOD *meth)$/;"	f	signature:(const RSA_METHOD *meth)
RSA_meth_new	openssl_compat.h	/^RSA_meth_new(const char *name, int flags)$/;"	f	signature:(const char *name, int flags)
RSA_meth_set0_app_data	openssl_compat.h	/^RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data)$/;"	f	signature:(RSA_METHOD *meth, void *app_data)
RSA_meth_set_finish	openssl_compat.h	/^RSA_meth_set_finish(RSA_METHOD *meth, int (*finish) (RSA *rsa))$/;"	f	signature:(RSA_METHOD *meth, int (*finish) (RSA *rsa))
RSA_meth_set_init	openssl_compat.h	/^RSA_meth_set_init(RSA_METHOD *meth, int (*init) (RSA *rsa))$/;"	f	signature:(RSA_METHOD *meth, int (*init) (RSA *rsa))
RSA_meth_set_priv_dec	openssl_compat.h	/^RSA_meth_set_priv_dec(RSA_METHOD *meth,$/;"	f	signature:(RSA_METHOD *meth, int (*priv_dec) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding))
RSA_meth_set_priv_enc	openssl_compat.h	/^RSA_meth_set_priv_enc(RSA_METHOD *meth,$/;"	f	signature:(RSA_METHOD *meth, int (*priv_enc) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding))
RSA_meth_set_pub_dec	openssl_compat.h	/^RSA_meth_set_pub_dec(RSA_METHOD *meth,$/;"	f	signature:(RSA_METHOD *meth, int (*pub_dec) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding))
RSA_meth_set_pub_enc	openssl_compat.h	/^RSA_meth_set_pub_enc(RSA_METHOD *meth,$/;"	f	signature:(RSA_METHOD *meth, int (*pub_enc) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding))
RSA_meth_set_sign	openssl_compat.h	/^int RSA_meth_set_sign(RSA_METHOD *meth,$/;"	f	signature:(RSA_METHOD *meth, int (*sign) (int type, const unsigned char *m, unsigned int m_length, unsigned char *sigret, unsigned int *siglen, const RSA *rsa))
RSA_set0_key	openssl_compat.h	/^RSA_set0_key(RSA *rsa, BIGNUM *n, BIGNUM *e, BIGNUM *d)$/;"	f	signature:(RSA *rsa, BIGNUM *n, BIGNUM *e, BIGNUM *d)
RSA_set_flags	openssl_compat.h	/^RSA_set_flags(RSA *rsa, int flags)$/;"	f	signature:(RSA *rsa, int flags)
RTSA_DEFAULT_METRIC	route.h	64;"	d
RTSA_REMOTE_ENDPOINT	route.h	62;"	d
RTSA_REMOTE_HOST	route.h	63;"	d
RT_ADDED	route.h	113;"	d
RT_DEFINED	route.h	112;"	d
RT_METRIC_DEFINED	route.h	114;"	d
SA_IP_PORT	socket.h	401;"	d
SA_SET_IF_NONZERO	socket.h	402;"	d
SCHEDULE_H	schedule.h	25;"	d
SCRIPT_SECURITY_WARNING	common.h	102;"	d
SC_ECHO	misc.h	213;"	d
SDL_CONSTRAIN	error.h	203;"	d
SELECT	event.c	52;"	d	file:
SELECT	event.c	54;"	d	file:
SELECT_MAX_FDS	event.c	62;"	d	file:
SELECT_MAX_FDS	event.c	64;"	d	file:
SELECT_PREFERRED_OVER_POLL	event.c	45;"	d	file:
SEQ_EXPIRED	packet_id.c	56;"	d	file:
SEQ_REAP_INTERVAL	packet_id.h	125;"	d
SEQ_UNSEEN	packet_id.c	55;"	d	file:
SESSION_ID_H	session_id.h	35;"	d
SET_MTU_TUN	mtu.h	220;"	d
SET_MTU_UPPER_BOUND	mtu.h	221;"	d
SF_GETADDRINFO_DGRAM	socket.h	212;"	d
SF_HOST_RANDOMIZE	socket.h	211;"	d
SF_NOPOOL	options.h	388;"	d
SF_NO_PUSH_ROUTE_GATEWAY	options.h	390;"	d
SF_PORT_SHARE	socket.h	210;"	d
SF_TCP_NODELAY	socket.h	209;"	d
SF_TCP_NODELAY_HELPER	options.h	389;"	d
SF_USE_IP_PKTINFO	socket.h	208;"	d
SHA256_DIGEST_LENGTH	crypto_mbedtls.h	75;"	d
SHAPER_DEFINED	options.h	675;"	d
SHAPER_DEFINED	options.h	677;"	d
SHAPER_H	shaper.h	25;"	d
SHAPER_MAX	shaper.h	43;"	d
SHAPER_MAX_TIMEOUT	shaper.h	45;"	d
SHAPER_MIN	shaper.h	42;"	d
SHAPER_USE_FP	shaper.h	47;"	d
SHA_DIGEST_LENGTH	crypto_mbedtls.h	74;"	d
SHOW_BOOL	options.c	1798;"	d	file:
SHOW_BOOL	options.c	963;"	d	file:
SHOW_INT	options.c	1797;"	d	file:
SHOW_INT	options.c	960;"	d	file:
SHOW_PARM	options.c	1795;"	d	file:
SHOW_PARM	options.c	958;"	d	file:
SHOW_STR	options.c	1796;"	d	file:
SHOW_STR	options.c	959;"	d	file:
SHOW_UINT	options.c	961;"	d	file:
SHOW_UNSIGNED	options.c	962;"	d	file:
SID_SIZE	session_id.h	47;"	d
SIG_H	sig.h	25;"	d
SIG_SOURCE_CONNECTION_FAILED	sig.h	37;"	d
SIG_SOURCE_HARD	sig.h	33;"	d
SIG_SOURCE_SOFT	sig.h	32;"	d
SIZE	basic.h	30;"	d
SM_POST_INIT	sig.c	234;"	d	file:
SM_PRE_INIT	sig.c	233;"	d	file:
SM_UNDEF	sig.c	232;"	d	file:
SOCKET_H	socket.h	25;"	d
SOCKET_READ	openvpn.h	240;"	d
SOCKET_UNDEFINED	syshead.h	486;"	d
SOCKET_UNDEFINED	syshead.h	489;"	d
SOCKET_WRITE	openvpn.h	241;"	d
SOCKS_H	socks.h	30;"	d
SOL_IP	syshead.h	439;"	d
SSEC_BUILT_IN	misc.h	296;"	d
SSEC_NONE	misc.h	295;"	d
SSEC_PW_ENV	misc.h	298;"	d
SSEC_SCRIPTS	misc.h	297;"	d
SSLAPI	ssl_backend.h	38;"	d
SSLAPI	ssl_backend.h	43;"	d
SSLAPI	ssl_backend.h	48;"	d
SSLF_AUTH_USER_PASS_OPTIONAL	ssl_common.h	322;"	d
SSLF_CLIENT_CERT_NOT_REQUIRED	ssl_common.h	319;"	d
SSLF_CLIENT_CERT_OPTIONAL	ssl_common.h	320;"	d
SSLF_CRL_VERIFY_DIR	ssl_common.h	324;"	d
SSLF_OPT_VERIFY	ssl_common.h	323;"	d
SSLF_TLS_VERSION_MAX_MASK	ssl_common.h	328;"	d
SSLF_TLS_VERSION_MAX_SHIFT	ssl_common.h	327;"	d
SSLF_TLS_VERSION_MIN_MASK	ssl_common.h	326;"	d
SSLF_TLS_VERSION_MIN_SHIFT	ssl_common.h	325;"	d
SSLF_USERNAME_AS_COMMON_NAME	ssl_common.h	321;"	d
SSL_BACKEND_H_	ssl_backend.h	31;"	d
SSL_COMMON_H_	ssl_common.h	30;"	d
SSL_CTX_get_default_passwd_cb	openssl_compat.h	/^SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)$/;"	f	signature:(SSL_CTX *ctx)
SSL_CTX_get_default_passwd_cb_userdata	openssl_compat.h	/^SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx)$/;"	f	signature:(SSL_CTX *ctx)
SSL_CTX_get_max_proto_version	openssl_compat.h	/^SSL_CTX_get_max_proto_version(SSL_CTX *ctx)$/;"	f	signature:(SSL_CTX *ctx)
SSL_CTX_get_min_proto_version	openssl_compat.h	/^SSL_CTX_get_min_proto_version(SSL_CTX *ctx)$/;"	f	signature:(SSL_CTX *ctx)
SSL_CTX_set_max_proto_version	openssl_compat.h	/^SSL_CTX_set_max_proto_version(SSL_CTX *ctx, long tls_ver_max)$/;"	f	signature:(SSL_CTX *ctx, long tls_ver_max)
SSL_CTX_set_min_proto_version	openssl_compat.h	/^SSL_CTX_set_min_proto_version(SSL_CTX *ctx, long tls_ver_min)$/;"	f	signature:(SSL_CTX *ctx, long tls_ver_min)
SSL_CTX_use_CryptoAPI_certificate	cryptoapi.c	/^SSL_CTX_use_CryptoAPI_certificate(SSL_CTX *ssl_ctx, const char *cert_prop)$/;"	f	signature:(SSL_CTX *ssl_ctx, const char *cert_prop)
SSL_CTX_use_CryptoAPI_certificate	cryptoapi.h	/^int SSL_CTX_use_CryptoAPI_certificate(SSL_CTX *ssl_ctx, const char *cert_prop);$/;"	p	signature:(SSL_CTX *ssl_ctx, const char *cert_prop)
SSL_LIB_VER_STR	options.c	4115;"	d	file:
SSL_LIB_VER_STR	options.c	4127;"	d	file:
SSL_MBEDTLS_H_	ssl_mbedtls.h	30;"	d
SSL_OPENSSL_H_	ssl_openssl.h	30;"	d
SSL_OP_NO_TICKET	ssl_openssl.h	42;"	d
SSL_SIG_LENGTH	cryptoapi.c	73;"	d	file:
SSL_VERIFY_BACKEND_H_	ssl_verify_backend.h	30;"	d
SSL_VERIFY_H_	ssl_verify.h	30;"	d
SSL_VERIFY_MBEDTLS_H_	ssl_verify_mbedtls.h	30;"	d
SSL_VERIFY_OPENSSL_H_	ssl_verify_openssl.h	31;"	d
STACK_N	perf.h	67;"	d
STATUS_H	status.h	25;"	d
STATUS_OUTPUT_READ	status.h	50;"	d
STATUS_OUTPUT_WRITE	status.h	51;"	d
STATUS_PRINTF_MAXLEN	status.c	236;"	d	file:
SUB_CHECKSUM_32	proto.h	204;"	d
SUCCESS	ssl_verify_backend.h	/^typedef enum { SUCCESS = 0, FAILURE = 1 } result_t;$/;"	e	enum:__anon9
SWAP	error.c	209;"	d	file:
SWAP_BUF_SIZE	ssl.c	1408;"	d	file:
SWAP_BUF_SIZE	ssl.c	1460;"	d	file:
SYSHEAD_H	syshead.h	25;"	d
SYSLOG_CAPABILITY	syshead.h	461;"	d
SYSLOG_CAPABILITY	syshead.h	463;"	d
SYS_PATH_ENV_VAR_NAME	win32.h	31;"	d
S_ACTIVE	ssl_common.h	93;"	d
S_ERROR	ssl_common.h	77;"	d
S_ERROR	syshead.h	251;"	d
S_FATAL	misc.h	56;"	d
S_GOT_KEY	ssl_common.h	90;"	d
S_INITIAL	ssl_common.h	80;"	d
S_NORMAL_OP	ssl_common.h	98;"	d
S_PRE_START	ssl_common.h	83;"	d
S_SCRIPT	misc.h	55;"	d
S_SENT_KEY	ssl_common.h	88;"	d
S_START	ssl_common.h	86;"	d
S_UNDEF	ssl_common.h	78;"	d
TAP_MTU_EXTRA_DEFAULT	mtu.h	75;"	d
TA_INITIAL	mtcp.c	54;"	d	file:
TA_SOCKET_READ	mtcp.c	47;"	d	file:
TA_SOCKET_READ_RESIDUAL	mtcp.c	48;"	d	file:
TA_SOCKET_WRITE	mtcp.c	49;"	d	file:
TA_SOCKET_WRITE_DEFERRED	mtcp.c	51;"	d	file:
TA_SOCKET_WRITE_READY	mtcp.c	50;"	d	file:
TA_TIMEOUT	mtcp.c	55;"	d	file:
TA_TUN_READ	mtcp.c	52;"	d	file:
TA_TUN_WRITE	mtcp.c	53;"	d	file:
TA_TUN_WRITE_TIMEOUT	mtcp.c	56;"	d	file:
TA_UNDEF	mtcp.c	46;"	d	file:
TIME_BACKTRACK_PROTECTION	syshead.h	651;"	d
TLA_LOCAL	route.h	335;"	d
TLA_NONLOCAL	route.h	334;"	d
TLA_NOT_IMPLEMENTED	route.h	333;"	d
TLSCRYPT_H	tls_crypt.h	75;"	d
TLSMP_ACTIVE	ssl.h	230;"	d
TLSMP_INACTIVE	ssl.h	229;"	d
TLSMP_KILL	ssl.h	231;"	d
TLS_AUTHENTICATION_DEFERRED	ssl_verify.h	72;"	d
TLS_AUTHENTICATION_FAILED	ssl_verify.h	71;"	d
TLS_AUTHENTICATION_SUCCEEDED	ssl_verify.h	70;"	d
TLS_AUTHENTICATION_UNDEFINED	ssl_verify.h	73;"	d
TLS_CHANNEL_BUF_SIZE	common.h	80;"	d
TLS_CLIENT	options.c	3582;"	d	file:
TLS_CLIENT	options.c	3680;"	d	file:
TLS_CRYPT_BLOCK_SIZE	tls_crypt.h	85;"	d
TLS_CRYPT_OFF_CT	tls_crypt.h	89;"	d
TLS_CRYPT_OFF_PID	tls_crypt.h	87;"	d
TLS_CRYPT_OFF_TAG	tls_crypt.h	88;"	d
TLS_CRYPT_PID_SIZE	tls_crypt.h	84;"	d
TLS_CRYPT_TAG_SIZE	tls_crypt.h	83;"	d
TLS_MODE	openvpn.h	570;"	d
TLS_MODE	openvpn.h	578;"	d
TLS_MULTI_AUTH_STATUS_INTERVAL	ssl.h	99;"	d
TLS_MULTI_HORIZON	ssl.h	88;"	d
TLS_MULTI_REFRESH	ssl.h	87;"	d
TLS_MULTI_THREAD_SEND_TIMEOUT	ssl.h	96;"	d
TLS_OPTIONS_LEN	ssl.h	106;"	d
TLS_RELIABLE_N_REC_BUFFERS	ssl.h	82;"	d
TLS_RELIABLE_N_SEND_BUFFERS	ssl.h	81;"	d
TLS_SERVER	options.c	3583;"	d	file:
TLS_SERVER	options.c	3681;"	d	file:
TLS_USERNAME_LEN	ssl_verify.c	51;"	d	file:
TLS_VER_1_0	ssl_backend.h	114;"	d
TLS_VER_1_1	ssl_backend.h	115;"	d
TLS_VER_1_2	ssl_backend.h	116;"	d
TLS_VER_1_3	ssl_backend.h	117;"	d
TLS_VER_BAD	ssl_backend.h	112;"	d
TLS_VER_UNSPEC	ssl_backend.h	113;"	d
TLS_WRAP_AUTH	ssl_common.h	/^        TLS_WRAP_AUTH,  \/**< Control channel authentication *\/$/;"	e	enum:tls_wrap_ctx::__anon2
TLS_WRAP_CRYPT	ssl_common.h	/^        TLS_WRAP_CRYPT, \/**< Control channel encryption and authentication *\/$/;"	e	enum:tls_wrap_ctx::__anon2
TLS_WRAP_NONE	ssl_common.h	/^        TLS_WRAP_NONE = 0, \/**< No control channel wrapping *\/$/;"	e	enum:tls_wrap_ctx::__anon2
TM_ACTIVE	ssl_common.h	442;"	d
TM_LAME_DUCK	ssl_common.h	445;"	d
TM_SIZE	ssl_common.h	446;"	d
TM_UNTRUSTED	ssl_common.h	443;"	d
TOP_NET30	proto.h	43;"	d
TOP_P2P	proto.h	44;"	d
TOP_SUBNET	proto.h	45;"	d
TOP_UNDEF	proto.h	42;"	d
TO_LINK_DEF	forward.h	48;"	d
TO_LINK_FRAG	forward.h	43;"	d
TO_LINK_FRAG	forward.h	45;"	d
TUNNEL_TOPOLOGY	tun.h	136;"	d
TUNNEL_TYPE	tun.h	133;"	d
TUN_ADAPTER_INDEX_INVALID	tun.h	42;"	d
TUN_H	tun.h	25;"	d
TUN_LINK_DELTA	mtu.h	151;"	d
TUN_MTU_DEFAULT	mtu.h	70;"	d
TUN_MTU_MIN	mtu.h	60;"	d
TUN_MTU_SIZE	mtu.h	156;"	d
TUN_MTU_SIZE_DYNAMIC	mtu.h	157;"	d
TUN_OUT	forward.h	38;"	d
TUN_PASS_BUFFER	tun.h	330;"	d
TUN_READ	openvpn.h	242;"	d
TUN_WRITE	openvpn.h	243;"	d
TV_WITHIN_SIGMA_MAX_SEC	otime.h	273;"	d
TV_WITHIN_SIGMA_MAX_USEC	otime.h	274;"	d
UINT64	ntlm.c	50;"	d	file:
UINT64	ntlm.c	54;"	d	file:
UINT8_MAX	socket.c	2986;"	d	file:
UINTEGER64	ntlm.c	49;"	d	file:
UINTEGER64	ntlm.c	53;"	d	file:
UNDEFINED_EVENT	event.h	48;"	d
UNDEFINED_EVENT	event.h	54;"	d
UNIX_SOCK_SUPPORT	syshead.h	587;"	d
UNIX_SOCK_SUPPORT	syshead.h	589;"	d
UP_QUERY_DISABLED	manage.h	248;"	d
UP_QUERY_NEED_OK	manage.h	251;"	d
UP_QUERY_NEED_STR	manage.h	252;"	d
UP_QUERY_PASS	manage.h	250;"	d
UP_QUERY_USER_PASS	manage.h	249;"	d
UP_TYPE_AUTH	ssl_common.h	41;"	d
UP_TYPE_PRIVATE_KEY	ssl_common.h	42;"	d
UP_TYPE_PROXY	proxy.c	45;"	d	file:
UP_TYPE_SOCKS	socks.c	50;"	d	file:
USEC_TIMER_MAX	interval.h	223;"	d
USEC_TIMER_MAX_USEC	interval.h	225;"	d
USER_PASS_LEN	misc.h	185;"	d
USER_PASS_LEN	misc.h	187;"	d
USE_64_BIT_COUNTERS	syshead.h	502;"	d
USE_COMP	syshead.h	696;"	d
VALGRIND_MAKE_READABLE	memdbg.h	49;"	d
VALGRIND_MAKE_READABLE	memdbg.h	53;"	d
VERIFY_PERMISSION	options.c	4788;"	d	file:
VERIFY_PERMISSION	options.c	4837;"	d	file:
VERIFY_X509_NONE	ssl_verify.h	65;"	d
VERIFY_X509_SUBJECT_DN	ssl_verify.h	66;"	d
VERIFY_X509_SUBJECT_RDN	ssl_verify.h	67;"	d
VERIFY_X509_SUBJECT_RDN_PREFIX	ssl_verify.h	68;"	d
WEXITSTATUS	syshead.h	68;"	d
WIFEXITED	syshead.h	71;"	d
WIN_7	win32.h	299;"	d
WIN_8	win32.h	300;"	d
WIN_IPCONFIG_PATH_SUFFIX	win32.h	34;"	d
WIN_NET_PATH_SUFFIX	win32.h	35;"	d
WIN_ROUTE_PATH_SUFFIX	win32.h	33;"	d
WIN_VISTA	win32.h	298;"	d
WIN_XP	win32.h	297;"	d
WSO_FORCE_CONSOLE	win32.h	163;"	d
WSO_FORCE_SERVICE	win32.h	162;"	d
WSO_MODE_CONSOLE	win32.h	148;"	d
WSO_MODE_SERVICE	win32.h	147;"	d
WSO_MODE_UNDEF	win32.h	146;"	d
WSO_NOFORCE	win32.h	161;"	d
X509_NAME_CHAR_CLASS	ssl_verify.c	54;"	d	file:
X509_OBJECT_free	openssl_compat.h	/^X509_OBJECT_free(X509_OBJECT *obj)$/;"	f	signature:(X509_OBJECT *obj)
X509_OBJECT_get_type	openssl_compat.h	/^X509_OBJECT_get_type(const X509_OBJECT *obj)$/;"	f	signature:(const X509_OBJECT *obj)
X509_STORE_get0_objects	openssl_compat.h	/^X509_STORE_get0_objects(X509_STORE *store)$/;"	f	signature:(X509_STORE *store)
X509_USERNAME_FIELD_DEFAULT	ssl.h	109;"	d
X509_get0_pubkey	openssl_compat.h	/^X509_get0_pubkey(const X509 *x)$/;"	f	signature:(const X509 *x)
XT_FULL_CHAIN	ssl_verify.h	205;"	d
_BASE64_H_	base64.h	35;"	d
_CAPI_DATA	cryptoapi.c	/^typedef struct _CAPI_DATA {$/;"	s	file:
_CAPI_DATA::cert_context	cryptoapi.c	/^    const CERT_CONTEXT *cert_context;$/;"	m	struct:_CAPI_DATA	file:	access:public
_CAPI_DATA::crypt_prov	cryptoapi.c	/^    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE crypt_prov;$/;"	m	struct:_CAPI_DATA	file:	access:public
_CAPI_DATA::free_crypt_prov	cryptoapi.c	/^    BOOL free_crypt_prov;$/;"	m	struct:_CAPI_DATA	file:	access:public
_CAPI_DATA::key_spec	cryptoapi.c	/^    DWORD key_spec;$/;"	m	struct:_CAPI_DATA	file:	access:public
_CRYPTOAPI_H_	cryptoapi.h	2;"	d
_OPENVPN_PATCH_LEVEL	plugin.c	425;"	d	file:
_OPENVPN_PATCH_LEVEL	plugin.c	427;"	d	file:
_P1003_1B_VISIBLE	syshead.h	381;"	d
__APPLE_USE_RFC_3542	syshead.h	54;"	d
__OPENVPN_X509_CERT_T_DECLARED	ssl_verify_mbedtls.h	36;"	d
__OPENVPN_X509_CERT_T_DECLARED	ssl_verify_openssl.h	36;"	d
__anon11::data_start	ssl_mbedtls.h	/^    size_t data_start;$/;"	m	struct:__anon11	access:public
__anon11::first_block	ssl_mbedtls.h	/^    buffer_entry *first_block;$/;"	m	struct:__anon11	access:public
__anon11::last_block	ssl_mbedtls.h	/^    buffer_entry *last_block;$/;"	m	struct:__anon11	access:public
__anon12::in	ssl_mbedtls.h	/^    endless_buffer in;$/;"	m	struct:__anon12	access:public
__anon12::out	ssl_mbedtls.h	/^    endless_buffer out;$/;"	m	struct:__anon12	access:public
__anon16::lib_name	crypto_backend.h	/^    const char *lib_name;       \/**< Cipher name used by crypto library *\/$/;"	m	struct:__anon16	access:public
__anon16::openvpn_name	crypto_backend.h	/^    const char *openvpn_name;   \/**< Cipher name used by OpenVPN *\/$/;"	m	struct:__anon16	access:public
__anon8::iana_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon8	access:public
__anon8::openssl_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon8	access:public
__attribute__	syshead.h	49;"	d
__func__	syshead.h	48;"	d
__mygettimeofday	pkcs11.c	/^__mygettimeofday(struct timeval *tv)$/;"	f	file:	signature:(struct timeval *tv)
__mysleep	pkcs11.c	/^__mysleep(const unsigned long usec)$/;"	f	file:	signature:(const unsigned long usec)
__mytime	pkcs11.c	/^__mytime(void)$/;"	f	file:	signature:(void)
_buffer_entry	ssl_mbedtls.h	/^struct _buffer_entry {$/;"	s
_buffer_entry::data	ssl_mbedtls.h	/^    uint8_t *data;$/;"	m	struct:_buffer_entry	access:public
_buffer_entry::length	ssl_mbedtls.h	/^    size_t length;$/;"	m	struct:_buffer_entry	access:public
_buffer_entry::next_block	ssl_mbedtls.h	/^    buffer_entry *next_block;$/;"	m	struct:_buffer_entry	access:public
_pkcs11_msg_openvpn2pkcs11	pkcs11.c	/^_pkcs11_msg_openvpn2pkcs11($/;"	f	file:	signature:( const unsigned flags )
_pkcs11_msg_pkcs112openvpn	pkcs11.c	/^_pkcs11_msg_pkcs112openvpn($/;"	f	file:	signature:( const unsigned flags )
_pkcs11_openvpn_log	pkcs11.c	/^_pkcs11_openvpn_log($/;"	f	file:	signature:( void *const global_data, unsigned flags, const char *const szFormat, va_list args )
_pkcs11_openvpn_pin_prompt	pkcs11.c	/^_pkcs11_openvpn_pin_prompt($/;"	f	file:	signature:( void *const global_data, void *const user_data, const pkcs11h_token_id_t token, const unsigned retry, char *const pin, const size_t pin_max )
_pkcs11_openvpn_show_pkcs11_ids_pin_prompt	pkcs11.c	/^_pkcs11_openvpn_show_pkcs11_ids_pin_prompt($/;"	f	file:	signature:( void *const global_data, void *const user_data, const pkcs11h_token_id_t token, const unsigned retry, char *const pin, const size_t pin_max )
_pkcs11_openvpn_token_prompt	pkcs11.c	/^_pkcs11_openvpn_token_prompt($/;"	f	file:	signature:( void *const global_data, void *const user_data, const pkcs11h_token_id_t token, const unsigned retry )
_query_user	console.h	/^struct _query_user {$/;"	s
_query_user::echo	console.h	/^    bool echo;                \/**< True: The user should see what is being typed, otherwise mask it *\/$/;"	m	struct:_query_user	access:public
_query_user::prompt	console.h	/^    char *prompt;             \/**< Prompt to present to the user *\/$/;"	m	struct:_query_user	access:public
_query_user::prompt_len	console.h	/^    size_t prompt_len;        \/**< Lenght of the prompt string *\/$/;"	m	struct:_query_user	access:public
_query_user::response	console.h	/^    char *response;           \/**< The user's response *\/$/;"	m	struct:_query_user	access:public
_query_user::response_len	console.h	/^    size_t response_len;      \/**< Lenght the of the user reposone *\/$/;"	m	struct:_query_user	access:public
abort	plugin.h	/^    openvpn_plugin_abort_v1 abort;$/;"	m	struct:plugin	access:public
absolute_pathname	misc.c	/^absolute_pathname(const char *pathname)$/;"	f	signature:(const char *pathname)
absolute_pathname	misc.h	/^bool absolute_pathname(const char *pathname);$/;"	p	signature:(const char *pathname)
ac	lzo.h	/^    struct lzo_adaptive_compress ac;$/;"	m	struct:lzo_compress_workspace	typeref:struct:lzo_compress_workspace::lzo_adaptive_compress	access:public
accept_from	openvpn.h	/^    const struct link_socket *accept_from; \/* possibly do accept() on a parent link_socket *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket	access:public
acf_last_mod	ssl_common.h	/^    time_t acf_last_mod;$/;"	m	struct:key_state	access:public
ack_seq	proto.h	/^    uint32_t ack_seq;      \/* acknowledgement number *\/$/;"	m	struct:openvpn_tcphdr	access:public
ack_write_buf	ssl_common.h	/^    struct buffer ack_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
active	reliable.h	/^    bool active;$/;"	m	struct:reliable_entry	access:public
actual	socket.h	/^    struct link_socket_actual actual; \/* reply to this address *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::link_socket_actual	access:public
actual_name	tun.h	/^    char *actual_name; \/* actual name of TUN\/TAP dev, usually including unit number *\/$/;"	m	struct:tuntap	access:public
adapter_index	route.h	/^    DWORD adapter_index;        \/* interface or ~0 if undefined *\/$/;"	m	struct:route_ipv6	access:public
adapter_index	route.h	/^    DWORD adapter_index; \/* interface or ~0 if undefined *\/$/;"	m	struct:route_gateway_info	access:public
adapter_index	route.h	/^    DWORD adapter_index; \/* interface or ~0 if undefined *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
adapter_index	tun.h	/^    DWORD adapter_index;$/;"	m	struct:tuntap	access:public
adapter_index_of_ip	tun.c	/^adapter_index_of_ip(const IP_ADAPTER_INFO *list,$/;"	f	signature:(const IP_ADAPTER_INFO *list, const in_addr_t ip, int *count, in_addr_t *netmask)
adapter_index_of_ip	tun.h	/^DWORD adapter_index_of_ip(const IP_ADAPTER_INFO *list,$/;"	p	signature:(const IP_ADAPTER_INFO *list, const in_addr_t ip, int *count, in_addr_t *netmask)
adapter_netmask	tun.h	/^    in_addr_t adapter_netmask;$/;"	m	struct:tuntap	access:public
add_block_dns_filters	block_dns.c	/^add_block_dns_filters(HANDLE *engine_handle,$/;"	f	signature:(HANDLE *engine_handle, int index, const WCHAR *exe_path, block_dns_msg_handler_t msg_handler )
add_block_dns_filters	block_dns.h	/^add_block_dns_filters(HANDLE *engine, int iface_index, const WCHAR *exe_path,$/;"	p	signature:(HANDLE *engine, int iface_index, const WCHAR *exe_path, block_dns_msg_handler_t msg_handler_callback)
add_block_local	route.c	/^add_block_local(struct route_list *rl)$/;"	f	file:	signature:(struct route_list *rl)
add_block_local_item	route.c	/^add_block_local_item(struct route_list *rl,$/;"	f	file:	signature:(struct route_list *rl, const struct route_gateway_address *gateway, in_addr_t target)
add_bypass_address	route.c	/^add_bypass_address(struct route_bypass *rb, const in_addr_t a)$/;"	f	file:	signature:(struct route_bypass *rb, const in_addr_t a)
add_bypass_routes	route.c	/^add_bypass_routes(struct route_bypass *rb,$/;"	f	file:	signature:(struct route_bypass *rb, in_addr_t gateway, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
add_client	pf.c	/^add_client(const char *line, const char *prefix, const int line_num, struct pf_cn_elem ***next, const bool exclude)$/;"	f	file:	signature:(const char *line, const char *prefix, const int line_num, struct pf_cn_elem ***next, const bool exclude)
add_client_nat_to_option_list	clinat.c	/^add_client_nat_to_option_list(struct client_nat_option_list *dest,$/;"	f	signature:(struct client_nat_option_list *dest, const char *type, const char *network, const char *netmask, const char *foreign_network, int msglevel)
add_client_nat_to_option_list	clinat.h	/^void add_client_nat_to_option_list(struct client_nat_option_list *dest,$/;"	p	signature:(struct client_nat_option_list *dest, const char *type, const char *network, const char *netmask, const char *foreign_network, int msglevel)
add_entry	clinat.c	/^add_entry(struct client_nat_option_list *dest,$/;"	f	file:	signature:(struct client_nat_option_list *dest, const struct client_nat_entry *e)
add_env_item	misc.c	/^add_env_item(char *str, const bool do_alloc, struct env_item **list, struct gc_arena *gc)$/;"	f	file:	signature:(char *str, const bool do_alloc, struct env_item **list, struct gc_arena *gc)
add_host_route_array	route.c	/^add_host_route_array(struct route_bypass *rb, const IP_ADDR_STRING *iplist)$/;"	f	file:	signature:(struct route_bypass *rb, const IP_ADDR_STRING *iplist)
add_host_route_if_nonlocal	route.c	/^add_host_route_if_nonlocal(struct route_bypass *rb, const in_addr_t addr)$/;"	f	file:	signature:(struct route_bypass *rb, const in_addr_t addr)
add_in6_addr	socket.c	/^add_in6_addr( struct in6_addr base, uint32_t add )$/;"	f	signature:( struct in6_addr base, uint32_t add )
add_in6_addr	socket.h	/^struct in6_addr add_in6_addr( struct in6_addr base, uint32_t add );$/;"	p	signature:( struct in6_addr base, uint32_t add )
add_option	options.c	/^add_option(struct options *options,$/;"	f	file:	signature:(struct options *options, char *p[], const char *file, int line, const int level, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
add_option	options.c	/^add_option(struct options *options,$/;"	p	file:	signature:(struct options *options, char *p[], const char *file, int line, const int level, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
add_proxy_headers	proxy.c	/^add_proxy_headers(struct http_proxy_info *p,$/;"	f	file:	signature:(struct http_proxy_info *p, socket_descriptor_t sd, const char *host, const char *port )
add_route	route.c	/^add_route(struct route_ipv4 *r,$/;"	f	signature:(struct route_ipv4 *r, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
add_route	route.h	/^void add_route(struct route_ipv4 *r,$/;"	p	signature:(struct route_ipv4 *r, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
add_route3	route.c	/^add_route3(in_addr_t network,$/;"	f	file:	signature:(in_addr_t network, in_addr_t netmask, in_addr_t gateway, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
add_route_connected_v6_net	tun.c	/^add_route_connected_v6_net(struct tuntap *tt,$/;"	f	signature:(struct tuntap *tt, const struct env_set *es)
add_route_ipapi	route.c	/^add_route_ipapi(const struct route_ipv4 *r, const struct tuntap *tt, DWORD adapter_index)$/;"	f	signature:(const struct route_ipv4 *r, const struct tuntap *tt, DWORD adapter_index)
add_route_ipapi	route.h	/^bool add_route_ipapi(const struct route_ipv4 *r, const struct tuntap *tt, DWORD adapter_index);$/;"	p	signature:(const struct route_ipv4 *r, const struct tuntap *tt, DWORD adapter_index)
add_route_ipv6	route.c	/^add_route_ipv6(struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	signature:(struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
add_route_ipv6	route.h	/^void add_route_ipv6(struct route_ipv6 *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es);$/;"	p	signature:(struct route_ipv6 *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
add_route_ipv6_service	route.c	/^add_route_ipv6_service(const struct route_ipv6 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const struct route_ipv6 *r, const struct tuntap *tt)
add_route_ipv6_service	route.c	/^static bool add_route_ipv6_service(const struct route_ipv6 *, const struct tuntap *);$/;"	p	file:	signature:(const struct route_ipv6 *, const struct tuntap *)
add_route_ipv6_to_option_list	route.c	/^add_route_ipv6_to_option_list(struct route_ipv6_option_list *l,$/;"	f	signature:(struct route_ipv6_option_list *l, const char *prefix, const char *gateway, const char *metric)
add_route_ipv6_to_option_list	route.h	/^void add_route_ipv6_to_option_list(struct route_ipv6_option_list *l,$/;"	p	signature:(struct route_ipv6_option_list *l, const char *prefix, const char *gateway, const char *metric)
add_route_service	route.c	/^add_route_service(const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const struct route_ipv4 *r, const struct tuntap *tt)
add_route_service	route.c	/^static bool add_route_service(const struct route_ipv4 *, const struct tuntap *);$/;"	p	file:	signature:(const struct route_ipv4 *, const struct tuntap *)
add_route_to_option_list	route.c	/^add_route_to_option_list(struct route_option_list *l,$/;"	f	signature:(struct route_option_list *l, const char *network, const char *netmask, const char *gateway, const char *metric)
add_route_to_option_list	route.h	/^void add_route_to_option_list(struct route_option_list *l,$/;"	p	signature:(struct route_option_list *l, const char *network, const char *netmask, const char *gateway, const char *metric)
add_routes	route.c	/^add_routes(struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	signature:(struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
add_routes	route.h	/^void add_routes(struct route_list *rl,$/;"	p	signature:(struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
add_security_buffer	ntlm.c	/^add_security_buffer(int sb_offset, void *data, int length,$/;"	f	file:	signature:(int sb_offset, void *data, int length, unsigned char *msg_buf, int *msg_bufpos)
add_sublayer	block_dns.c	/^add_sublayer(GUID uuid)$/;"	f	file:	signature:(GUID uuid)
add_subnet	pf.c	/^add_subnet(const char *line, const char *prefix, const int line_num, struct pf_subnet ***next, const bool exclude)$/;"	f	file:	signature:(const char *line, const char *prefix, const int line_num, struct pf_subnet ***next, const bool exclude)
addr	buffer.h	/^    void *addr;$/;"	m	struct:gc_entry_special	access:public
addr	mroute.h	/^            in_addr_t addr;     \/* _network order_ IPv4 address *\/$/;"	m	struct:mroute_addr::__anon4::__anon5	access:public
addr	mroute.h	/^            in_addr_t addr;     \/* _network order_ IPv4 address *\/$/;"	m	struct:mroute_addr::__anon4::__anon7	access:public
addr	mroute.h	/^            struct in6_addr addr;$/;"	m	struct:mroute_addr::__anon4::__anon6	typeref:struct:mroute_addr::__anon4::__anon6::in6_addr	access:public
addr	multi.h	/^    struct mroute_addr addr;$/;"	m	struct:multi_route	typeref:struct:multi_route::mroute_addr	access:public
addr	route.h	/^    in_addr_t addr;$/;"	m	struct:route_gateway_address	access:public
addr	socket.h	/^    } addr;$/;"	m	struct:openvpn_sockaddr	typeref:union:openvpn_sockaddr::__anon13	access:public
addr	win32.h	/^        struct sockaddr_in addr;$/;"	m	union:overlapped_io::__anon10	typeref:struct:overlapped_io::__anon10::sockaddr_in	access:public
addr6	win32.h	/^        struct sockaddr_in6 addr6;$/;"	m	union:overlapped_io::__anon10	typeref:struct:overlapped_io::__anon10::sockaddr_in6	access:public
addr_copy_sa	socket.h	/^addr_copy_sa(struct openvpn_sockaddr *dst, const struct openvpn_sockaddr *src)$/;"	f	signature:(struct openvpn_sockaddr *dst, const struct openvpn_sockaddr *src)
addr_defined	socket.h	/^addr_defined(const struct openvpn_sockaddr *addr)$/;"	f	signature:(const struct openvpn_sockaddr *addr)
addr_defined	win32.h	/^    bool addr_defined;$/;"	m	struct:overlapped_io	access:public
addr_defined_ipi	socket.h	/^addr_defined_ipi(const struct link_socket_actual *lsa)$/;"	f	signature:(const struct link_socket_actual *lsa)
addr_family_name	socket.c	/^addr_family_name(int af)$/;"	f	signature:(int af)
addr_family_name	socket.h	/^const char *addr_family_name(int af);$/;"	p	signature:(int af)
addr_guess_family	socket.h	/^int addr_guess_family(sa_family_t af,const char *name);$/;"	p	signature:(sa_family_t af,const char *name)
addr_host	socket.h	/^addr_host(const struct openvpn_sockaddr *addr)$/;"	f	signature:(const struct openvpn_sockaddr *addr)
addr_inet4or6	socket.h	/^addr_inet4or6(struct sockaddr *addr)$/;"	f	signature:(struct sockaddr *addr)
addr_ipv6	route.h	/^    struct in6_addr addr_ipv6;$/;"	m	struct:route_ipv6_gateway_address	typeref:struct:route_ipv6_gateway_address::in6_addr	access:public
addr_local	socket.h	/^addr_local(const struct sockaddr *addr)$/;"	f	signature:(const struct sockaddr *addr)
addr_match	socket.h	/^addr_match(const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)$/;"	f	signature:(const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)
addr_match_proto	socket.h	/^addr_match_proto(const struct openvpn_sockaddr *a1,$/;"	f	signature:(const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2, const int proto)
addr_port_match	socket.h	/^addr_port_match(const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)$/;"	f	signature:(const struct openvpn_sockaddr *a1, const struct openvpn_sockaddr *a2)
addr_zero_host	socket.h	/^addr_zero_host(struct openvpn_sockaddr *addr)$/;"	f	signature:(struct openvpn_sockaddr *addr)
addrlen	win32.h	/^    int addrlen;$/;"	m	struct:overlapped_io	access:public
addrlist_match	socket.h	/^addrlist_match(const struct openvpn_sockaddr *a1, const struct addrinfo *addrlist)$/;"	f	signature:(const struct openvpn_sockaddr *a1, const struct addrinfo *addrlist)
addrlist_match_proto	socket.h	/^addrlist_match_proto(const struct openvpn_sockaddr *a1,$/;"	f	signature:(const struct openvpn_sockaddr *a1, struct addrinfo *addr_list, const int proto)
addrlist_port_match	socket.h	/^addrlist_port_match(const struct openvpn_sockaddr *a1, const struct addrinfo *a2)$/;"	f	signature:(const struct openvpn_sockaddr *a1, const struct addrinfo *a2)
addrs	route.h	/^    struct route_gateway_address addrs[RGI_N_ADDRESSES]; \/* local addresses attached to iface *\/$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address	access:public
addrs	route.h	/^    struct route_ipv6_gateway_address addrs[RGI_N_ADDRESSES]; \/* local addresses attached to iface *\/$/;"	m	struct:route_ipv6_gateway_info	typeref:struct:route_ipv6_gateway_info::route_ipv6_gateway_address	access:public
adjust_power_of_2	integer.h	/^adjust_power_of_2(size_t u)$/;"	f	signature:(size_t u)
af	options.h	/^    sa_family_t af;$/;"	m	struct:connection_entry	access:public
af	options.h	/^    sa_family_t af;$/;"	m	struct:remote_entry	access:public
af	socket.h	/^    sa_family_t af;                     \/* Address family like AF_INET, AF_INET6 or AF_UNSPEC*\/$/;"	m	struct:link_socket_info	access:public
af_addr_size	socket.h	/^af_addr_size(sa_family_t af)$/;"	f	signature:(sa_family_t af)
ageable_ttl_secs	mroute.h	/^    int ageable_ttl_secs;        \/* host route cache entry time-to-live*\/$/;"	m	struct:mroute_helper	access:public
ai	socket.h	/^    struct addrinfo *ai;$/;"	m	struct:cached_dns_entry	typeref:struct:cached_dns_entry::addrinfo	access:public
ai_family	socket.h	/^    int ai_family;$/;"	m	struct:cached_dns_entry	access:public
alg	comp.h	/^    int alg;$/;"	m	struct:compress_options	access:public
alg	comp.h	/^    struct compress_alg alg;$/;"	m	struct:compress_context	typeref:struct:compress_context::compress_alg	access:public
align_adjust	mtu.h	/^    int align_adjust;$/;"	m	struct:frame	access:public
align_flags	mtu.h	/^    unsigned int align_flags;$/;"	m	struct:frame	access:public
alloc_buf	buffer.h	/^struct buffer alloc_buf(size_t size);$/;"	p	signature:(size_t size)
alloc_buf	buffer.h	155;"	d
alloc_buf_debug	buffer.c	/^alloc_buf_debug(size_t size, const char *file, int line)$/;"	f	signature:(size_t size, const char *file, int line)
alloc_buf_debug	buffer.h	/^struct buffer alloc_buf_debug(size_t size, const char *file, int line);$/;"	p	signature:(size_t size, const char *file, int line)
alloc_buf_gc	buffer.h	/^struct buffer alloc_buf_gc(size_t size, struct gc_arena *gc);  \/* allocate buffer with garbage collection *\/$/;"	p	signature:(size_t size, struct gc_arena *gc)
alloc_buf_gc	buffer.h	156;"	d
alloc_buf_gc_debug	buffer.c	/^alloc_buf_gc_debug(size_t size, struct gc_arena *gc, const char *file, int line)$/;"	f	signature:(size_t size, struct gc_arena *gc, const char *file, int line)
alloc_buf_gc_debug	buffer.h	/^struct buffer alloc_buf_gc_debug(size_t size, struct gc_arena *gc, const char *file, int line);$/;"	p	signature:(size_t size, struct gc_arena *gc, const char *file, int line)
alloc_buf_sock_tun	mtu.c	/^alloc_buf_sock_tun(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, const struct frame *frame, const bool tuntap_buffer, const unsigned int align_mask)
alloc_buf_sock_tun	mtu.h	/^void alloc_buf_sock_tun(struct buffer *buf,$/;"	p	signature:(struct buffer *buf, const struct frame *frame, const bool tuntap_buffer, const unsigned int align_mask)
alloc_connection_entry	options.c	/^alloc_connection_entry(struct options *options, const int msglevel)$/;"	f	file:	signature:(struct options *options, const int msglevel)
alloc_connection_list_if_undef	options.c	/^alloc_connection_list_if_undef(struct options *options)$/;"	f	file:	signature:(struct options *options)
alloc_pull_filter	options.c	/^alloc_pull_filter(struct options *o, const int msglevel)$/;"	f	file:	signature:(struct options *o, const int msglevel)
alloc_pull_filter_list	options.c	/^alloc_pull_filter_list(struct options *o)$/;"	f	file:	signature:(struct options *o)
alloc_remote_entry	options.c	/^alloc_remote_entry(struct options *options, const int msglevel)$/;"	f	file:	signature:(struct options *options, const int msglevel)
alloc_remote_list_if_undef	options.c	/^alloc_remote_list_if_undef(struct options *options)$/;"	f	file:	signature:(struct options *options)
allow_pull_fqdn	options.h	/^    bool allow_pull_fqdn; \/* as a client, allow server to push a FQDN for certain parameters *\/$/;"	m	struct:options	access:public
allow_recursive_routing	options.h	/^    bool allow_recursive_routing;$/;"	m	struct:options	access:public
allowed_ciphers	ssl_mbedtls.h	/^    int *allowed_ciphers;       \/**< List of allowed ciphers for this connection *\/$/;"	m	struct:tls_root_ctx	access:public
apply_pull_filter	options.c	/^apply_pull_filter(const struct options *o, char *line)$/;"	f	file:	signature:(const struct options *o, char *line)
apply_push_options	options.c	/^apply_push_options(struct options *options,$/;"	f	signature:(struct options *options, struct buffer *buf, unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
apply_push_options	options.h	/^bool apply_push_options(struct options *options,$/;"	p	signature:(struct options *options, struct buffer *buf, unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
arg	event.h	/^    void *arg;$/;"	m	struct:event_set_return	access:public
arg	manage.h	/^    void *arg;$/;"	m	struct:management_callback	access:public
arg	status.h	/^    void *arg;$/;"	m	struct:virtual_output	access:public
argc	argv.h	/^    size_t argc;$/;"	m	struct:argv	access:public
args	event.c	/^    void **args; \/* allocated to capacity size *\/$/;"	m	struct:se_set	file:	access:public
args	event.c	/^    void **args;$/;"	m	struct:po_set	file:	access:public
argv	argv.h	/^    char **argv;$/;"	m	struct:argv	access:public
argv	argv.h	/^struct argv {$/;"	s
argv	plugin.h	/^    const char **argv;$/;"	m	struct:plugin_option	access:public
argv::argc	argv.h	/^    size_t argc;$/;"	m	struct:argv	access:public
argv::argv	argv.h	/^    char **argv;$/;"	m	struct:argv	access:public
argv::capacity	argv.h	/^    size_t capacity;$/;"	m	struct:argv	access:public
argv_append	argv.c	/^argv_append(struct argv *a, char *str)  \/* str must have been malloced or be NULL *\/$/;"	f	file:	signature:(struct argv *a, char *str)
argv_clone	argv.c	/^argv_clone(const struct argv *a, const size_t headroom)$/;"	f	file:	signature:(const struct argv *a, const size_t headroom)
argv_extend	argv.c	/^argv_extend(struct argv *a, const size_t newcap)$/;"	f	file:	signature:(struct argv *a, const size_t newcap)
argv_grow	argv.c	/^argv_grow(struct argv *a, const size_t add)$/;"	f	file:	signature:(struct argv *a, const size_t add)
argv_init	argv.c	/^argv_init(struct argv *a)$/;"	f	file:	signature:(struct argv *a)
argv_insert_head	argv.c	/^argv_insert_head(const struct argv *a, const char *head)$/;"	f	signature:(const struct argv *a, const char *head)
argv_insert_head	argv.h	/^struct argv argv_insert_head(const struct argv *a, const char *head);$/;"	p	signature:(const struct argv *a, const char *head)
argv_msg	argv.c	/^argv_msg(const int msglev, const struct argv *a)$/;"	f	signature:(const int msglev, const struct argv *a)
argv_msg	argv.h	/^void argv_msg(const int msglev, const struct argv *a);$/;"	p	signature:(const int msglev, const struct argv *a)
argv_msg_prefix	argv.c	/^argv_msg_prefix(const int msglev, const struct argv *a, const char *prefix)$/;"	f	signature:(const int msglev, const struct argv *a, const char *prefix)
argv_msg_prefix	argv.h	/^void argv_msg_prefix(const int msglev, const struct argv *a, const char *prefix);$/;"	p	signature:(const int msglev, const struct argv *a, const char *prefix)
argv_new	argv.c	/^argv_new(void)$/;"	f	signature:(void)
argv_new	argv.h	/^struct argv argv_new(void);$/;"	p	signature:(void)
argv_parse_cmd	argv.c	/^argv_parse_cmd(struct argv *a, const char *s)$/;"	f	signature:(struct argv *a, const char *s)
argv_parse_cmd	argv.h	/^void argv_parse_cmd(struct argv *a, const char *s);$/;"	p	signature:(struct argv *a, const char *s)
argv_printf	argv.c	/^argv_printf(struct argv *a, const char *format, ...)$/;"	f	signature:(struct argv *a, const char *format, ...)
argv_printf	argv.h	/^void argv_printf(struct argv *a, const char *format, ...)$/;"	p	signature:(struct argv *a, const char *format, ...)
argv_printf_arglist	argv.c	/^argv_printf_arglist(struct argv *a, const char *format, va_list arglist)$/;"	f	file:	signature:(struct argv *a, const char *format, va_list arglist)
argv_printf_cat	argv.c	/^argv_printf_cat(struct argv *a, const char *format, ...)$/;"	f	signature:(struct argv *a, const char *format, ...)
argv_printf_cat	argv.h	/^void argv_printf_cat(struct argv *a, const char *format, ...)$/;"	p	signature:(struct argv *a, const char *format, ...)
argv_reset	argv.c	/^argv_reset(struct argv *a)$/;"	f	signature:(struct argv *a)
argv_reset	argv.h	/^void argv_reset(struct argv *a);$/;"	p	signature:(struct argv *a)
argv_str	argv.c	/^argv_str(const struct argv *a, struct gc_arena *gc, const unsigned int flags)$/;"	f	signature:(const struct argv *a, struct gc_arena *gc, const unsigned int flags)
argv_str	argv.h	/^const char *argv_str(const struct argv *a, struct gc_arena *gc, const unsigned int flags);$/;"	p	signature:(const struct argv *a, struct gc_arena *gc, const unsigned int flags)
argv_term	argv.c	/^argv_term(const char **f)$/;"	f	file:	signature:(const char **f)
arp_command	proto.h	/^    uint16_t arp_command;       \/* 0x0001 for ARP request, 0x0002 for ARP reply *\/$/;"	m	struct:openvpn_arp	access:public
array	manage.h	/^    struct log_entry *array;$/;"	m	struct:log_history	typeref:struct:log_history::log_entry	access:public
array	mbuf.h	/^    struct mbuf_item *array;$/;"	m	struct:mbuf_set	typeref:struct:mbuf_set::mbuf_item	access:public
array	options.h	/^    struct connection_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:connection_list	typeref:struct:connection_list::connection_entry	access:public
array	options.h	/^    struct remote_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:remote_list	typeref:struct:remote_list::remote_entry	access:public
array	reliable.h	/^    struct reliable_entry array[RELIABLE_CAPACITY];$/;"	m	struct:reliable	typeref:struct:reliable::reliable_entry	access:public
array_mult_safe	buffer.c	/^array_mult_safe(const size_t m1, const size_t m2, const size_t extra)$/;"	f	signature:(const size_t m1, const size_t m2, const size_t extra)
array_mult_safe	buffer.h	/^size_t array_mult_safe(const size_t m1, const size_t m2, const size_t extra);$/;"	p	signature:(const size_t m1, const size_t m2, const size_t extra)
ascii2af	socket.c	/^ascii2af(const char *proto_name)$/;"	f	signature:(const char *proto_name)
ascii2af	socket.h	/^sa_family_t ascii2af(const char *proto_name);$/;"	p	signature:(const char *proto_name)
ascii2ipset	tun.c	/^ascii2ipset(const char *name)$/;"	f	signature:(const char *name)
ascii2ipset	tun.h	/^int ascii2ipset(const char *name);$/;"	p	signature:(const char *name)
ascii2keydirection	crypto.c	/^ascii2keydirection(int msglevel, const char *str)$/;"	f	signature:(int msglevel, const char *str)
ascii2keydirection	crypto.h	/^int ascii2keydirection(int msglevel, const char *str);$/;"	p	signature:(int msglevel, const char *str)
ascii2proto	socket.c	/^ascii2proto(const char *proto_name)$/;"	f	signature:(const char *proto_name)
ascii2proto	socket.h	/^int ascii2proto(const char *proto_name);$/;"	p	signature:(const char *proto_name)
ask_gremlin	gremlin.c	/^ask_gremlin(int flags)$/;"	f	signature:(int flags)
ask_gremlin	gremlin.h	/^bool ask_gremlin(int flags);$/;"	p	signature:(int flags)
asn1_buf_to_c_string	ssl_verify_mbedtls.c	/^asn1_buf_to_c_string(const mbedtls_asn1_buf *orig, struct gc_arena *gc)$/;"	f	file:	signature:(const mbedtls_asn1_buf *orig, struct gc_arena *gc)
assert_failed	error.c	/^assert_failed(const char *filename, int line, const char *condition)$/;"	f	signature:(const char *filename, int line, const char *condition)
assert_failed	error.h	/^void assert_failed(const char *filename, int line, const char *condition)$/;"	p	signature:(const char *filename, int line, const char *condition)
at_least_one_tap_win	tun.c	/^at_least_one_tap_win(const struct tap_reg *tap_reg)$/;"	f	file:	signature:(const struct tap_reg *tap_reg)
atou	options.c	/^atou(const char *str)$/;"	f	file:	signature:(const char *str)
attrbuf	route.c	/^    char attrbuf[512];$/;"	m	struct:rtreq	file:	access:public
auth_challenge	ssl.c	/^static char *auth_challenge; \/* GLOBAL *\/$/;"	v	file:
auth_challenge_info	misc.h	/^struct auth_challenge_info {$/;"	s
auth_challenge_info	misc.h	/^struct auth_challenge_info {};$/;"	s
auth_challenge_info::challenge_text	misc.h	/^    const char *challenge_text;$/;"	m	struct:auth_challenge_info	access:public
auth_challenge_info::flags	misc.h	/^    unsigned int flags;$/;"	m	struct:auth_challenge_info	access:public
auth_challenge_info::state_id	misc.h	/^    const char *state_id;$/;"	m	struct:auth_challenge_info	access:public
auth_challenge_info::user	misc.h	/^    const char *user;$/;"	m	struct:auth_challenge_info	access:public
auth_control_file	ssl_common.h	/^    char *auth_control_file;$/;"	m	struct:key_state	access:public
auth_control_status	ssl_common.h	/^    unsigned int auth_control_status;$/;"	m	struct:key_state	access:public
auth_deferred	ssl_common.h	/^    bool auth_deferred;$/;"	m	struct:key_state	access:public
auth_deferred_expire	ssl_common.h	/^    time_t auth_deferred_expire;$/;"	m	struct:key_state	access:public
auth_deferred_expire_window	ssl.c	/^auth_deferred_expire_window(const struct tls_options *o)$/;"	f	file:	signature:(const struct tls_options *o)
auth_file	proxy.h	/^    const char *auth_file;$/;"	m	struct:http_proxy_options	access:public
auth_method	proxy.h	/^    int auth_method;$/;"	m	struct:http_proxy_info	access:public
auth_method_string	proxy.h	/^    const char *auth_method_string;$/;"	m	struct:http_proxy_options	access:public
auth_retry	proxy.h	/^    int auth_retry;$/;"	m	struct:http_proxy_options	access:public
auth_retry	proxy.h	/^    int auth_retry;$/;"	m	struct:http_proxy_options_simple	access:public
auth_retry_get	options.c	/^auth_retry_get(void)$/;"	f	signature:(void)
auth_retry_get	options.h	/^int auth_retry_get(void);$/;"	p	signature:(void)
auth_retry_print	options.c	/^auth_retry_print(void)$/;"	f	signature:(void)
auth_retry_print	options.h	/^const char *auth_retry_print(void);$/;"	p	signature:(void)
auth_retry_set	options.c	/^auth_retry_set(const int msglevel, const char *option)$/;"	f	signature:(const int msglevel, const char *option)
auth_retry_set	options.h	/^bool auth_retry_set(const int msglevel, const char *option);$/;"	p	signature:(const int msglevel, const char *option)
auth_token	ssl.c	/^static struct user_pass auth_token;     \/* GLOBAL *\/$/;"	v	typeref:struct:user_pass	file:
auth_token	ssl_common.h	/^    char *auth_token;    \/**< If server sends a generated auth-token,$/;"	m	struct:tls_multi	access:public
auth_token_generate	options.h	/^    bool auth_token_generate;$/;"	m	struct:options	access:public
auth_token_generate	ssl_common.h	/^    bool auth_token_generate;   \/**< Generate auth-tokens on successful user\/pass auth,$/;"	m	struct:tls_options	access:public
auth_token_lifetime	options.h	/^    unsigned int auth_token_lifetime;$/;"	m	struct:options	access:public
auth_token_lifetime	ssl_common.h	/^    unsigned int auth_token_lifetime;$/;"	m	struct:tls_options	access:public
auth_token_sent	ssl_common.h	/^    bool auth_token_sent; \/**< If server uses --auth-gen-token and$/;"	m	struct:tls_multi	access:public
auth_token_tstamp	ssl_common.h	/^    time_t auth_token_tstamp; \/**< timestamp of the generated token *\/$/;"	m	struct:tls_multi	access:public
auth_user_pass	openvpn.h	/^    struct user_pass *auth_user_pass;$/;"	m	struct:context_1	typeref:struct:context_1::user_pass	access:public
auth_user_pass	ssl.c	/^static struct user_pass auth_user_pass; \/* GLOBAL *\/$/;"	v	typeref:struct:user_pass	file:
auth_user_pass_enabled	ssl.c	/^static bool auth_user_pass_enabled;     \/* GLOBAL *\/$/;"	v	file:
auth_user_pass_file	options.h	/^    const char *auth_user_pass_file;$/;"	m	struct:options	access:public
auth_user_pass_file	ssl_common.h	/^    const char *auth_user_pass_file;$/;"	m	struct:tls_options	access:public
auth_user_pass_setup	ssl.c	/^auth_user_pass_setup(const char *auth_file, const struct static_challenge_info *sci)$/;"	f	signature:(const char *auth_file, const struct static_challenge_info *sci)
auth_user_pass_setup	ssl.h	/^void auth_user_pass_setup(const char *auth_file, const struct static_challenge_info *sc_info);$/;"	p	signature:(const char *auth_file, const struct static_challenge_info *sc_info)
auth_user_pass_verify_script	options.h	/^    const char *auth_user_pass_verify_script;$/;"	m	struct:options	access:public
auth_user_pass_verify_script	ssl_common.h	/^    const char *auth_user_pass_verify_script;$/;"	m	struct:tls_options	access:public
auth_user_pass_verify_script_via_file	options.h	/^    bool auth_user_pass_verify_script_via_file;$/;"	m	struct:options	access:public
auth_user_pass_verify_script_via_file	ssl_common.h	/^    bool auth_user_pass_verify_script_via_file;$/;"	m	struct:tls_options	access:public
authenticated	ssl_common.h	/^    bool authenticated;$/;"	m	struct:key_state	access:public
authfile	socks.h	/^    char authfile[256];$/;"	m	struct:socks_proxy_info	access:public
authname	openvpn.h	/^    const char *authname;       \/**< Data channel auth from config file *\/$/;"	m	struct:context_1	access:public
authname	options.h	/^    const char *authname;$/;"	m	struct:options	access:public
aux_buf	openvpn.h	/^    struct buffer aux_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
backend_tls_ctx_reload_crl	ssl_backend.h	/^void backend_tls_ctx_reload_crl(struct tls_root_ctx *ssl_ctx,$/;"	p	signature:(struct tls_root_ctx *ssl_ctx, const char *crl_file, const char *crl_inline)
backend_tls_ctx_reload_crl	ssl_mbedtls.c	/^backend_tls_ctx_reload_crl(struct tls_root_ctx *ctx, const char *crl_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *crl_file, const char *crl_inline)
backend_tls_ctx_reload_crl	ssl_openssl.c	/^backend_tls_ctx_reload_crl(struct tls_root_ctx *ssl_ctx, const char *crl_file,$/;"	f	signature:(struct tls_root_ctx *ssl_ctx, const char *crl_file, const char *crl_inline)
backend_x509_get_serial	ssl_verify_backend.h	/^char *backend_x509_get_serial(openvpn_x509_cert_t *cert, struct gc_arena *gc);$/;"	p	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
backend_x509_get_serial	ssl_verify_mbedtls.c	/^backend_x509_get_serial(mbedtls_x509_crt *cert, struct gc_arena *gc)$/;"	f	signature:(mbedtls_x509_crt *cert, struct gc_arena *gc)
backend_x509_get_serial	ssl_verify_openssl.c	/^backend_x509_get_serial(openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
backend_x509_get_serial_hex	ssl_verify_backend.h	/^char *backend_x509_get_serial_hex(openvpn_x509_cert_t *cert,$/;"	p	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
backend_x509_get_serial_hex	ssl_verify_mbedtls.c	/^backend_x509_get_serial_hex(mbedtls_x509_crt *cert, struct gc_arena *gc)$/;"	f	signature:(mbedtls_x509_crt *cert, struct gc_arena *gc)
backend_x509_get_serial_hex	ssl_verify_openssl.c	/^backend_x509_get_serial_hex(openvpn_x509_cert_t *cert, struct gc_arena *gc)$/;"	f	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
backend_x509_get_username	ssl_verify_backend.h	/^result_t backend_x509_get_username(char *common_name, int cn_len,$/;"	p	signature:(char *common_name, int cn_len, char *x509_username_field, openvpn_x509_cert_t *peer_cert)
backend_x509_get_username	ssl_verify_mbedtls.c	/^backend_x509_get_username(char *cn, int cn_len,$/;"	f	signature:(char *cn, int cn_len, char *x509_username_field, mbedtls_x509_crt *cert)
backend_x509_get_username	ssl_verify_openssl.c	/^backend_x509_get_username(char *common_name, int cn_len,$/;"	f	signature:(char *common_name, int cn_len, char *x509_username_field, X509 *peer_cert)
background_pid	ps.h	/^    pid_t background_pid;$/;"	m	struct:port_share	access:public
bad_address_length	socket.c	/^bad_address_length(int actual, int expected)$/;"	f	signature:(int actual, int expected)
bad_address_length	socket.h	/^void bad_address_length(int actual, int expected);$/;"	p	signature:(int actual, int expected)
base	manage.h	/^    int base;$/;"	m	struct:log_history	access:public
base	pool.h	/^    in_addr_t base;$/;"	m	struct:ifconfig_pool	access:public
base64_chars	base64.c	/^static char base64_chars[] =$/;"	v	file:
base_ipv6	pool.h	/^    struct in6_addr base_ipv6;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::in6_addr	access:public
bind_defined	options.h	/^    bool bind_defined;$/;"	m	struct:connection_entry	access:public
bind_ipv6_only	options.h	/^    bool bind_ipv6_only;$/;"	m	struct:connection_entry	access:public
bind_ipv6_only	socket.h	/^    bool bind_ipv6_only;$/;"	m	struct:link_socket_info	access:public
bind_local	options.h	/^    bool bind_local;$/;"	m	struct:connection_entry	access:public
bind_local	socket.c	/^bind_local(struct link_socket *sock, const sa_family_t ai_family)$/;"	f	file:	signature:(struct link_socket *sock, const sa_family_t ai_family)
bind_local	socket.h	/^    bool bind_local;$/;"	m	struct:link_socket	access:public
bind_local	socket.h	/^    struct addrinfo *bind_local;$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
bio_ctx	ssl_mbedtls.h	/^    bio_ctx bio_ctx;$/;"	m	struct:key_state_ssl	access:public
bio_ctx	ssl_mbedtls.h	/^} bio_ctx;$/;"	t	typeref:struct:__anon12
bio_debug_data	ssl_openssl.c	/^bio_debug_data(const char *mode, BIO *bio, const uint8_t *buf, int len, const char *desc)$/;"	f	file:	signature:(const char *mode, BIO *bio, const uint8_t *buf, int len, const char *desc)
bio_debug_oc	ssl_openssl.c	/^bio_debug_oc(const char *mode, BIO *bio)$/;"	f	file:	signature:(const char *mode, BIO *bio)
bio_read	ssl_openssl.c	/^bio_read(BIO *bio, struct buffer *buf, int maxlen, const char *desc)$/;"	f	file:	signature:(BIO *bio, struct buffer *buf, int maxlen, const char *desc)
bio_write	ssl_openssl.c	/^bio_write(BIO *bio, const uint8_t *data, int size, const char *desc)$/;"	f	file:	signature:(BIO *bio, const uint8_t *data, int size, const char *desc)
bio_write_post	ssl_openssl.c	/^bio_write_post(const int status, struct buffer *buf)$/;"	f	file:	signature:(const int status, struct buffer *buf)
biofp	ssl_openssl.c	/^static FILE *biofp;                            \/* GLOBAL *\/$/;"	v	file:
biofp_last_open	ssl_openssl.c	/^static time_t biofp_last_open;                 \/* GLOBAL *\/$/;"	v	file:
biofp_reopen_interval	ssl_openssl.c	/^static const int biofp_reopen_interval = 600;  \/* GLOBAL *\/$/;"	v	file:
biofp_toggle	ssl_openssl.c	/^static bool biofp_toggle;                      \/* GLOBAL *\/$/;"	v	file:
blank_up	manage.c	/^static const char blank_up[] = "[[BLANK]]";$/;"	v	file:
block_dns_msg_handler	win32.c	/^block_dns_msg_handler(DWORD err, const char *msg)$/;"	f	file:	signature:(DWORD err, const char *msg)
block_dns_msg_handler_t	block_dns.h	/^typedef void (*block_dns_msg_handler_t) (DWORD err, const char *msg);$/;"	t
block_outside_dns	options.h	/^    bool block_outside_dns;$/;"	m	struct:options	access:public
broadcast	tun.h	/^    in_addr_t broadcast;$/;"	m	struct:tuntap	access:public
bucket	list.h	/^    struct hash_bucket *bucket;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_bucket	access:public
bucket_base	multi.h	/^    int bucket_base;$/;"	m	struct:multi_reap	access:public
bucket_index	list.h	/^    int bucket_index;$/;"	m	struct:hash_iterator	access:public
bucket_index_end	list.h	/^    int bucket_index_end;$/;"	m	struct:hash_iterator	access:public
bucket_index_start	list.h	/^    int bucket_index_start;$/;"	m	struct:hash_iterator	access:public
bucket_marked	list.h	/^    bool bucket_marked;$/;"	m	struct:hash_iterator	access:public
buckets	list.h	/^    struct hash_bucket *buckets;$/;"	m	struct:hash	typeref:struct:hash::hash_bucket	access:public
buckets_per_pass	multi.h	/^    int buckets_per_pass;$/;"	m	struct:multi_reap	access:public
buf	buffer.h	/^    struct buffer buf;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer	access:public
buf	fragment.h	/^    struct buffer buf;          \/**< Buffer in which received datagrams$/;"	m	struct:fragment	typeref:struct:fragment::buffer	access:public
buf	manage.h	/^    struct buffer buf;$/;"	m	struct:command_line	typeref:struct:command_line::buffer	access:public
buf	mbuf.h	/^    struct buffer buf;$/;"	m	struct:mbuf_buffer	typeref:struct:mbuf_buffer::buffer	access:public
buf	openvpn.h	/^    struct buffer buf;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
buf	ps.c	/^    struct buffer buf;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::buffer	file:	access:public
buf	reliable.h	/^    struct buffer buf;$/;"	m	struct:reliable_entry	typeref:struct:reliable_entry::buffer	access:public
buf	socket.h	/^    struct buffer buf;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
buf	win32.h	/^    struct buffer buf;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer	access:public
buf_advance	buffer.h	/^buf_advance(struct buffer *buf, int size)$/;"	f	signature:(struct buffer *buf, int size)
buf_assign	buffer.c	/^buf_assign(struct buffer *dest, const struct buffer *src)$/;"	f	signature:(struct buffer *dest, const struct buffer *src)
buf_assign	buffer.h	/^bool buf_assign(struct buffer *dest, const struct buffer *src);$/;"	p	signature:(struct buffer *dest, const struct buffer *src)
buf_bend	buffer.h	/^buf_bend(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_blast	buffer.h	/^buf_blast(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_bptr	buffer.h	/^buf_bptr(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_catrunc	buffer.c	/^buf_catrunc(struct buffer *buf, const char *str)$/;"	f	signature:(struct buffer *buf, const char *str)
buf_catrunc	buffer.h	/^void buf_catrunc(struct buffer *buf, const char *str);$/;"	p	signature:(struct buffer *buf, const char *str)
buf_chomp	buffer.c	/^buf_chomp(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_chomp	buffer.h	/^void buf_chomp(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
buf_clear	buffer.c	/^buf_clear(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_clear	buffer.h	/^void buf_clear(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
buf_copy	buffer.h	/^buf_copy(struct buffer *dest, const struct buffer *src)$/;"	f	signature:(struct buffer *dest, const struct buffer *src)
buf_copy_excess	buffer.h	/^buf_copy_excess(struct buffer *dest,$/;"	f	signature:(struct buffer *dest, struct buffer *src, int len)
buf_copy_n	buffer.h	/^buf_copy_n(struct buffer *dest, struct buffer *src, int n)$/;"	f	signature:(struct buffer *dest, struct buffer *src, int n)
buf_copy_range	buffer.h	/^buf_copy_range(struct buffer *dest,$/;"	f	signature:(struct buffer *dest, int dest_index, const struct buffer *src, int src_index, int src_len)
buf_debug_file	buffer.c	/^buf_debug_file(const struct buffer *buf)$/;"	f	file:	signature:(const struct buffer *buf)
buf_debug_file	buffer.c	157;"	d	file:
buf_debug_line	buffer.c	/^buf_debug_line(const struct buffer *buf)$/;"	f	file:	signature:(const struct buffer *buf)
buf_debug_line	buffer.c	156;"	d	file:
buf_defined	buffer.h	/^buf_defined(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_forward_capacity	buffer.h	/^buf_forward_capacity(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_forward_capacity_total	buffer.h	/^buf_forward_capacity_total(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_free_entries	ssl_mbedtls.c	/^buf_free_entries(endless_buffer *buf)$/;"	f	file:	signature:(endless_buffer *buf)
buf_free_entry	ssl_mbedtls.c	/^buf_free_entry(buffer_entry *entry)$/;"	f	file:	signature:(buffer_entry *entry)
buf_inc_len	buffer.h	/^buf_inc_len(struct buffer *buf, int inc)$/;"	f	signature:(struct buffer *buf, int inc)
buf_init	buffer.h	194;"	d
buf_init	buffer.h	198;"	d
buf_init	socket.h	/^    struct buffer buf_init;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
buf_init	win32.h	/^    struct buffer buf_init;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer	access:public
buf_init_debug	buffer.c	/^buf_init_debug(struct buffer *buf, int offset, const char *file, int line)$/;"	f	signature:(struct buffer *buf, int offset, const char *file, int line)
buf_init_debug	buffer.h	/^bool buf_init_debug(struct buffer *buf, int offset, const char *file, int line);$/;"	p	signature:(struct buffer *buf, int offset, const char *file, int line)
buf_init_dowork	buffer.h	/^buf_init_dowork(struct buffer *buf, int offset)$/;"	f	signature:(struct buffer *buf, int offset)
buf_len	buffer.h	/^buf_len(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_null_terminate	buffer.c	/^buf_null_terminate(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_null_terminate	buffer.h	/^void buf_null_terminate(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
buf_parse	buffer.c	/^buf_parse(struct buffer *buf, const int delim, char *line, const int size)$/;"	f	signature:(struct buffer *buf, const int delim, char *line, const int size)
buf_parse	buffer.h	/^bool buf_parse(struct buffer *buf, const int delim, char *line, const int size);$/;"	p	signature:(struct buffer *buf, const int delim, char *line, const int size)
buf_prepend	buffer.h	/^buf_prepend(struct buffer *buf, int size)$/;"	f	signature:(struct buffer *buf, int size)
buf_printf	buffer.c	/^buf_printf(struct buffer *buf, const char *format, ...)$/;"	f	signature:(struct buffer *buf, const char *format, ...)
buf_printf	buffer.h	/^bool buf_printf(struct buffer *buf, const char *format, ...)$/;"	p	signature:(struct buffer *buf, const char *format, ...)
buf_puts	buffer.c	/^buf_puts(struct buffer *buf, const char *str)$/;"	f	signature:(struct buffer *buf, const char *str)
buf_puts	buffer.h	/^bool buf_puts(struct buffer *buf, const char *str);$/;"	p	signature:(struct buffer *buf, const char *str)
buf_read	buffer.h	/^buf_read(struct buffer *src, void *dest, int size)$/;"	f	signature:(struct buffer *src, void *dest, int size)
buf_read_alloc	buffer.h	/^buf_read_alloc(struct buffer *buf, int size)$/;"	f	signature:(struct buffer *buf, int size)
buf_read_u16	buffer.h	/^buf_read_u16(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_read_u32	buffer.h	/^buf_read_u32(struct buffer *buf, bool *good)$/;"	f	signature:(struct buffer *buf, bool *good)
buf_read_u8	buffer.h	/^buf_read_u8(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_reset	buffer.h	/^buf_reset(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_reset_len	buffer.h	/^buf_reset_len(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
buf_reverse_capacity	buffer.h	/^buf_reverse_capacity(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_rmtail	buffer.c	/^buf_rmtail(struct buffer *buf, uint8_t remove)$/;"	f	signature:(struct buffer *buf, uint8_t remove)
buf_rmtail	buffer.h	/^void buf_rmtail(struct buffer *buf, uint8_t remove);$/;"	p	signature:(struct buffer *buf, uint8_t remove)
buf_safe	buffer.h	/^buf_safe(const struct buffer *buf, int len)$/;"	f	signature:(const struct buffer *buf, int len)
buf_safe_bidir	buffer.h	/^buf_safe_bidir(const struct buffer *buf, int len)$/;"	f	signature:(const struct buffer *buf, int len)
buf_set_read	buffer.h	/^buf_set_read(struct buffer *buf, const uint8_t *data, int size)$/;"	f	signature:(struct buffer *buf, const uint8_t *data, int size)
buf_set_write	buffer.h	/^buf_set_write(struct buffer *buf, uint8_t *data, int size)$/;"	f	signature:(struct buffer *buf, uint8_t *data, int size)
buf_size_error	buffer.c	/^buf_size_error(const size_t size)$/;"	f	signature:(const size_t size)
buf_size_error	buffer.h	/^void buf_size_error(const size_t size);$/;"	p	signature:(const size_t size)
buf_size_valid	buffer.h	/^buf_size_valid(const size_t size)$/;"	f	signature:(const size_t size)
buf_size_valid_signed	buffer.h	/^buf_size_valid_signed(const int size)$/;"	f	signature:(const int size)
buf_str	buffer.h	/^buf_str(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_string_compare_advance	buffer.c	/^buf_string_compare_advance(struct buffer *src, const char *match)$/;"	f	signature:(struct buffer *src, const char *match)
buf_string_compare_advance	buffer.h	/^bool buf_string_compare_advance(struct buffer *src, const char *match);$/;"	p	signature:(struct buffer *src, const char *match)
buf_string_match	buffer.h	/^buf_string_match(const struct buffer *src, const void *match, int size)$/;"	f	signature:(const struct buffer *src, const void *match, int size)
buf_string_match_head	buffer.h	/^buf_string_match_head(const struct buffer *src, const void *match, int size)$/;"	f	signature:(const struct buffer *src, const void *match, int size)
buf_string_match_head_str	buffer.c	/^buf_string_match_head_str(const struct buffer *src, const char *match)$/;"	f	signature:(const struct buffer *src, const char *match)
buf_string_match_head_str	buffer.h	/^bool buf_string_match_head_str(const struct buffer *src, const char *match);$/;"	p	signature:(const struct buffer *src, const char *match)
buf_sub	buffer.c	/^buf_sub(struct buffer *buf, int size, bool prepend)$/;"	f	signature:(struct buffer *buf, int size, bool prepend)
buf_sub	buffer.h	/^struct buffer buf_sub(struct buffer *buf, int size, bool prepend);$/;"	p	signature:(struct buffer *buf, int size, bool prepend)
buf_substring_len	buffer.c	/^buf_substring_len(const struct buffer *buf, int delim)$/;"	f	signature:(const struct buffer *buf, int delim)
buf_substring_len	buffer.h	/^int buf_substring_len(const struct buffer *buf, int delim);$/;"	p	signature:(const struct buffer *buf, int delim)
buf_valid	buffer.h	/^buf_valid(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
buf_write	buffer.h	/^buf_write(struct buffer *dest, const void *src, int size)$/;"	f	signature:(struct buffer *dest, const void *src, int size)
buf_write_alloc	buffer.h	/^buf_write_alloc(struct buffer *buf, int size)$/;"	f	signature:(struct buffer *buf, int size)
buf_write_alloc_prepend	buffer.h	/^buf_write_alloc_prepend(struct buffer *buf, int size, bool prepend)$/;"	f	signature:(struct buffer *buf, int size, bool prepend)
buf_write_prepend	buffer.h	/^buf_write_prepend(struct buffer *dest, const void *src, int size)$/;"	f	signature:(struct buffer *dest, const void *src, int size)
buf_write_string_file	buffer.c	/^buf_write_string_file(const struct buffer *buf, const char *filename, int fd)$/;"	f	signature:(const struct buffer *buf, const char *filename, int fd)
buf_write_string_file	buffer.h	/^void buf_write_string_file(const struct buffer *buf, const char *filename, int fd);$/;"	p	signature:(const struct buffer *buf, const char *filename, int fd)
buf_write_u16	buffer.h	/^buf_write_u16(struct buffer *dest, int data)$/;"	f	signature:(struct buffer *dest, int data)
buf_write_u32	buffer.h	/^buf_write_u32(struct buffer *dest, int data)$/;"	f	signature:(struct buffer *dest, int data)
buf_write_u8	buffer.h	/^buf_write_u8(struct buffer *dest, int data)$/;"	f	signature:(struct buffer *dest, int data)
buffer	buffer.h	/^struct buffer$/;"	s
buffer	mbuf.h	/^    struct mbuf_buffer *buffer;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::mbuf_buffer	access:public
buffer::capacity	buffer.h	/^    int capacity;               \/**< Size in bytes of memory allocated by$/;"	m	struct:buffer	access:public
buffer::data	buffer.h	/^    uint8_t *data;              \/**< Pointer to the allocated memory. *\/$/;"	m	struct:buffer	access:public
buffer::debug_file	buffer.h	/^    const char *debug_file;$/;"	m	struct:buffer	access:public
buffer::debug_line	buffer.h	/^    int debug_line;$/;"	m	struct:buffer	access:public
buffer::len	buffer.h	/^    int len;                    \/**< Length in bytes of the actual content$/;"	m	struct:buffer	access:public
buffer::offset	buffer.h	/^    int offset;                 \/**< Offset in bytes of the actual content$/;"	m	struct:buffer	access:public
buffer_entry	buffer.h	/^struct buffer_entry$/;"	s
buffer_entry	ssl_mbedtls.h	/^typedef struct _buffer_entry buffer_entry;$/;"	t	typeref:struct:_buffer_entry
buffer_entry::buf	buffer.h	/^    struct buffer buf;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer	access:public
buffer_entry::next	buffer.h	/^    struct buffer_entry *next;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer_entry	access:public
buffer_initial	ps.c	/^    bool buffer_initial;$/;"	m	struct:proxy_connection	file:	access:public
buffer_list	buffer.h	/^struct buffer_list$/;"	s
buffer_list::head	buffer.h	/^    struct buffer_entry *head; \/* next item to pop\/peek *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry	access:public
buffer_list::max_size	buffer.h	/^    int max_size;            \/* maximum size list should grow to *\/$/;"	m	struct:buffer_list	access:public
buffer_list::size	buffer.h	/^    int size;                \/* current number of entries *\/$/;"	m	struct:buffer_list	access:public
buffer_list::tail	buffer.h	/^    struct buffer_entry *tail; \/* last item pushed *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry	access:public
buffer_list_advance	buffer.c	/^buffer_list_advance(struct buffer_list *ol, int n)$/;"	f	signature:(struct buffer_list *ol, int n)
buffer_list_advance	buffer.h	/^void buffer_list_advance(struct buffer_list *ol, int n);$/;"	p	signature:(struct buffer_list *ol, int n)
buffer_list_aggregate	buffer.c	/^buffer_list_aggregate(struct buffer_list *bl, const size_t max)$/;"	f	signature:(struct buffer_list *bl, const size_t max)
buffer_list_aggregate	buffer.h	/^void buffer_list_aggregate(struct buffer_list *bl, const size_t max);$/;"	p	signature:(struct buffer_list *bl, const size_t max)
buffer_list_aggregate_separator	buffer.c	/^buffer_list_aggregate_separator(struct buffer_list *bl, const size_t max_len,$/;"	f	signature:(struct buffer_list *bl, const size_t max_len, const char *sep)
buffer_list_aggregate_separator	buffer.h	/^void buffer_list_aggregate_separator(struct buffer_list *bl,$/;"	p	signature:(struct buffer_list *bl, const size_t max_len, const char *sep)
buffer_list_defined	buffer.c	/^buffer_list_defined(const struct buffer_list *ol)$/;"	f	signature:(const struct buffer_list *ol)
buffer_list_defined	buffer.h	/^bool buffer_list_defined(const struct buffer_list *ol);$/;"	p	signature:(const struct buffer_list *ol)
buffer_list_file	buffer.c	/^buffer_list_file(const char *fn, int max_line_len)$/;"	f	signature:(const char *fn, int max_line_len)
buffer_list_file	buffer.h	/^struct buffer_list *buffer_list_file(const char *fn, int max_line_len);$/;"	p	signature:(const char *fn, int max_line_len)
buffer_list_free	buffer.c	/^buffer_list_free(struct buffer_list *ol)$/;"	f	signature:(struct buffer_list *ol)
buffer_list_free	buffer.h	/^void buffer_list_free(struct buffer_list *ol);$/;"	p	signature:(struct buffer_list *ol)
buffer_list_new	buffer.c	/^buffer_list_new(const int max_size)$/;"	f	signature:(const int max_size)
buffer_list_new	buffer.h	/^struct buffer_list *buffer_list_new(const int max_size);$/;"	p	signature:(const int max_size)
buffer_list_peek	buffer.c	/^buffer_list_peek(struct buffer_list *ol)$/;"	f	signature:(struct buffer_list *ol)
buffer_list_peek	buffer.h	/^struct buffer *buffer_list_peek(struct buffer_list *ol);$/;"	p	signature:(struct buffer_list *ol)
buffer_list_pop	buffer.c	/^buffer_list_pop(struct buffer_list *ol)$/;"	f	signature:(struct buffer_list *ol)
buffer_list_pop	buffer.h	/^void buffer_list_pop(struct buffer_list *ol);$/;"	p	signature:(struct buffer_list *ol)
buffer_list_push	buffer.c	/^buffer_list_push(struct buffer_list *ol, const char *str)$/;"	f	signature:(struct buffer_list *ol, const char *str)
buffer_list_push	buffer.h	/^void buffer_list_push(struct buffer_list *ol, const char *str);$/;"	p	signature:(struct buffer_list *ol, const char *str)
buffer_list_push_data	buffer.c	/^buffer_list_push_data(struct buffer_list *ol, const void *data, size_t size)$/;"	f	signature:(struct buffer_list *ol, const void *data, size_t size)
buffer_list_push_data	buffer.h	/^struct buffer_entry *buffer_list_push_data(struct buffer_list *ol, const void *data, size_t size);$/;"	p	signature:(struct buffer_list *ol, const void *data, size_t size)
buffer_list_reset	buffer.c	/^buffer_list_reset(struct buffer_list *ol)$/;"	f	signature:(struct buffer_list *ol)
buffer_list_reset	buffer.h	/^void buffer_list_reset(struct buffer_list *ol);$/;"	p	signature:(struct buffer_list *ol)
buffer_turnover	forward.c	/^buffer_turnover(const uint8_t *orig_buf, struct buffer *dest_stub, struct buffer *src_stub, struct buffer *storage)$/;"	f	file:	signature:(const uint8_t *orig_buf, struct buffer *dest_stub, struct buffer *src_stub, struct buffer *storage)
buffers	openvpn.h	/^    struct context_buffers *buffers;$/;"	m	struct:context_2	typeref:struct:context_2::context_buffers	access:public
buffers_owned	openvpn.h	/^    bool buffers_owned; \/* if true, we should free all buffers on close *\/$/;"	m	struct:context_2	access:public
build_dhcp_options_string	tun.c	/^build_dhcp_options_string(struct buffer *buf, const struct tuntap_options *o)$/;"	f	file:	signature:(struct buffer *buf, const struct tuntap_options *o)
burst	ssl_common.h	/^    bool burst;$/;"	m	struct:tls_session	access:public
bypass	route.h	/^    in_addr_t bypass[N_ROUTE_BYPASS];$/;"	m	struct:route_bypass	access:public
bypass	route.h	/^    struct route_bypass bypass;$/;"	m	struct:route_special_addr	typeref:struct:route_special_addr::route_bypass	access:public
bypass_doubledash	options.c	/^bypass_doubledash(char **p)$/;"	f	file:	signature:(char **p)
bytecount_last_update	manage.h	/^    time_t bytecount_last_update;$/;"	m	struct:man_connection	access:public
bytecount_last_update	manage.h	/^    time_t bytecount_last_update;$/;"	m	struct:man_def_auth_context	access:public
bytecount_update_seconds	manage.h	/^    int bytecount_update_seconds;$/;"	m	struct:man_connection	access:public
bytes_in	manage.h	/^    counter_type bytes_in;$/;"	m	struct:man_persist	access:public
bytes_out	manage.h	/^    counter_type bytes_out;$/;"	m	struct:man_persist	access:public
bytes_per_second	shaper.h	/^    int bytes_per_second;$/;"	m	struct:shaper	access:public
c0	openvpn.h	/^    struct context_0 *c0;       \/**< Level 0 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_0	access:public
c1	openvpn.h	/^    struct context_1 c1;        \/**< Level 1 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_1	access:public
c2	openvpn.h	/^    struct context_2 c2;        \/**< Level 2 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_2	access:public
ca_chain	ssl_mbedtls.h	/^    mbedtls_x509_crt *ca_chain;         \/**< CA chain for remote verification *\/$/;"	m	struct:tls_root_ctx	access:public
ca_file	options.h	/^    const char *ca_file;$/;"	m	struct:options	access:public
ca_file_inline	options.h	/^    const char *ca_file_inline;$/;"	m	struct:options	access:public
ca_path	options.h	/^    const char *ca_path;$/;"	m	struct:options	access:public
cache_generation	mroute.h	/^    unsigned int cache_generation; \/* incremented when route added *\/$/;"	m	struct:mroute_helper	access:public
cache_generation	multi.h	/^    unsigned int cache_generation;$/;"	m	struct:multi_route	access:public
cached_dns_entry	socket.h	/^struct cached_dns_entry {$/;"	s
cached_dns_entry::ai	socket.h	/^    struct addrinfo *ai;$/;"	m	struct:cached_dns_entry	typeref:struct:cached_dns_entry::addrinfo	access:public
cached_dns_entry::ai_family	socket.h	/^    int ai_family;$/;"	m	struct:cached_dns_entry	access:public
cached_dns_entry::flags	socket.h	/^    int flags;$/;"	m	struct:cached_dns_entry	access:public
cached_dns_entry::hostname	socket.h	/^    const char *hostname;$/;"	m	struct:cached_dns_entry	access:public
cached_dns_entry::next	socket.h	/^    struct cached_dns_entry *next;$/;"	m	struct:cached_dns_entry	typeref:struct:cached_dns_entry::cached_dns_entry	access:public
cached_dns_entry::servname	socket.h	/^    const char *servname;$/;"	m	struct:cached_dns_entry	access:public
calc_options_string_link_mtu	options.c	/^calc_options_string_link_mtu(const struct options *o, const struct frame *frame)$/;"	f	file:	signature:(const struct options *o, const struct frame *frame)
callback	manage.h	/^    struct management_callback callback;$/;"	m	struct:man_persist	typeref:struct:man_persist::management_callback	access:public
callbacks	plugin.c	/^static struct openvpn_plugin_callbacks callbacks = {$/;"	v	typeref:struct:openvpn_plugin_callbacks	file:
capacity	argv.h	/^    size_t capacity;$/;"	m	struct:argv	access:public
capacity	buffer.h	/^    int capacity;               \/**< Size in bytes of memory allocated by$/;"	m	struct:buffer	access:public
capacity	event.c	/^    int capacity; \/* fixed largest fd + 1 *\/$/;"	m	struct:se_set	file:	access:public
capacity	event.c	/^    int capacity;$/;"	m	struct:po_set	file:	access:public
capacity	event.c	/^    int capacity;$/;"	m	struct:we_set	file:	access:public
capacity	manage.h	/^    int capacity;$/;"	m	struct:log_history	access:public
capacity	mbuf.h	/^    unsigned int capacity;$/;"	m	struct:mbuf_set	access:public
cc_config	multi.h	/^    struct buffer_list *cc_config;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::buffer_list	access:public
ccd_exclusive	options.h	/^    bool ccd_exclusive;$/;"	m	struct:options	access:public
cd_dir	options.h	/^    const char *cd_dir;$/;"	m	struct:options	access:public
ce	options.h	/^    struct connection_entry ce;$/;"	m	struct:options	typeref:struct:options::connection_entry	access:public
ce_management_query_proxy	init.c	/^ce_management_query_proxy(struct context *c)$/;"	f	file:	signature:(struct context *c)
ce_management_query_remote	init.c	/^ce_management_query_remote(struct context *c)$/;"	f	file:	signature:(struct context *c)
cert_context	cryptoapi.c	/^    const CERT_CONTEXT *cert_context;$/;"	m	struct:_CAPI_DATA	file:	access:public
cert_file	options.h	/^    const char *cert_file;$/;"	m	struct:options	access:public
cert_file_inline	options.h	/^    const char *cert_file_inline;$/;"	m	struct:options	access:public
cert_hash	ssl_verify.h	/^struct cert_hash {$/;"	s
cert_hash::sha256_hash	ssl_verify.h	/^    unsigned char sha256_hash[256\/8];$/;"	m	struct:cert_hash	access:public
cert_hash_compare	ssl_verify.c	/^cert_hash_compare(const struct cert_hash_set *chs1, const struct cert_hash_set *chs2)$/;"	f	signature:(const struct cert_hash_set *chs1, const struct cert_hash_set *chs2)
cert_hash_compare	ssl_verify.h	/^bool cert_hash_compare(const struct cert_hash_set *chs1, const struct cert_hash_set *chs2);$/;"	p	signature:(const struct cert_hash_set *chs1, const struct cert_hash_set *chs2)
cert_hash_copy	ssl_verify.c	/^cert_hash_copy(const struct cert_hash_set *chs)$/;"	f	file:	signature:(const struct cert_hash_set *chs)
cert_hash_free	ssl_verify.c	/^cert_hash_free(struct cert_hash_set *chs)$/;"	f	signature:(struct cert_hash_set *chs)
cert_hash_free	ssl_verify.h	/^void cert_hash_free(struct cert_hash_set *chs);$/;"	p	signature:(struct cert_hash_set *chs)
cert_hash_remember	ssl_verify.c	/^cert_hash_remember(struct tls_session *session, const int error_depth,$/;"	f	signature:(struct tls_session *session, const int error_depth, const struct buffer *cert_hash)
cert_hash_remember	ssl_verify_backend.h	/^void cert_hash_remember(struct tls_session *session, const int cert_depth,$/;"	p	signature:(struct tls_session *session, const int cert_depth, const struct buffer *cert_hash)
cert_hash_set	ssl_common.h	/^    struct cert_hash_set *cert_hash_set;$/;"	m	struct:tls_session	typeref:struct:tls_session::cert_hash_set	access:public
cert_hash_set	ssl_verify.h	/^struct cert_hash_set {$/;"	s
cert_hash_set::ch	ssl_verify.h	/^    struct cert_hash *ch[MAX_CERT_DEPTH]; \/**< Array of certificate hashes *\/$/;"	m	struct:cert_hash_set	typeref:struct:cert_hash_set::cert_hash	access:public
cert_profile	ssl_mbedtls.h	/^    mbedtls_x509_crt_profile cert_profile; \/**< Allowed certificate types *\/$/;"	m	struct:tls_root_ctx	access:public
cf_max	options.h	/^    int cf_max;$/;"	m	struct:options	access:public
cf_per	options.h	/^    int cf_per;$/;"	m	struct:options	access:public
ch	ssl_verify.h	/^    struct cert_hash *ch[MAX_CERT_DEPTH]; \/**< Array of certificate hashes *\/$/;"	m	struct:cert_hash_set	typeref:struct:cert_hash_set::cert_hash	access:public
chaddr	dhcp.h	/^    uint8_t chaddr[16]; \/* client hardware address *\/$/;"	m	struct:dhcp	access:public
challenge_text	misc.h	/^    const char *challenge_text;$/;"	m	struct:auth_challenge_info	access:public
challenge_text	misc.h	/^    const char *challenge_text;$/;"	m	struct:static_challenge_info	access:public
char_class	buffer.c	/^char_class(const unsigned char c, const unsigned int flags)$/;"	f	signature:(const unsigned char c, const unsigned int flags)
char_class	buffer.h	/^bool char_class(const unsigned char c, const unsigned int flags);$/;"	p	signature:(const unsigned char c, const unsigned int flags)
char_inc_exc	buffer.c	/^char_inc_exc(const char c, const unsigned int inclusive, const unsigned int exclusive)$/;"	f	file:	signature:(const char c, const unsigned int inclusive, const unsigned int exclusive)
character_class_debug	buffer.c	/^character_class_debug(void)$/;"	f	signature:(void)
character_class_debug	buffer.h	/^void character_class_debug(void);$/;"	p	signature:(void)
check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_iphdr	access:public
check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_tcphdr	access:public
check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_udphdr	access:public
check_add_routes	forward-inline.h	/^check_add_routes(struct context *c)$/;"	f	signature:(struct context *c)
check_add_routes_action	forward.c	/^check_add_routes_action(struct context *c, const bool errors)$/;"	f	file:	signature:(struct context *c, const bool errors)
check_add_routes_dowork	forward.c	/^check_add_routes_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_addr_clash	tun.c	/^check_addr_clash(const char *name,$/;"	f	file:	signature:(const char *name, int type, in_addr_t public, in_addr_t local, in_addr_t remote_netmask)
check_cmd_access	options.c	/^check_cmd_access(const char *command, const char *opt, const char *chroot)$/;"	f	file:	signature:(const char *command, const char *opt, const char *chroot)
check_coarse_timers	forward.c	/^check_coarse_timers(struct context *c)$/;"	f	file:	signature:(struct context *c)
check_coarse_timers_dowork	forward.c	/^check_coarse_timers_dowork(struct context *c)$/;"	f	file:	signature:(struct context *c)
check_connection_established	forward-inline.h	/^check_connection_established(struct context *c)$/;"	f	signature:(struct context *c)
check_connection_established_dowork	forward.c	/^check_connection_established_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_debug_level	error.h	/^check_debug_level(unsigned int level)$/;"	f	signature:(unsigned int level)
check_file_access	options.c	/^check_file_access(const int type, const char *file, const int mode, const char *opt)$/;"	f	file:	signature:(const int type, const char *file, const int mode, const char *opt)
check_file_access_chroot	options.c	/^check_file_access_chroot(const char *chroot, const int type, const char *file, const int mode, const char *opt)$/;"	f	file:	signature:(const char *chroot, const int type, const char *file, const int mode, const char *opt)
check_fragment	forward-inline.h	/^check_fragment(struct context *c)$/;"	f	signature:(struct context *c)
check_fragment_dowork	forward.c	/^check_fragment_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_inactivity_timeout	forward-inline.h	/^check_inactivity_timeout(struct context *c)$/;"	f	signature:(struct context *c)
check_inactivity_timeout_dowork	forward.c	/^check_inactivity_timeout_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_incoming_control_channel	forward-inline.h	/^check_incoming_control_channel(struct context *c)$/;"	f	signature:(struct context *c)
check_incoming_control_channel_dowork	forward.c	/^check_incoming_control_channel_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_inline_file	options.c	/^check_inline_file(struct in_src *is, char *p[], struct gc_arena *gc)$/;"	f	file:	signature:(struct in_src *is, char *p[], struct gc_arena *gc)
check_inline_file_via_buf	options.c	/^check_inline_file_via_buf(struct buffer *multiline, char *p[], struct gc_arena *gc)$/;"	f	file:	signature:(struct buffer *multiline, char *p[], struct gc_arena *gc)
check_inline_file_via_fp	options.c	/^check_inline_file_via_fp(FILE *fp, char *p[], struct gc_arena *gc)$/;"	f	file:	signature:(FILE *fp, char *p[], struct gc_arena *gc)
check_key	crypto.c	/^check_key(struct key *key, const struct key_type *kt)$/;"	f	signature:(struct key *key, const struct key_type *kt)
check_key	crypto.h	/^bool check_key(struct key *key, const struct key_type *kt);$/;"	p	signature:(struct key *key, const struct key_type *kt)
check_malloc_return	buffer.h	/^check_malloc_return(const void *p)$/;"	f	signature:(const void *p)
check_packet_id_persist_flush	forward-inline.h	/^check_packet_id_persist_flush(struct context *c)$/;"	f	signature:(struct context *c)
check_ping_restart	ping-inline.h	/^check_ping_restart(struct context *c)$/;"	f	signature:(struct context *c)
check_ping_restart_dowork	ping.c	/^check_ping_restart_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_ping_send	ping-inline.h	/^check_ping_send(struct context *c)$/;"	f	signature:(struct context *c)
check_ping_send_dowork	ping.c	/^check_ping_send_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_push_request	forward-inline.h	/^check_push_request(struct context *c)$/;"	f	signature:(struct context *c)
check_push_request_dowork	forward.c	/^check_push_request_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_replay_iv_consistency	crypto.c	/^check_replay_iv_consistency(const struct key_type *kt, bool packet_id, bool use_iv)$/;"	f	signature:(const struct key_type *kt, bool packet_id, bool use_iv)
check_replay_iv_consistency	crypto.h	/^void check_replay_iv_consistency(const struct key_type *kt, bool packet_id, bool use_iv);$/;"	p	signature:(const struct key_type *kt, bool packet_id, bool use_iv)
check_scheduled_exit	forward-inline.h	/^check_scheduled_exit(struct context *c)$/;"	f	signature:(struct context *c)
check_scheduled_exit_dowork	forward.c	/^check_scheduled_exit_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_load_test	occ-inline.h	/^check_send_occ_load_test(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_load_test_dowork	occ.c	/^check_send_occ_load_test_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_msg	occ-inline.h	/^check_send_occ_msg(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_msg_dowork	occ.c	/^check_send_occ_msg_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_req	occ-inline.h	/^check_send_occ_req(struct context *c)$/;"	f	signature:(struct context *c)
check_send_occ_req_dowork	occ.c	/^check_send_occ_req_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_server_poll_timeout	forward-inline.h	/^check_server_poll_timeout(struct context *c)$/;"	f	signature:(struct context *c)
check_server_poll_timeout_dowork	forward.c	/^check_server_poll_timeout_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_stale_routes	multi.c	/^check_stale_routes(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
check_status	error.h	/^check_status(int status, const char *description, struct link_socket *sock, struct tuntap *tt)$/;"	f	signature:(int status, const char *description, struct link_socket *sock, struct tuntap *tt)
check_status_file	forward-inline.h	/^check_status_file(struct context *c)$/;"	f	signature:(struct context *c)
check_status_file_dowork	forward.c	/^check_status_file_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_subnet_conflict	tun.c	/^check_subnet_conflict(const in_addr_t ip,$/;"	f	signature:(const in_addr_t ip, const in_addr_t netmask, const char *prefix)
check_subnet_conflict	tun.h	/^void check_subnet_conflict(const in_addr_t ip,$/;"	p	signature:(const in_addr_t ip, const in_addr_t netmask, const char *prefix)
check_systemd_running	console_systemd.c	/^check_systemd_running(void)$/;"	f	file:	signature:(void)
check_timeout_random_component	forward.c	/^check_timeout_random_component(struct context *c)$/;"	f	file:	signature:(struct context *c)
check_timeout_random_component_dowork	forward.c	/^check_timeout_random_component_dowork(struct context *c)$/;"	f	file:	signature:(struct context *c)
check_timestamp_delta	packet_id.h	/^check_timestamp_delta(time_t remote, unsigned int max_delta)$/;"	f	signature:(time_t remote, unsigned int max_delta)
check_tls	forward-inline.h	/^check_tls(struct context *c)$/;"	f	signature:(struct context *c)
check_tls_dowork	forward.c	/^check_tls_dowork(struct context *c)$/;"	f	signature:(struct context *c)
check_tls_errors	forward-inline.h	/^check_tls_errors(struct context *c)$/;"	f	signature:(struct context *c)
check_tls_errors_co	forward.c	/^check_tls_errors_co(struct context *c)$/;"	f	signature:(struct context *c)
check_tls_errors_nco	forward.c	/^check_tls_errors_nco(struct context *c)$/;"	f	signature:(struct context *c)
chomp	buffer.c	/^chomp(char *str)$/;"	f	signature:(char *str)
chomp	buffer.h	/^void chomp(char *str);$/;"	p	signature:(char *str)
chroot_dir	options.h	/^    const char *chroot_dir;$/;"	m	struct:options	access:public
ciaddr	dhcp.h	/^    uint32_t ciaddr;   \/* client IP address, client sets if known *\/$/;"	m	struct:dhcp	access:public
cid	manage.h	/^    unsigned long cid;$/;"	m	struct:man_def_auth_context	access:public
cid_compare_function	multi.c	/^cid_compare_function(const void *key1, const void *key2)$/;"	f	file:	signature:(const void *key1, const void *key2)
cid_counter	multi.h	/^    unsigned long cid_counter;$/;"	m	struct:multi_context	access:public
cid_hash	multi.h	/^    struct hash *cid_hash;$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
cid_hash_function	multi.c	/^cid_hash_function(const void *key, uint32_t iv)$/;"	f	file:	signature:(const void *key, uint32_t iv)
cipher	crypto.h	/^    cipher_ctx_t *cipher;       \/**< Generic cipher %context. *\/$/;"	m	struct:key_ctx	access:public
cipher	crypto.h	/^    const cipher_kt_t *cipher;  \/**< Cipher static parameters *\/$/;"	m	struct:key_type	access:public
cipher	crypto.h	/^    uint8_t cipher[MAX_CIPHER_KEY_LENGTH];$/;"	m	struct:key	access:public
cipher_ctx_block_size	crypto_backend.h	/^int cipher_ctx_block_size(const cipher_ctx_t *ctx);$/;"	p	signature:(const cipher_ctx_t *ctx)
cipher_ctx_block_size	crypto_mbedtls.c	/^cipher_ctx_block_size(const mbedtls_cipher_context_t *ctx)$/;"	f	signature:(const mbedtls_cipher_context_t *ctx)
cipher_ctx_block_size	crypto_openssl.c	/^cipher_ctx_block_size(const EVP_CIPHER_CTX *ctx)$/;"	f	signature:(const EVP_CIPHER_CTX *ctx)
cipher_ctx_cleanup	crypto_backend.h	/^void cipher_ctx_cleanup(cipher_ctx_t *ctx);$/;"	p	signature:(cipher_ctx_t *ctx)
cipher_ctx_cleanup	crypto_mbedtls.c	/^cipher_ctx_cleanup(mbedtls_cipher_context_t *ctx)$/;"	f	signature:(mbedtls_cipher_context_t *ctx)
cipher_ctx_cleanup	crypto_openssl.c	/^cipher_ctx_cleanup(EVP_CIPHER_CTX *ctx)$/;"	f	signature:(EVP_CIPHER_CTX *ctx)
cipher_ctx_final	crypto_backend.h	/^int cipher_ctx_final(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len);$/;"	p	signature:(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len)
cipher_ctx_final	crypto_mbedtls.c	/^cipher_ctx_final(mbedtls_cipher_context_t *ctx, uint8_t *dst, int *dst_len)$/;"	f	signature:(mbedtls_cipher_context_t *ctx, uint8_t *dst, int *dst_len)
cipher_ctx_final	crypto_openssl.c	/^cipher_ctx_final(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len)$/;"	f	signature:(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len)
cipher_ctx_final_check_tag	crypto_backend.h	/^int cipher_ctx_final_check_tag(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len,$/;"	p	signature:(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len, uint8_t *tag, size_t tag_len)
cipher_ctx_final_check_tag	crypto_mbedtls.c	/^cipher_ctx_final_check_tag(mbedtls_cipher_context_t *ctx, uint8_t *dst,$/;"	f	signature:(mbedtls_cipher_context_t *ctx, uint8_t *dst, int *dst_len, uint8_t *tag, size_t tag_len)
cipher_ctx_final_check_tag	crypto_openssl.c	/^cipher_ctx_final_check_tag(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len,$/;"	f	signature:(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len, uint8_t *tag, size_t tag_len)
cipher_ctx_free	crypto_backend.h	/^void cipher_ctx_free(cipher_ctx_t *ctx);$/;"	p	signature:(cipher_ctx_t *ctx)
cipher_ctx_free	crypto_mbedtls.c	/^cipher_ctx_free(mbedtls_cipher_context_t *ctx)$/;"	f	signature:(mbedtls_cipher_context_t *ctx)
cipher_ctx_free	crypto_openssl.c	/^cipher_ctx_free(EVP_CIPHER_CTX *ctx)$/;"	f	signature:(EVP_CIPHER_CTX *ctx)
cipher_ctx_get_cipher_kt	crypto_backend.h	/^const cipher_kt_t *cipher_ctx_get_cipher_kt(const cipher_ctx_t *ctx);$/;"	p	signature:(const cipher_ctx_t *ctx)
cipher_ctx_get_cipher_kt	crypto_mbedtls.c	/^cipher_ctx_get_cipher_kt(const cipher_ctx_t *ctx)$/;"	f	signature:(const cipher_ctx_t *ctx)
cipher_ctx_get_cipher_kt	crypto_openssl.c	/^cipher_ctx_get_cipher_kt(const cipher_ctx_t *ctx)$/;"	f	signature:(const cipher_ctx_t *ctx)
cipher_ctx_get_tag	crypto_backend.h	/^int cipher_ctx_get_tag(cipher_ctx_t *ctx, uint8_t *tag, int tag_len);$/;"	p	signature:(cipher_ctx_t *ctx, uint8_t *tag, int tag_len)
cipher_ctx_get_tag	crypto_mbedtls.c	/^cipher_ctx_get_tag(cipher_ctx_t *ctx, uint8_t *tag, int tag_len)$/;"	f	signature:(cipher_ctx_t *ctx, uint8_t *tag, int tag_len)
cipher_ctx_get_tag	crypto_openssl.c	/^cipher_ctx_get_tag(EVP_CIPHER_CTX *ctx, uint8_t *tag_buf, int tag_size)$/;"	f	signature:(EVP_CIPHER_CTX *ctx, uint8_t *tag_buf, int tag_size)
cipher_ctx_init	crypto_backend.h	/^void cipher_ctx_init(cipher_ctx_t *ctx, const uint8_t *key, int key_len,$/;"	p	signature:(cipher_ctx_t *ctx, const uint8_t *key, int key_len, const cipher_kt_t *kt, int enc)
cipher_ctx_init	crypto_mbedtls.c	/^cipher_ctx_init(mbedtls_cipher_context_t *ctx, const uint8_t *key, int key_len,$/;"	f	signature:(mbedtls_cipher_context_t *ctx, const uint8_t *key, int key_len, const mbedtls_cipher_info_t *kt, const mbedtls_operation_t operation)
cipher_ctx_init	crypto_openssl.c	/^cipher_ctx_init(EVP_CIPHER_CTX *ctx, const uint8_t *key, int key_len,$/;"	f	signature:(EVP_CIPHER_CTX *ctx, const uint8_t *key, int key_len, const EVP_CIPHER *kt, int enc)
cipher_ctx_iv_length	crypto_backend.h	/^int cipher_ctx_iv_length(const cipher_ctx_t *ctx);$/;"	p	signature:(const cipher_ctx_t *ctx)
cipher_ctx_iv_length	crypto_mbedtls.c	/^cipher_ctx_iv_length(const mbedtls_cipher_context_t *ctx)$/;"	f	signature:(const mbedtls_cipher_context_t *ctx)
cipher_ctx_iv_length	crypto_openssl.c	/^cipher_ctx_iv_length(const EVP_CIPHER_CTX *ctx)$/;"	f	signature:(const EVP_CIPHER_CTX *ctx)
cipher_ctx_mode	crypto_backend.h	/^int cipher_ctx_mode(const cipher_ctx_t *ctx);$/;"	p	signature:(const cipher_ctx_t *ctx)
cipher_ctx_mode	crypto_mbedtls.c	/^cipher_ctx_mode(const mbedtls_cipher_context_t *ctx)$/;"	f	signature:(const mbedtls_cipher_context_t *ctx)
cipher_ctx_mode	crypto_openssl.c	/^cipher_ctx_mode(const EVP_CIPHER_CTX *ctx)$/;"	f	signature:(const EVP_CIPHER_CTX *ctx)
cipher_ctx_new	crypto_backend.h	/^cipher_ctx_t *cipher_ctx_new(void);$/;"	p	signature:(void)
cipher_ctx_new	crypto_mbedtls.c	/^cipher_ctx_new(void)$/;"	f	signature:(void)
cipher_ctx_new	crypto_openssl.c	/^cipher_ctx_new(void)$/;"	f	signature:(void)
cipher_ctx_reset	crypto_backend.h	/^int cipher_ctx_reset(cipher_ctx_t *ctx, uint8_t *iv_buf);$/;"	p	signature:(cipher_ctx_t *ctx, uint8_t *iv_buf)
cipher_ctx_reset	crypto_mbedtls.c	/^cipher_ctx_reset(mbedtls_cipher_context_t *ctx, uint8_t *iv_buf)$/;"	f	signature:(mbedtls_cipher_context_t *ctx, uint8_t *iv_buf)
cipher_ctx_reset	crypto_openssl.c	/^cipher_ctx_reset(EVP_CIPHER_CTX *ctx, uint8_t *iv_buf)$/;"	f	signature:(EVP_CIPHER_CTX *ctx, uint8_t *iv_buf)
cipher_ctx_t	crypto_mbedtls.h	/^typedef mbedtls_cipher_context_t cipher_ctx_t;$/;"	t
cipher_ctx_t	crypto_openssl.h	/^typedef EVP_CIPHER_CTX cipher_ctx_t;$/;"	t
cipher_ctx_update	crypto_backend.h	/^int cipher_ctx_update(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len,$/;"	p	signature:(cipher_ctx_t *ctx, uint8_t *dst, int *dst_len, uint8_t *src, int src_len)
cipher_ctx_update	crypto_mbedtls.c	/^cipher_ctx_update(mbedtls_cipher_context_t *ctx, uint8_t *dst,$/;"	f	signature:(mbedtls_cipher_context_t *ctx, uint8_t *dst, int *dst_len, uint8_t *src, int src_len)
cipher_ctx_update	crypto_openssl.c	/^cipher_ctx_update(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len,$/;"	f	signature:(EVP_CIPHER_CTX *ctx, uint8_t *dst, int *dst_len, uint8_t *src, int src_len)
cipher_ctx_update_ad	crypto_backend.h	/^int cipher_ctx_update_ad(cipher_ctx_t *ctx, const uint8_t *src, int src_len);$/;"	p	signature:(cipher_ctx_t *ctx, const uint8_t *src, int src_len)
cipher_ctx_update_ad	crypto_mbedtls.c	/^cipher_ctx_update_ad(cipher_ctx_t *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(cipher_ctx_t *ctx, const uint8_t *src, int src_len)
cipher_ctx_update_ad	crypto_openssl.c	/^cipher_ctx_update_ad(EVP_CIPHER_CTX *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(EVP_CIPHER_CTX *ctx, const uint8_t *src, int src_len)
cipher_des_encrypt_ecb	crypto_backend.h	/^void cipher_des_encrypt_ecb(const unsigned char key[DES_KEY_LENGTH],$/;"	p	signature:(const unsigned char key[DES_KEY_LENGTH], unsigned char src[DES_KEY_LENGTH], unsigned char dst[DES_KEY_LENGTH])
cipher_des_encrypt_ecb	crypto_mbedtls.c	/^cipher_des_encrypt_ecb(const unsigned char key[DES_KEY_LENGTH],$/;"	f	signature:(const unsigned char key[DES_KEY_LENGTH], unsigned char *src, unsigned char *dst)
cipher_des_encrypt_ecb	crypto_openssl.c	/^cipher_des_encrypt_ecb(const unsigned char key[DES_KEY_LENGTH],$/;"	f	signature:(const unsigned char key[DES_KEY_LENGTH], unsigned char *src, unsigned char *dst)
cipher_kt_block_size	crypto_backend.h	/^int cipher_kt_block_size(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_block_size	crypto_mbedtls.c	/^cipher_kt_block_size(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_block_size	crypto_openssl.c	/^cipher_kt_block_size(const EVP_CIPHER *cipher)$/;"	f	signature:(const EVP_CIPHER *cipher)
cipher_kt_get	crypto_backend.h	/^const cipher_kt_t *cipher_kt_get(const char *ciphername);$/;"	p	signature:(const char *ciphername)
cipher_kt_get	crypto_mbedtls.c	/^cipher_kt_get(const char *ciphername)$/;"	f	signature:(const char *ciphername)
cipher_kt_get	crypto_openssl.c	/^cipher_kt_get(const char *ciphername)$/;"	f	signature:(const char *ciphername)
cipher_kt_iv_size	crypto_backend.h	/^int cipher_kt_iv_size(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_iv_size	crypto_mbedtls.c	/^cipher_kt_iv_size(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_iv_size	crypto_openssl.c	/^cipher_kt_iv_size(const EVP_CIPHER *cipher_kt)$/;"	f	signature:(const EVP_CIPHER *cipher_kt)
cipher_kt_key_size	crypto_backend.h	/^int cipher_kt_key_size(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_key_size	crypto_mbedtls.c	/^cipher_kt_key_size(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_key_size	crypto_openssl.c	/^cipher_kt_key_size(const EVP_CIPHER *cipher_kt)$/;"	f	signature:(const EVP_CIPHER *cipher_kt)
cipher_kt_mode	crypto_backend.h	/^int cipher_kt_mode(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_mode	crypto_mbedtls.c	/^cipher_kt_mode(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_mode	crypto_openssl.c	/^cipher_kt_mode(const EVP_CIPHER *cipher_kt)$/;"	f	signature:(const EVP_CIPHER *cipher_kt)
cipher_kt_mode_aead	crypto_backend.h	/^bool cipher_kt_mode_aead(const cipher_kt_t *cipher);$/;"	p	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_aead	crypto_mbedtls.c	/^cipher_kt_mode_aead(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_aead	crypto_openssl.c	/^cipher_kt_mode_aead(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_cbc	crypto_backend.h	/^bool cipher_kt_mode_cbc(const cipher_kt_t *cipher);$/;"	p	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_cbc	crypto_mbedtls.c	/^cipher_kt_mode_cbc(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_cbc	crypto_openssl.c	/^cipher_kt_mode_cbc(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_ofb_cfb	crypto_backend.h	/^bool cipher_kt_mode_ofb_cfb(const cipher_kt_t *cipher);$/;"	p	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_ofb_cfb	crypto_mbedtls.c	/^cipher_kt_mode_ofb_cfb(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_mode_ofb_cfb	crypto_openssl.c	/^cipher_kt_mode_ofb_cfb(const cipher_kt_t *cipher)$/;"	f	signature:(const cipher_kt_t *cipher)
cipher_kt_name	crypto_backend.h	/^const char *cipher_kt_name(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_name	crypto_mbedtls.c	/^cipher_kt_name(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_name	crypto_openssl.c	/^cipher_kt_name(const EVP_CIPHER *cipher_kt)$/;"	f	signature:(const EVP_CIPHER *cipher_kt)
cipher_kt_t	crypto_mbedtls.h	/^typedef mbedtls_cipher_info_t cipher_kt_t;$/;"	t
cipher_kt_t	crypto_openssl.h	/^typedef EVP_CIPHER cipher_kt_t;$/;"	t
cipher_kt_tag_size	crypto_backend.h	/^int cipher_kt_tag_size(const cipher_kt_t *cipher_kt);$/;"	p	signature:(const cipher_kt_t *cipher_kt)
cipher_kt_tag_size	crypto_mbedtls.c	/^cipher_kt_tag_size(const mbedtls_cipher_info_t *cipher_kt)$/;"	f	signature:(const mbedtls_cipher_info_t *cipher_kt)
cipher_kt_tag_size	crypto_openssl.c	/^cipher_kt_tag_size(const EVP_CIPHER *cipher_kt)$/;"	f	signature:(const EVP_CIPHER *cipher_kt)
cipher_length	crypto.h	/^    uint8_t cipher_length;      \/**< Cipher length, in bytes *\/$/;"	m	struct:key_type	access:public
cipher_list	options.h	/^    const char *cipher_list;$/;"	m	struct:options	access:public
cipher_list_tls13	options.h	/^    const char *cipher_list_tls13;$/;"	m	struct:options	access:public
cipher_name_cmp	crypto_openssl.c	/^cipher_name_cmp(const void *a, const void *b)$/;"	f	file:	signature:(const void *a, const void *b)
cipher_name_pair	crypto_backend.h	/^} cipher_name_pair;$/;"	t	typeref:struct:__anon16
cipher_name_translation_table	crypto_mbedtls.c	/^const cipher_name_pair cipher_name_translation_table[] = {$/;"	v
cipher_name_translation_table	crypto_openssl.c	/^const cipher_name_pair cipher_name_translation_table[] = {$/;"	v
cipher_name_translation_table_count	crypto_mbedtls.c	/^const size_t cipher_name_translation_table_count =$/;"	v
cipher_name_translation_table_count	crypto_openssl.c	/^const size_t cipher_name_translation_table_count =$/;"	v
ciphername	openvpn.h	/^    const char *ciphername;     \/**< Data channel cipher from config file *\/$/;"	m	struct:context_1	access:public
ciphername	options.h	/^    const char *ciphername;$/;"	m	struct:options	access:public
clear_buf	buffer.c	/^clear_buf(void)$/;"	f	signature:(void)
clear_buf	buffer.h	/^struct buffer clear_buf(void);$/;"	p	signature:(void)
clear_prefix	multi.h	/^clear_prefix(void)$/;"	f	signature:(void)
clear_remote_addrlist	init.c	/^clear_remote_addrlist(struct link_socket_addr *lsa, bool free)$/;"	f	file:	signature:(struct link_socket_addr *lsa, bool free)
clear_route_ipv6_list	route.c	/^clear_route_ipv6_list(struct route_ipv6_list *rl6)$/;"	f	file:	signature:(struct route_ipv6_list *rl6)
clear_route_list	route.c	/^clear_route_list(struct route_list *rl)$/;"	f	file:	signature:(struct route_list *rl)
clear_tuntap	tun.c	/^clear_tuntap(struct tuntap *tuntap)$/;"	f	file:	signature:(struct tuntap *tuntap)
clear_tuntap	tun.c	/^static void clear_tuntap(struct tuntap *tuntap);$/;"	p	file:	signature:(struct tuntap *tuntap)
clear_user_pass_http	proxy.c	/^clear_user_pass_http(void)$/;"	f	file:	signature:(void)
client	options.h	/^    bool client;$/;"	m	struct:options	access:public
client	ssl_common.h	/^    struct key_source client;   \/**< Random provided by client. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source	access:public
client_auth	manage.h	/^    bool (*client_auth) (void *arg,$/;"	m	struct:management_callback	access:public
client_config_dir	options.h	/^    const char *client_config_dir;$/;"	m	struct:options	access:public
client_config_dir_exclusive	ssl_common.h	/^    const char *client_config_dir_exclusive;$/;"	m	struct:tls_options	access:public
client_connect_script	options.h	/^    const char *client_connect_script;$/;"	m	struct:options	access:public
client_constructor	plugin.h	/^    openvpn_plugin_client_constructor_v1 client_constructor;$/;"	m	struct:plugin	access:public
client_destructor	plugin.h	/^    openvpn_plugin_client_destructor_v1 client_destructor;$/;"	m	struct:plugin	access:public
client_disconnect_script	options.h	/^    const char *client_disconnect_script;$/;"	m	struct:options	access:public
client_gid	manage.h	/^    int client_gid;$/;"	m	struct:man_settings	access:public
client_nat	options.h	/^    struct client_nat_option_list *client_nat;$/;"	m	struct:options	typeref:struct:options::client_nat_option_list	access:public
client_nat	options.h	/^    struct client_nat_option_list *client_nat;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::client_nat_option_list	access:public
client_nat_defined	options.h	/^    bool client_nat_defined;$/;"	m	struct:options_pre_pull	access:public
client_nat_entry	clinat.h	/^struct client_nat_entry {$/;"	s
client_nat_entry::foreign_network	clinat.h	/^    in_addr_t foreign_network;$/;"	m	struct:client_nat_entry	access:public
client_nat_entry::netmask	clinat.h	/^    in_addr_t netmask;$/;"	m	struct:client_nat_entry	access:public
client_nat_entry::network	clinat.h	/^    in_addr_t network;$/;"	m	struct:client_nat_entry	access:public
client_nat_entry::type	clinat.h	/^    int type;$/;"	m	struct:client_nat_entry	access:public
client_nat_option_list	clinat.h	/^struct client_nat_option_list {$/;"	s
client_nat_option_list::entries	clinat.h	/^    struct client_nat_entry entries[MAX_CLIENT_NAT];$/;"	m	struct:client_nat_option_list	typeref:struct:client_nat_option_list::client_nat_entry	access:public
client_nat_option_list::n	clinat.h	/^    int n;$/;"	m	struct:client_nat_option_list	access:public
client_nat_transform	clinat.c	/^client_nat_transform(const struct client_nat_option_list *list,$/;"	f	signature:(const struct client_nat_option_list *list, struct buffer *ipbuf, const int direction)
client_nat_transform	clinat.h	/^void client_nat_transform(const struct client_nat_option_list *list,$/;"	p	signature:(const struct client_nat_option_list *list, struct buffer *ipbuf, const int direction)
client_pf	manage.h	/^    bool (*client_pf)(void *arg,$/;"	m	struct:management_callback	access:public
client_reason	ssl_common.h	/^    char *client_reason;$/;"	m	struct:tls_multi	access:public
client_uid	manage.h	/^    int client_uid;$/;"	m	struct:man_settings	access:public
clone_buf	buffer.h	/^struct buffer clone_buf(const struct buffer *buf);$/;"	p	signature:(const struct buffer *buf)
clone_buf	buffer.h	157;"	d
clone_buf_debug	buffer.c	/^clone_buf_debug(const struct buffer *buf, const char *file, int line)$/;"	f	signature:(const struct buffer *buf, const char *file, int line)
clone_buf_debug	buffer.h	/^struct buffer clone_buf_debug(const struct buffer *buf, const char *file, int line);$/;"	p	signature:(const struct buffer *buf, const char *file, int line)
clone_client_nat_option_list	clinat.c	/^clone_client_nat_option_list(const struct client_nat_option_list *src, struct gc_arena *gc)$/;"	f	signature:(const struct client_nat_option_list *src, struct gc_arena *gc)
clone_client_nat_option_list	clinat.h	/^struct client_nat_option_list *clone_client_nat_option_list(const struct client_nat_option_list *src, struct gc_arena *gc);$/;"	p	signature:(const struct client_nat_option_list *src, struct gc_arena *gc)
clone_push_list	push.c	/^clone_push_list(struct options *o)$/;"	f	signature:(struct options *o)
clone_push_list	push.h	/^void clone_push_list(struct options *o);$/;"	p	signature:(struct options *o)
clone_route_ipv6_option_list	route.c	/^clone_route_ipv6_option_list(const struct route_ipv6_option_list *src, struct gc_arena *a)$/;"	f	signature:(const struct route_ipv6_option_list *src, struct gc_arena *a)
clone_route_ipv6_option_list	route.h	/^struct route_ipv6_option_list *clone_route_ipv6_option_list(const struct route_ipv6_option_list *src, struct gc_arena *a);$/;"	p	signature:(const struct route_ipv6_option_list *src, struct gc_arena *a)
clone_route_option_list	route.c	/^clone_route_option_list(const struct route_option_list *src, struct gc_arena *a)$/;"	f	signature:(const struct route_option_list *src, struct gc_arena *a)
clone_route_option_list	route.h	/^struct route_option_list *clone_route_option_list(const struct route_option_list *src, struct gc_arena *a);$/;"	p	signature:(const struct route_option_list *src, struct gc_arena *a)
close	plugin.h	/^    openvpn_plugin_close_v1 close;$/;"	m	struct:plugin	access:public
close_biofp	ssl_openssl.c	/^close_biofp(void)$/;"	f	file:	signature:(void)
close_context	init.c	/^close_context(struct context *c, int sig, unsigned int flags)$/;"	f	signature:(struct context *c, int sig, unsigned int flags)
close_context	init.h	/^void close_context(struct context *c, int sig, unsigned int flags);$/;"	p	signature:(struct context *c, int sig, unsigned int flags)
close_fds_except	ps.c	/^close_fds_except(int keep)$/;"	f	file:	signature:(int keep)
close_instance	init.c	/^close_instance(struct context *c)$/;"	f	signature:(struct context *c)
close_instance	init.h	/^void close_instance(struct context *c);$/;"	p	signature:(struct context *c)
close_management	init.c	/^close_management(void)$/;"	f	signature:(void)
close_management	init.h	/^void close_management(void);$/;"	p	signature:(void)
close_net_event_win32	win32.c	/^close_net_event_win32(struct rw_handle *event, socket_descriptor_t sd, unsigned int flags)$/;"	f	signature:(struct rw_handle *event, socket_descriptor_t sd, unsigned int flags)
close_net_event_win32	win32.h	/^void close_net_event_win32(struct rw_handle *event, socket_descriptor_t sd, unsigned int flags);$/;"	p	signature:(struct rw_handle *event, socket_descriptor_t sd, unsigned int flags)
close_port_share	init.c	/^close_port_share(void)$/;"	f	file:	signature:(void)
close_socket_if_defined	ps.c	/^close_socket_if_defined(const socket_descriptor_t sd)$/;"	f	file:	signature:(const socket_descriptor_t sd)
close_syslog	error.c	/^close_syslog(void)$/;"	f	signature:(void)
close_syslog	error.h	/^void close_syslog(void);$/;"	p	signature:(void)
close_tty	console_builtin.c	/^close_tty(FILE *fp)$/;"	f	file:	signature:(FILE *fp)
close_tun	tun.c	/^close_tun(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
close_tun	tun.h	/^void close_tun(struct tuntap *tt);$/;"	p	signature:(struct tuntap *tt)
close_tun_generic	tun.c	/^close_tun_generic(struct tuntap *tt)$/;"	f	file:	signature:(struct tuntap *tt)
cmp_prefix	win32.c	/^cmp_prefix(const char *str, const bool n, const char *pre)$/;"	f	file:	signature:(const char *str, const bool n, const char *pre)
cmsg_size	ps.c	/^cmsg_size(void)$/;"	f	file:	signature:(void)
cn	pf.h	/^    char *cn;$/;"	m	struct:pf_cn	access:public
cn_compare_function	pf.c	/^cn_compare_function(const void *key1, const void *key2)$/;"	f	file:	signature:(const void *key1, const void *key2)
cn_hash_function	pf.c	/^cn_hash_function(const void *key, uint32_t iv)$/;"	f	file:	signature:(const void *key, uint32_t iv)
cnol_check_alloc	options.c	/^cnol_check_alloc(struct options *options)$/;"	f	file:	signature:(struct options *options)
cns	pf.h	/^    struct pf_cn_set cns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_cn_set	access:public
coarse_timer_wakeup	openvpn.h	/^    time_t coarse_timer_wakeup;$/;"	m	struct:context_2	access:public
coll	schedule.c	/^    int coll;$/;"	m	struct:status	file:	access:public
command_line	manage.h	/^struct command_line$/;"	s
command_line::buf	manage.h	/^    struct buffer buf;$/;"	m	struct:command_line	typeref:struct:command_line::buffer	access:public
command_line::residual	manage.h	/^    struct buffer residual;$/;"	m	struct:command_line	typeref:struct:command_line::buffer	access:public
command_line_add	manage.c	/^command_line_add(struct command_line *cl, const unsigned char *buf, const int len)$/;"	f	signature:(struct command_line *cl, const unsigned char *buf, const int len)
command_line_add	manage.h	/^void command_line_add(struct command_line *cl, const unsigned char *buf, const int len);$/;"	p	signature:(struct command_line *cl, const unsigned char *buf, const int len)
command_line_free	manage.c	/^command_line_free(struct command_line *cl)$/;"	f	signature:(struct command_line *cl)
command_line_free	manage.h	/^void command_line_free(struct command_line *cl);$/;"	p	signature:(struct command_line *cl)
command_line_get	manage.c	/^command_line_get(struct command_line *cl)$/;"	f	signature:(struct command_line *cl)
command_line_get	manage.h	/^const char *command_line_get(struct command_line *cl);$/;"	p	signature:(struct command_line *cl)
command_line_new	manage.c	/^command_line_new(const int buf_len)$/;"	f	signature:(const int buf_len)
command_line_new	manage.h	/^struct command_line *command_line_new(const int buf_len);$/;"	p	signature:(const int buf_len)
command_line_next	manage.c	/^command_line_next(struct command_line *cl)$/;"	f	signature:(struct command_line *cl)
command_line_next	manage.h	/^void command_line_next(struct command_line *cl);$/;"	p	signature:(struct command_line *cl)
command_line_reset	manage.c	/^command_line_reset(struct command_line *cl)$/;"	f	signature:(struct command_line *cl)
command_line_reset	manage.h	/^void command_line_reset(struct command_line *cl);$/;"	p	signature:(struct command_line *cl)
common	plugin.h	/^    struct plugin_common *common;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_common	access:public
common_name	pool.h	/^    char *common_name;$/;"	m	struct:ifconfig_pool_entry	access:public
common_name	ssl_common.h	/^    char *common_name;$/;"	m	struct:tls_session	access:public
common_name_hashval	ssl_common.h	/^    uint32_t common_name_hashval;$/;"	m	struct:tls_session	access:public
common_owned	plugin.h	/^    bool common_owned;$/;"	m	struct:plugin_list	access:public
comp	options.h	/^    struct compress_options comp;$/;"	m	struct:options	typeref:struct:options::compress_options	access:public
comp_add_to_extra_buffer	comp.c	/^comp_add_to_extra_buffer(struct frame *frame)$/;"	f	signature:(struct frame *frame)
comp_add_to_extra_buffer	comp.h	/^void comp_add_to_extra_buffer(struct frame *frame);$/;"	p	signature:(struct frame *frame)
comp_add_to_extra_frame	comp.c	/^comp_add_to_extra_frame(struct frame *frame)$/;"	f	signature:(struct frame *frame)
comp_add_to_extra_frame	comp.h	/^void comp_add_to_extra_frame(struct frame *frame);$/;"	p	signature:(struct frame *frame)
comp_context	openvpn.h	/^    struct compress_context *comp_context;$/;"	m	struct:context_2	typeref:struct:context_2::compress_context	access:public
comp_enabled	comp.h	/^comp_enabled(const struct compress_options *info)$/;"	f	signature:(const struct compress_options *info)
comp_generate_peer_info_string	comp.c	/^comp_generate_peer_info_string(const struct compress_options *opt, struct buffer *out)$/;"	f	signature:(const struct compress_options *opt, struct buffer *out)
comp_generate_peer_info_string	comp.h	/^void comp_generate_peer_info_string(const struct compress_options *opt, struct buffer *out);$/;"	p	signature:(const struct compress_options *opt, struct buffer *out)
comp_init	comp.c	/^comp_init(const struct compress_options *opt)$/;"	f	signature:(const struct compress_options *opt)
comp_init	comp.h	/^struct compress_context *comp_init(const struct compress_options *opt);$/;"	p	signature:(const struct compress_options *opt)
comp_options	ssl_common.h	/^    struct compress_options comp_options;$/;"	m	struct:tls_options	typeref:struct:tls_options::compress_options	access:public
comp_print_stats	comp.c	/^comp_print_stats(const struct compress_context *compctx, struct status_output *so)$/;"	f	signature:(const struct compress_context *compctx, struct status_output *so)
comp_print_stats	comp.h	/^void comp_print_stats(const struct compress_context *compctx, struct status_output *so);$/;"	p	signature:(const struct compress_context *compctx, struct status_output *so)
comp_stub_alg	compstub.c	/^const struct compress_alg comp_stub_alg = {$/;"	v	typeref:struct:compress_alg
comp_uninit	comp.c	/^comp_uninit(struct compress_context *compctx)$/;"	f	signature:(struct compress_context *compctx)
comp_uninit	comp.h	/^void comp_uninit(struct compress_context *compctx);$/;"	p	signature:(struct compress_context *compctx)
comp_unswapped_prefix	comp.h	/^comp_unswapped_prefix(const struct compress_options *info)$/;"	f	signature:(const struct compress_options *info)
compare_function	list.h	/^    bool (*compare_function)(const void *key1, const void *key2); \/* return true if equal *\/$/;"	m	struct:hash	access:public
compat_flag	misc.c	/^compat_flag(unsigned int flag)$/;"	f	signature:(unsigned int flag)
compat_flag	misc.h	/^bool compat_flag(unsigned int flag);$/;"	p	signature:(unsigned int flag)
compress	comp.h	/^    void (*compress)(struct buffer *buf, struct buffer work,$/;"	m	struct:compress_alg	access:public
compress_alg	comp.h	/^struct compress_alg$/;"	s
compress_alg::compress	comp.h	/^    void (*compress)(struct buffer *buf, struct buffer work,$/;"	m	struct:compress_alg	access:public
compress_alg::compress_init	comp.h	/^    void (*compress_init)(struct compress_context *compctx);$/;"	m	struct:compress_alg	access:public
compress_alg::compress_uninit	comp.h	/^    void (*compress_uninit)(struct compress_context *compctx);$/;"	m	struct:compress_alg	access:public
compress_alg::decompress	comp.h	/^    void (*decompress)(struct buffer *buf, struct buffer work,$/;"	m	struct:compress_alg	access:public
compress_alg::name	comp.h	/^    const char *name;$/;"	m	struct:compress_alg	access:public
compress_buf	openvpn.h	/^    struct buffer compress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
compress_context	comp.h	/^struct compress_context$/;"	s
compress_context::alg	comp.h	/^    struct compress_alg alg;$/;"	m	struct:compress_context	typeref:struct:compress_context::compress_alg	access:public
compress_context::flags	comp.h	/^    unsigned int flags;$/;"	m	struct:compress_context	access:public
compress_context::post_compress	comp.h	/^    counter_type post_compress;$/;"	m	struct:compress_context	access:public
compress_context::post_decompress	comp.h	/^    counter_type post_decompress;$/;"	m	struct:compress_context	access:public
compress_context::pre_compress	comp.h	/^    counter_type pre_compress;$/;"	m	struct:compress_context	access:public
compress_context::pre_decompress	comp.h	/^    counter_type pre_decompress;$/;"	m	struct:compress_context	access:public
compress_context::wu	comp.h	/^    union compress_workspace_union wu;$/;"	m	struct:compress_context	typeref:union:compress_context::compress_workspace_union	access:public
compress_init	comp.h	/^    void (*compress_init)(struct compress_context *compctx);$/;"	m	struct:compress_alg	access:public
compress_options	comp.h	/^struct compress_options$/;"	s
compress_options::alg	comp.h	/^    int alg;$/;"	m	struct:compress_options	access:public
compress_options::flags	comp.h	/^    unsigned int flags;$/;"	m	struct:compress_options	access:public
compress_state	lzo.h	/^    bool compress_state;$/;"	m	struct:lzo_adaptive_compress	access:public
compress_uninit	comp.h	/^    void (*compress_uninit)(struct compress_context *compctx);$/;"	m	struct:compress_alg	access:public
compress_workspace_union	comp.h	/^union compress_workspace_union$/;"	u
compress_workspace_union::lz4	comp.h	/^    struct lz4_workspace lz4;$/;"	m	union:compress_workspace_union	typeref:struct:compress_workspace_union::lz4_workspace	access:public
compress_workspace_union::lzo	comp.h	/^    struct lzo_compress_workspace lzo;$/;"	m	union:compress_workspace_union	typeref:struct:compress_workspace_union::lzo_compress_workspace	access:public
compute_earliest_wakeup	ssl.c	/^compute_earliest_wakeup(interval_t *earliest, interval_t seconds_from_now)$/;"	f	file:	signature:(interval_t *earliest, interval_t seconds_from_now)
compute_wakeup_sigma	multi.c	/^compute_wakeup_sigma(const struct timeval *delta)$/;"	f	file:	signature:(const struct timeval *delta)
compv2_escape_data_ifneeded	comp.c	/^compv2_escape_data_ifneeded(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
compv2_escape_data_ifneeded	comp.h	/^void compv2_escape_data_ifneeded(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
compv2_stub_alg	compstub.c	/^const struct compress_alg compv2_stub_alg = {$/;"	v	typeref:struct:compress_alg
config	options.h	/^    const char *config;$/;"	m	struct:options	access:public
config_authname	ssl_common.h	/^    const char *config_authname;$/;"	m	struct:tls_options	access:public
config_ciphername	ssl_common.h	/^    const char *config_ciphername;$/;"	m	struct:tls_options	access:public
configure_path	misc.h	/^void configure_path(void);$/;"	p	signature:(void)
connect_retry_max	options.h	/^    int connect_retry_max;$/;"	m	struct:options	access:public
connect_retry_seconds	options.h	/^    int connect_retry_seconds;$/;"	m	struct:connection_entry	access:public
connect_retry_seconds_max	options.h	/^    int connect_retry_seconds_max;$/;"	m	struct:connection_entry	access:public
connect_timeout	options.h	/^    int connect_timeout;$/;"	m	struct:connection_entry	access:public
connection	manage.h	/^    struct man_connection connection;$/;"	m	struct:management	typeref:struct:management::man_connection	access:public
connection_entry	options.h	/^struct connection_entry$/;"	s
connection_entry::af	options.h	/^    sa_family_t af;$/;"	m	struct:connection_entry	access:public
connection_entry::bind_defined	options.h	/^    bool bind_defined;$/;"	m	struct:connection_entry	access:public
connection_entry::bind_ipv6_only	options.h	/^    bool bind_ipv6_only;$/;"	m	struct:connection_entry	access:public
connection_entry::bind_local	options.h	/^    bool bind_local;$/;"	m	struct:connection_entry	access:public
connection_entry::connect_retry_seconds	options.h	/^    int connect_retry_seconds;$/;"	m	struct:connection_entry	access:public
connection_entry::connect_retry_seconds_max	options.h	/^    int connect_retry_seconds_max;$/;"	m	struct:connection_entry	access:public
connection_entry::connect_timeout	options.h	/^    int connect_timeout;$/;"	m	struct:connection_entry	access:public
connection_entry::explicit_exit_notification	options.h	/^    int explicit_exit_notification; \/* Explicitly tell peer when we are exiting via OCC_EXIT or [RESTART] message *\/$/;"	m	struct:connection_entry	access:public
connection_entry::flags	options.h	/^    unsigned int flags;$/;"	m	struct:connection_entry	access:public
connection_entry::fragment	options.h	/^    int fragment;        \/* internal fragmentation size *\/$/;"	m	struct:connection_entry	access:public
connection_entry::http_proxy_options	options.h	/^    struct http_proxy_options *http_proxy_options;$/;"	m	struct:connection_entry	typeref:struct:connection_entry::http_proxy_options	access:public
connection_entry::link_mtu	options.h	/^    int link_mtu;        \/* MTU of device over which tunnel packets pass via TCP\/UDP *\/$/;"	m	struct:connection_entry	access:public
connection_entry::link_mtu_defined	options.h	/^    bool link_mtu_defined; \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry	access:public
connection_entry::local	options.h	/^    const char *local;$/;"	m	struct:connection_entry	access:public
connection_entry::local_port	options.h	/^    const char *local_port;$/;"	m	struct:connection_entry	access:public
connection_entry::local_port_defined	options.h	/^    bool local_port_defined;$/;"	m	struct:connection_entry	access:public
connection_entry::mssfix	options.h	/^    int mssfix;          \/* Upper bound on TCP MSS *\/$/;"	m	struct:connection_entry	access:public
connection_entry::mssfix_default	options.h	/^    bool mssfix_default; \/* true if --mssfix was supplied without a parameter *\/$/;"	m	struct:connection_entry	access:public
connection_entry::mtu_discover_type	options.h	/^    int mtu_discover_type; \/* used if OS supports setting Path MTU discovery options on socket *\/$/;"	m	struct:connection_entry	access:public
connection_entry::proto	options.h	/^    int proto;$/;"	m	struct:connection_entry	access:public
connection_entry::remote	options.h	/^    const char *remote;$/;"	m	struct:connection_entry	access:public
connection_entry::remote_float	options.h	/^    bool remote_float;$/;"	m	struct:connection_entry	access:public
connection_entry::remote_port	options.h	/^    const char *remote_port;$/;"	m	struct:connection_entry	access:public
connection_entry::socks_proxy_authfile	options.h	/^    const char *socks_proxy_authfile;$/;"	m	struct:connection_entry	access:public
connection_entry::socks_proxy_port	options.h	/^    const char *socks_proxy_port;$/;"	m	struct:connection_entry	access:public
connection_entry::socks_proxy_server	options.h	/^    const char *socks_proxy_server;$/;"	m	struct:connection_entry	access:public
connection_entry::tun_mtu	options.h	/^    int tun_mtu;         \/* MTU of tun device *\/$/;"	m	struct:connection_entry	access:public
connection_entry::tun_mtu_defined	options.h	/^    bool tun_mtu_defined; \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry	access:public
connection_entry::tun_mtu_extra	options.h	/^    int tun_mtu_extra;$/;"	m	struct:connection_entry	access:public
connection_entry::tun_mtu_extra_defined	options.h	/^    bool tun_mtu_extra_defined;$/;"	m	struct:connection_entry	access:public
connection_entry_load_re	options.c	/^connection_entry_load_re(struct connection_entry *ce, const struct remote_entry *re)$/;"	f	file:	signature:(struct connection_entry *ce, const struct remote_entry *re)
connection_established	socket.h	/^    bool connection_established;$/;"	m	struct:link_socket_info	access:public
connection_established_flag	multi.h	/^    bool connection_established_flag;$/;"	m	struct:multi_instance	access:public
connection_list	options.h	/^    struct connection_list *connection_list;$/;"	m	struct:options	typeref:struct:options::connection_list	access:public
connection_list	options.h	/^struct connection_list$/;"	s
connection_list::array	options.h	/^    struct connection_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:connection_list	typeref:struct:connection_list::connection_entry	access:public
connection_list::current	options.h	/^    int current;$/;"	m	struct:connection_list	access:public
connection_list::len	options.h	/^    int len;$/;"	m	struct:connection_list	access:public
console_mode_save	win32.h	/^    DWORD console_mode_save;$/;"	m	struct:win32_signal	access:public
console_mode_save_defined	win32.h	/^    bool console_mode_save_defined;$/;"	m	struct:win32_signal	access:public
constrain_int	integer.h	/^constrain_int(int x, int min, int max)$/;"	f	signature:(int x, int min, int max)
construct_name_value	misc.c	/^construct_name_value(const char *name, const char *value, struct gc_arena *gc)$/;"	f	file:	signature:(const char *name, const char *value, struct gc_arena *gc)
content	proxy.h	/^    const char *content;$/;"	m	struct:http_custom_header	access:public
context	multi.h	/^    struct context context;     \/**< The context structure storing state$/;"	m	struct:multi_instance	typeref:struct:multi_instance::context	access:public
context	openvpn.h	/^struct context$/;"	s
context::c0	openvpn.h	/^    struct context_0 *c0;       \/**< Level 0 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_0	access:public
context::c1	openvpn.h	/^    struct context_1 c1;        \/**< Level 1 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_1	access:public
context::c2	openvpn.h	/^    struct context_2 c2;        \/**< Level 2 %context. *\/$/;"	m	struct:context	typeref:struct:context::context_2	access:public
context::did_we_daemonize	openvpn.h	/^    bool did_we_daemonize;      \/**< Whether demonization has already$/;"	m	struct:context	access:public
context::es	openvpn.h	/^    struct env_set *es;         \/**< Set of environment variables. *\/$/;"	m	struct:context	typeref:struct:context::env_set	access:public
context::first_time	openvpn.h	/^    bool first_time;            \/**< True on the first iteration of$/;"	m	struct:context	access:public
context::gc	openvpn.h	/^    struct gc_arena gc;         \/**< Garbage collection arena for$/;"	m	struct:context	typeref:struct:context::gc_arena	access:public
context::mode	openvpn.h	/^    int mode;                   \/**< Role of this context within the$/;"	m	struct:context	access:public
context::options	openvpn.h	/^    struct options options;     \/**< Options loaded from command line or$/;"	m	struct:context	typeref:struct:context::options	access:public
context::persist	openvpn.h	/^    struct context_persist persist;$/;"	m	struct:context	typeref:struct:context::context_persist	access:public
context::plugins	openvpn.h	/^    struct plugin_list *plugins; \/**< List of plug-ins. *\/$/;"	m	struct:context	typeref:struct:context::plugin_list	access:public
context::plugins_owned	openvpn.h	/^    bool plugins_owned;         \/**< Whether the plug-ins should be$/;"	m	struct:context	access:public
context::sig	openvpn.h	/^    struct signal_info *sig;    \/**< Internal error signaling object. *\/$/;"	m	struct:context	typeref:struct:context::signal_info	access:public
context_0	openvpn.h	/^struct context_0$/;"	s
context_0::platform_state_group	openvpn.h	/^    struct platform_state_group platform_state_group;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_group	access:public
context_0::platform_state_user	openvpn.h	/^    struct platform_state_user platform_state_user;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_user	access:public
context_0::uid_gid_chroot_set	openvpn.h	/^    bool uid_gid_chroot_set;$/;"	m	struct:context_0	access:public
context_0::uid_gid_specified	openvpn.h	/^    bool uid_gid_specified;$/;"	m	struct:context_0	access:public
context_1	openvpn.h	/^struct context_1$/;"	s
context_1::auth_user_pass	openvpn.h	/^    struct user_pass *auth_user_pass;$/;"	m	struct:context_1	typeref:struct:context_1::user_pass	access:public
context_1::authname	openvpn.h	/^    const char *authname;       \/**< Data channel auth from config file *\/$/;"	m	struct:context_1	access:public
context_1::ciphername	openvpn.h	/^    const char *ciphername;     \/**< Data channel cipher from config file *\/$/;"	m	struct:context_1	access:public
context_1::dns_cache	openvpn.h	/^    struct cached_dns_entry *dns_cache;$/;"	m	struct:context_1	typeref:struct:context_1::cached_dns_entry	access:public
context_1::http_proxy	openvpn.h	/^    struct http_proxy_info *http_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::http_proxy_info	access:public
context_1::http_proxy_owned	openvpn.h	/^    bool http_proxy_owned;$/;"	m	struct:context_1	access:public
context_1::ifconfig_pool_persist	openvpn.h	/^    struct ifconfig_pool_persist *ifconfig_pool_persist;$/;"	m	struct:context_1	typeref:struct:context_1::ifconfig_pool_persist	access:public
context_1::ifconfig_pool_persist_owned	openvpn.h	/^    bool ifconfig_pool_persist_owned;$/;"	m	struct:context_1	access:public
context_1::keysize	openvpn.h	/^    int keysize;                \/**< Data channel keysize from config file *\/$/;"	m	struct:context_1	access:public
context_1::ks	openvpn.h	/^    struct key_schedule ks;$/;"	m	struct:context_1	typeref:struct:context_1::key_schedule	access:public
context_1::link_socket_addr	openvpn.h	/^    struct link_socket_addr link_socket_addr;$/;"	m	struct:context_1	typeref:struct:context_1::link_socket_addr	access:public
context_1::pid_persist	openvpn.h	/^    struct packet_id_persist pid_persist;$/;"	m	struct:context_1	typeref:struct:context_1::packet_id_persist	access:public
context_1::pulled_options_digest_save	openvpn.h	/^    struct sha256_digest pulled_options_digest_save;$/;"	m	struct:context_1	typeref:struct:context_1::sha256_digest	access:public
context_1::route_ipv6_list	openvpn.h	/^    struct route_ipv6_list *route_ipv6_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_ipv6_list	access:public
context_1::route_list	openvpn.h	/^    struct route_list *route_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_list	access:public
context_1::socks_proxy	openvpn.h	/^    struct socks_proxy_info *socks_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::socks_proxy_info	access:public
context_1::socks_proxy_owned	openvpn.h	/^    bool socks_proxy_owned;$/;"	m	struct:context_1	access:public
context_1::status_output	openvpn.h	/^    struct status_output *status_output;$/;"	m	struct:context_1	typeref:struct:context_1::status_output	access:public
context_1::status_output_owned	openvpn.h	/^    bool status_output_owned;$/;"	m	struct:context_1	access:public
context_1::tuntap	openvpn.h	/^    struct tuntap *tuntap;      \/**< Tun\/tap virtual network interface. *\/$/;"	m	struct:context_1	typeref:struct:context_1::tuntap	access:public
context_1::tuntap_owned	openvpn.h	/^    bool tuntap_owned;          \/**< Whether the tun\/tap interface should$/;"	m	struct:context_1	access:public
context_2	openvpn.h	/^struct context_2$/;"	s
context_2::accept_from	openvpn.h	/^    const struct link_socket *accept_from; \/* possibly do accept() on a parent link_socket *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket	access:public
context_2::buf	openvpn.h	/^    struct buffer buf;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
context_2::buffers	openvpn.h	/^    struct context_buffers *buffers;$/;"	m	struct:context_2	typeref:struct:context_2::context_buffers	access:public
context_2::buffers_owned	openvpn.h	/^    bool buffers_owned; \/* if true, we should free all buffers on close *\/$/;"	m	struct:context_2	access:public
context_2::coarse_timer_wakeup	openvpn.h	/^    time_t coarse_timer_wakeup;$/;"	m	struct:context_2	access:public
context_2::comp_context	openvpn.h	/^    struct compress_context *comp_context;$/;"	m	struct:context_2	typeref:struct:context_2::compress_context	access:public
context_2::context_auth	openvpn.h	/^    int context_auth;$/;"	m	struct:context_2	access:public
context_2::crypto_options	openvpn.h	/^    struct crypto_options crypto_options;$/;"	m	struct:context_2	typeref:struct:context_2::crypto_options	access:public
context_2::did_open_tun	openvpn.h	/^    bool did_open_tun;$/;"	m	struct:context_2	access:public
context_2::did_pre_pull_restore	openvpn.h	/^    bool did_pre_pull_restore;$/;"	m	struct:context_2	access:public
context_2::do_up_ran	openvpn.h	/^    bool do_up_ran;$/;"	m	struct:context_2	access:public
context_2::es	openvpn.h	/^    struct env_set *es;$/;"	m	struct:context_2	typeref:struct:context_2::env_set	access:public
context_2::es_owned	openvpn.h	/^    bool es_owned;$/;"	m	struct:context_2	access:public
context_2::event_set	openvpn.h	/^    struct event_set *event_set;$/;"	m	struct:context_2	typeref:struct:context_2::event_set	access:public
context_2::event_set_max	openvpn.h	/^    int event_set_max;$/;"	m	struct:context_2	access:public
context_2::event_set_owned	openvpn.h	/^    bool event_set_owned;$/;"	m	struct:context_2	access:public
context_2::event_set_status	openvpn.h	/^    unsigned int event_set_status;$/;"	m	struct:context_2	access:public
context_2::explicit_exit_notification_interval	openvpn.h	/^    struct event_timeout explicit_exit_notification_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::explicit_exit_notification_time_wait	openvpn.h	/^    time_t explicit_exit_notification_time_wait;$/;"	m	struct:context_2	access:public
context_2::fast_io	openvpn.h	/^    bool fast_io;$/;"	m	struct:context_2	access:public
context_2::fragment	openvpn.h	/^    struct fragment_master *fragment;$/;"	m	struct:context_2	typeref:struct:context_2::fragment_master	access:public
context_2::frame	openvpn.h	/^    struct frame frame;                         \/* Active frame parameters *\/$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
context_2::frame_fragment	openvpn.h	/^    struct frame frame_fragment;$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
context_2::frame_fragment_omit	openvpn.h	/^    struct frame frame_fragment_omit;$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
context_2::frame_initial	openvpn.h	/^    struct frame frame_initial;                 \/* Restored on new session *\/$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
context_2::from	openvpn.h	/^    struct link_socket_actual from;             \/* address of incoming datagram *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual	access:public
context_2::gc	openvpn.h	/^    struct gc_arena gc;         \/**< Garbage collection arena for$/;"	m	struct:context_2	typeref:struct:context_2::gc_arena	access:public
context_2::inactivity_bytes	openvpn.h	/^    int inactivity_bytes;$/;"	m	struct:context_2	access:public
context_2::inactivity_interval	openvpn.h	/^    struct event_timeout inactivity_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::inotify_fd	openvpn.h	/^    int inotify_fd; \/* descriptor for monitoring file changes *\/$/;"	m	struct:context_2	access:public
context_2::link_read_bytes	openvpn.h	/^    counter_type link_read_bytes;$/;"	m	struct:context_2	access:public
context_2::link_read_bytes_auth	openvpn.h	/^    counter_type link_read_bytes_auth;$/;"	m	struct:context_2	access:public
context_2::link_socket	openvpn.h	/^    struct link_socket *link_socket;     \/* socket used for TCP\/UDP connection to remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket	access:public
context_2::link_socket_info	openvpn.h	/^    struct link_socket_info *link_socket_info;$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_info	access:public
context_2::link_socket_owned	openvpn.h	/^    bool link_socket_owned;$/;"	m	struct:context_2	access:public
context_2::link_write_bytes	openvpn.h	/^    counter_type link_write_bytes;$/;"	m	struct:context_2	access:public
context_2::log_rw	openvpn.h	/^    bool log_rw;$/;"	m	struct:context_2	access:public
context_2::max_recv_size_local	openvpn.h	/^    int max_recv_size_local;    \/* max packet size received *\/$/;"	m	struct:context_2	access:public
context_2::max_recv_size_remote	openvpn.h	/^    int max_recv_size_remote;   \/* max packet size received by remote *\/$/;"	m	struct:context_2	access:public
context_2::max_send_size_local	openvpn.h	/^    int max_send_size_local;    \/* max packet size sent *\/$/;"	m	struct:context_2	access:public
context_2::max_send_size_remote	openvpn.h	/^    int max_send_size_remote;   \/* max packet size sent by remote *\/$/;"	m	struct:context_2	access:public
context_2::mda_context	openvpn.h	/^    struct man_def_auth_context mda_context;$/;"	m	struct:context_2	typeref:struct:context_2::man_def_auth_context	access:public
context_2::n_sent_push_requests	openvpn.h	/^    int n_sent_push_requests;$/;"	m	struct:context_2	access:public
context_2::n_trunc_post_decrypt	openvpn.h	/^    counter_type n_trunc_post_decrypt;$/;"	m	struct:context_2	access:public
context_2::n_trunc_pre_encrypt	openvpn.h	/^    counter_type n_trunc_pre_encrypt;$/;"	m	struct:context_2	access:public
context_2::n_trunc_tun_read	openvpn.h	/^    counter_type n_trunc_tun_read;$/;"	m	struct:context_2	access:public
context_2::n_trunc_tun_write	openvpn.h	/^    counter_type n_trunc_tun_write;$/;"	m	struct:context_2	access:public
context_2::occ_interval	openvpn.h	/^    struct event_timeout occ_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::occ_mtu_load_n_tries	openvpn.h	/^    int occ_mtu_load_n_tries;$/;"	m	struct:context_2	access:public
context_2::occ_mtu_load_size	openvpn.h	/^    int occ_mtu_load_size;$/;"	m	struct:context_2	access:public
context_2::occ_mtu_load_test_interval	openvpn.h	/^    struct event_timeout occ_mtu_load_test_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::occ_n_tries	openvpn.h	/^    int occ_n_tries;$/;"	m	struct:context_2	access:public
context_2::occ_op	openvpn.h	/^    int occ_op;                 \/* INIT to -1 *\/$/;"	m	struct:context_2	access:public
context_2::options_string_local	openvpn.h	/^    char *options_string_local;$/;"	m	struct:context_2	access:public
context_2::options_string_remote	openvpn.h	/^    char *options_string_remote;$/;"	m	struct:context_2	access:public
context_2::original_recv_size	openvpn.h	/^    int original_recv_size;     \/* temporary *\/$/;"	m	struct:context_2	access:public
context_2::packet_id_persist_interval	openvpn.h	/^    struct event_timeout packet_id_persist_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::pf	openvpn.h	/^    struct pf_context pf;$/;"	m	struct:context_2	typeref:struct:context_2::pf_context	access:public
context_2::ping_rec_interval	openvpn.h	/^    struct event_timeout ping_rec_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::ping_send_interval	openvpn.h	/^    struct event_timeout ping_send_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::pulled_options_digest	openvpn.h	/^    struct sha256_digest pulled_options_digest;$/;"	m	struct:context_2	typeref:struct:context_2::sha256_digest	access:public
context_2::pulled_options_digest_init_done	openvpn.h	/^    bool pulled_options_digest_init_done;$/;"	m	struct:context_2	access:public
context_2::pulled_options_state	openvpn.h	/^    md_ctx_t *pulled_options_state;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_defined	openvpn.h	/^    bool push_ifconfig_defined;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_ipv6_defined	openvpn.h	/^    bool push_ifconfig_ipv6_defined;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_ipv6_local	openvpn.h	/^    struct in6_addr push_ifconfig_ipv6_local;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr	access:public
context_2::push_ifconfig_ipv6_netbits	openvpn.h	/^    int push_ifconfig_ipv6_netbits;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_ipv6_remote	openvpn.h	/^    struct in6_addr push_ifconfig_ipv6_remote;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr	access:public
context_2::push_ifconfig_local	openvpn.h	/^    in_addr_t push_ifconfig_local;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_local_alias	openvpn.h	/^    in_addr_t push_ifconfig_local_alias;$/;"	m	struct:context_2	access:public
context_2::push_ifconfig_remote_netmask	openvpn.h	/^    in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:context_2	access:public
context_2::push_reply_deferred	openvpn.h	/^    bool push_reply_deferred;$/;"	m	struct:context_2	access:public
context_2::push_request_interval	openvpn.h	/^    struct event_timeout push_request_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::push_request_received	openvpn.h	/^    bool push_request_received;$/;"	m	struct:context_2	access:public
context_2::route_wakeup	openvpn.h	/^    struct event_timeout route_wakeup;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::route_wakeup_expire	openvpn.h	/^    struct event_timeout route_wakeup_expire;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::scheduled_exit	openvpn.h	/^    struct event_timeout scheduled_exit;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::scheduled_exit_signal	openvpn.h	/^    int scheduled_exit_signal;$/;"	m	struct:context_2	access:public
context_2::sent_push_reply_expiry	openvpn.h	/^    time_t sent_push_reply_expiry;$/;"	m	struct:context_2	access:public
context_2::server_poll_interval	openvpn.h	/^    struct event_timeout server_poll_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_2::shaper	openvpn.h	/^    struct shaper shaper;$/;"	m	struct:context_2	typeref:struct:context_2::shaper	access:public
context_2::timeout_random_component	openvpn.h	/^    struct timeval timeout_random_component;$/;"	m	struct:context_2	typeref:struct:context_2::timeval	access:public
context_2::timeval	openvpn.h	/^    struct timeval timeval;$/;"	m	struct:context_2	typeref:struct:context_2::timeval	access:public
context_2::tls_auth_standalone	openvpn.h	/^    struct tls_auth_standalone *tls_auth_standalone;$/;"	m	struct:context_2	typeref:struct:context_2::tls_auth_standalone	access:public
context_2::tls_exit_signal	openvpn.h	/^    int tls_exit_signal;$/;"	m	struct:context_2	access:public
context_2::tls_multi	openvpn.h	/^    struct tls_multi *tls_multi; \/**< TLS state structure for this VPN$/;"	m	struct:context_2	typeref:struct:context_2::tls_multi	access:public
context_2::tmp_int	openvpn.h	/^    struct interval tmp_int;$/;"	m	struct:context_2	typeref:struct:context_2::interval	access:public
context_2::to_link	openvpn.h	/^    struct buffer to_link;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
context_2::to_link_addr	openvpn.h	/^    struct link_socket_actual *to_link_addr;    \/* IP address of remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual	access:public
context_2::to_tun	openvpn.h	/^    struct buffer to_tun;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
context_2::tun_read_bytes	openvpn.h	/^    counter_type tun_read_bytes;$/;"	m	struct:context_2	access:public
context_2::tun_write_bytes	openvpn.h	/^    counter_type tun_write_bytes;$/;"	m	struct:context_2	access:public
context_2::update_timeout_random_component	openvpn.h	/^    time_t update_timeout_random_component;$/;"	m	struct:context_2	access:public
context_2::wait_for_connect	openvpn.h	/^    struct event_timeout wait_for_connect;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
context_auth	openvpn.h	/^    int context_auth;$/;"	m	struct:context_2	access:public
context_buffers	multi.h	/^    struct context_buffers *context_buffers;$/;"	m	struct:multi_context	typeref:struct:multi_context::context_buffers	access:public
context_buffers	openvpn.h	/^struct context_buffers$/;"	s
context_buffers::aux_buf	openvpn.h	/^    struct buffer aux_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::compress_buf	openvpn.h	/^    struct buffer compress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::decompress_buf	openvpn.h	/^    struct buffer decompress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::decrypt_buf	openvpn.h	/^    struct buffer decrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::encrypt_buf	openvpn.h	/^    struct buffer encrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::read_link_buf	openvpn.h	/^    struct buffer read_link_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_buffers::read_tun_buf	openvpn.h	/^    struct buffer read_tun_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
context_clear	init.c	/^context_clear(struct context *c)$/;"	f	signature:(struct context *c)
context_clear	init.h	/^void context_clear(struct context *c);$/;"	p	signature:(struct context *c)
context_clear_1	init.c	/^context_clear_1(struct context *c)$/;"	f	signature:(struct context *c)
context_clear_1	init.h	/^void context_clear_1(struct context *c);$/;"	p	signature:(struct context *c)
context_clear_2	init.c	/^context_clear_2(struct context *c)$/;"	f	signature:(struct context *c)
context_clear_2	init.h	/^void context_clear_2(struct context *c);$/;"	p	signature:(struct context *c)
context_clear_all_except_first_time	init.c	/^context_clear_all_except_first_time(struct context *c)$/;"	f	signature:(struct context *c)
context_clear_all_except_first_time	init.h	/^void context_clear_all_except_first_time(struct context *c);$/;"	p	signature:(struct context *c)
context_gc_free	init.c	/^context_gc_free(struct context *c)$/;"	f	signature:(struct context *c)
context_gc_free	init.h	/^void context_gc_free(struct context *c);$/;"	p	signature:(struct context *c)
context_immediate_reschedule	forward-inline.h	/^context_immediate_reschedule(struct context *c)$/;"	f	signature:(struct context *c)
context_init_1	init.c	/^context_init_1(struct context *c)$/;"	f	signature:(struct context *c)
context_init_1	init.h	/^void context_init_1(struct context *c);$/;"	p	signature:(struct context *c)
context_persist	openvpn.h	/^struct context_persist$/;"	s
context_persist::restart_sleep_seconds	openvpn.h	/^    int restart_sleep_seconds;$/;"	m	struct:context_persist	access:public
context_reschedule_sec	forward-inline.h	/^context_reschedule_sec(struct context *c, int sec)$/;"	f	signature:(struct context *c, int sec)
control_message_from_parent	ps.c	/^control_message_from_parent(const socket_descriptor_t sd_control,$/;"	f	file:	signature:(const socket_descriptor_t sd_control, struct proxy_connection **list, struct event_set *es, const struct sockaddr_in server_addr, const int max_initial_buf, const char *journal_dir)
convert_tls13_list_to_openssl	ssl_openssl.c	/^convert_tls13_list_to_openssl(char *openssl_ciphers, size_t len,$/;"	f	signature:(char *openssl_ciphers, size_t len, const char *ciphers)
convert_to_one_line	buffer.c	/^convert_to_one_line(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
convert_to_one_line	buffer.h	/^void convert_to_one_line(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
copy_client_nat_option_list	clinat.c	/^copy_client_nat_option_list(struct client_nat_option_list *dest,$/;"	f	signature:(struct client_nat_option_list *dest, const struct client_nat_option_list *src)
copy_client_nat_option_list	clinat.h	/^void copy_client_nat_option_list(struct client_nat_option_list *dest, const struct client_nat_option_list *src);$/;"	p	signature:(struct client_nat_option_list *dest, const struct client_nat_option_list *src)
copy_route_ipv6_option_list	route.c	/^copy_route_ipv6_option_list(struct route_ipv6_option_list *dest,$/;"	f	signature:(struct route_ipv6_option_list *dest, const struct route_ipv6_option_list *src, struct gc_arena *a)
copy_route_ipv6_option_list	route.h	/^void copy_route_ipv6_option_list(struct route_ipv6_option_list *dest,$/;"	p	signature:(struct route_ipv6_option_list *dest, const struct route_ipv6_option_list *src, struct gc_arena *a)
copy_route_option_list	route.c	/^copy_route_option_list(struct route_option_list *dest, const struct route_option_list *src, struct gc_arena *a)$/;"	f	signature:(struct route_option_list *dest, const struct route_option_list *src, struct gc_arena *a)
copy_route_option_list	route.h	/^void copy_route_option_list(struct route_option_list *dest, const struct route_option_list *src, struct gc_arena *a);$/;"	p	signature:(struct route_option_list *dest, const struct route_option_list *src, struct gc_arena *a)
corrupt_freq	gremlin.c	/^static const int corrupt_freq[] = { 500, 100, 50 };$/;"	v	file:
corrupt_gremlin	gremlin.c	/^corrupt_gremlin(struct buffer *buf, int flags)$/;"	f	signature:(struct buffer *buf, int flags)
corrupt_gremlin	gremlin.h	/^void corrupt_gremlin(struct buffer *buf, int flags);$/;"	p	signature:(struct buffer *buf, int flags)
count	perf.c	/^    double count;$/;"	m	struct:perf	file:	access:public
counter_format	common.h	33;"	d
counter_format	common.h	35;"	d
counter_format	common.h	39;"	d
counter_type	common.h	/^typedef unsigned int counter_type;$/;"	t
counter_type	common.h	/^typedef unsigned long long int counter_type;$/;"	t
counterpart	ps.c	/^    struct proxy_connection *counterpart;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:	access:public
crash	error.c	/^crash(void)$/;"	f	signature:(void)
crash	error.h	/^void crash(void);  \/* force a segfault (debugging only) *\/$/;"	p	signature:(void)
create_arbitrary_remote	tun.c	/^create_arbitrary_remote( struct tuntap *tt )$/;"	f	signature:( struct tuntap *tt )
create_des_keys	ntlm.c	/^create_des_keys(const unsigned char *hash, unsigned char *key)$/;"	f	file:	signature:(const unsigned char *hash, unsigned char *key)
create_socket	socket.c	/^create_socket(struct link_socket *sock, struct addrinfo *addr)$/;"	f	file:	signature:(struct link_socket *sock, struct addrinfo *addr)
create_socket_tcp	socket.c	/^create_socket_tcp(struct addrinfo *addrinfo)$/;"	f	signature:(struct addrinfo *addrinfo)
create_socket_tcp	socket.h	/^socket_descriptor_t create_socket_tcp(struct addrinfo *);$/;"	p	signature:(struct addrinfo *)
create_socket_udp	socket.c	/^create_socket_udp(struct addrinfo *addrinfo, const unsigned int flags)$/;"	f	file:	signature:(struct addrinfo *addrinfo, const unsigned int flags)
create_socket_unix	socket.c	/^create_socket_unix(void)$/;"	f	signature:(void)
create_socket_unix	socket.h	/^socket_descriptor_t create_socket_unix(void);$/;"	p	signature:(void)
create_temp_file	misc.c	/^create_temp_file(const char *directory, const char *prefix, struct gc_arena *gc)$/;"	f	signature:(const char *directory, const char *prefix, struct gc_arena *gc)
create_temp_file	misc.h	/^const char *create_temp_file(const char *directory, const char *prefix, struct gc_arena *gc);$/;"	p	signature:(const char *directory, const char *prefix, struct gc_arena *gc)
created	multi.h	/^    time_t created;             \/**< Time at which a VPN tunnel instance$/;"	m	struct:multi_instance	access:public
crl	ssl_mbedtls.h	/^    mbedtls_x509_crl *crl;              \/**< Certificate Revocation List *\/$/;"	m	struct:tls_root_ctx	access:public
crl_file	options.h	/^    const char *crl_file;$/;"	m	struct:options	access:public
crl_file	ssl_common.h	/^    const char *crl_file;$/;"	m	struct:tls_options	access:public
crl_file_inline	options.h	/^    const char *crl_file_inline;$/;"	m	struct:options	access:public
crl_file_inline	ssl_common.h	/^    const char *crl_file_inline;$/;"	m	struct:tls_options	access:public
crl_last_mtime	ssl_mbedtls.h	/^    time_t crl_last_mtime;              \/**< CRL last modification time *\/$/;"	m	struct:tls_root_ctx	access:public
crl_last_mtime	ssl_openssl.h	/^    time_t crl_last_mtime;$/;"	m	struct:tls_root_ctx	access:public
crl_last_size	ssl_mbedtls.h	/^    off_t crl_last_size;                \/**< size of last loaded CRL *\/$/;"	m	struct:tls_root_ctx	access:public
crl_last_size	ssl_openssl.h	/^    off_t crl_last_size;$/;"	m	struct:tls_root_ctx	access:public
crt_chain	ssl_mbedtls.h	/^    mbedtls_x509_crt *crt_chain;        \/**< Local Certificate chain *\/$/;"	m	struct:tls_root_ctx	access:public
crypt_prov	cryptoapi.c	/^    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE crypt_prov;$/;"	m	struct:_CAPI_DATA	file:	access:public
crypto_adjust_frame_parameters	crypto.c	/^crypto_adjust_frame_parameters(struct frame *frame,$/;"	f	signature:(struct frame *frame, const struct key_type *kt, bool use_iv, bool packet_id, bool packet_id_long_form)
crypto_adjust_frame_parameters	crypto.h	/^void crypto_adjust_frame_parameters(struct frame *frame,$/;"	p	signature:(struct frame *frame, const struct key_type *kt, bool use_iv, bool packet_id, bool packet_id_long_form)
crypto_check_replay	crypto.c	/^crypto_check_replay(struct crypto_options *opt,$/;"	f	signature:(struct crypto_options *opt, const struct packet_id_net *pin, const char *error_prefix, struct gc_arena *gc)
crypto_check_replay	crypto.h	/^bool crypto_check_replay(struct crypto_options *opt,$/;"	p	signature:(struct crypto_options *opt, const struct packet_id_net *pin, const char *error_prefix, struct gc_arena *gc)
crypto_clear_error	crypto_backend.h	/^void crypto_clear_error(void);$/;"	p	signature:(void)
crypto_clear_error	crypto_mbedtls.c	/^crypto_clear_error(void)$/;"	f	signature:(void)
crypto_clear_error	crypto_openssl.c	/^crypto_clear_error(void)$/;"	f	signature:(void)
crypto_flags	ssl_common.h	/^    unsigned int crypto_flags;$/;"	m	struct:tls_options	access:public
crypto_free	crypto_openssl.c	/^crypto_free(void *ptr)$/;"	f	file:	signature:(void *ptr)
crypto_init_dmalloc	crypto_backend.h	/^void crypto_init_dmalloc(void);$/;"	p	signature:(void)
crypto_init_dmalloc	crypto_mbedtls.c	/^crypto_init_dmalloc(void)$/;"	f	signature:(void)
crypto_init_dmalloc	crypto_openssl.c	/^crypto_init_dmalloc(void)$/;"	f	signature:(void)
crypto_init_lib	crypto_backend.h	/^void crypto_init_lib(void);$/;"	p	signature:(void)
crypto_init_lib	crypto_mbedtls.c	/^crypto_init_lib(void)$/;"	f	signature:(void)
crypto_init_lib	crypto_openssl.c	/^crypto_init_lib(void)$/;"	f	signature:(void)
crypto_init_lib_engine	crypto_backend.h	/^void crypto_init_lib_engine(const char *engine_name);$/;"	p	signature:(const char *engine_name)
crypto_init_lib_engine	crypto_mbedtls.c	/^crypto_init_lib_engine(const char *engine_name)$/;"	f	signature:(const char *engine_name)
crypto_init_lib_engine	crypto_openssl.c	/^crypto_init_lib_engine(const char *engine_name)$/;"	f	signature:(const char *engine_name)
crypto_malloc	crypto_openssl.c	/^crypto_malloc(size_t size, const char *file, int line)$/;"	f	file:	signature:(size_t size, const char *file, int line)
crypto_max_overhead	crypto.c	/^crypto_max_overhead(void)$/;"	f	signature:(void)
crypto_max_overhead	crypto.h	/^unsigned int crypto_max_overhead(void);$/;"	p	signature:(void)
crypto_msg	crypto_openssl.h	98;"	d
crypto_options	crypto.h	/^struct crypto_options$/;"	s
crypto_options	openvpn.h	/^    struct crypto_options crypto_options;$/;"	m	struct:context_2	typeref:struct:context_2::crypto_options	access:public
crypto_options	ssl_common.h	/^    struct crypto_options crypto_options;\/* data channel crypto options *\/$/;"	m	struct:key_state	typeref:struct:key_state::crypto_options	access:public
crypto_options::flags	crypto.h	/^    unsigned int flags;         \/**< Bit-flags determining behavior of$/;"	m	struct:crypto_options	access:public
crypto_options::key_ctx_bi	crypto.h	/^    struct key_ctx_bi key_ctx_bi;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::key_ctx_bi	access:public
crypto_options::packet_id	crypto.h	/^    struct packet_id packet_id; \/**< Current packet ID state for both$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id	access:public
crypto_options::pid_persist	crypto.h	/^    struct packet_id_persist *pid_persist;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id_persist	access:public
crypto_print_openssl_errors	crypto_openssl.c	/^crypto_print_openssl_errors(const unsigned int flags)$/;"	f	signature:(const unsigned int flags)
crypto_print_openssl_errors	crypto_openssl.h	/^void crypto_print_openssl_errors(const unsigned int flags);$/;"	p	signature:(const unsigned int flags)
crypto_read_openvpn_key	crypto.c	/^crypto_read_openvpn_key(const struct key_type *key_type,$/;"	f	signature:(const struct key_type *key_type, struct key_ctx_bi *ctx, const char *key_file, const char *key_inline, const int key_direction, const char *key_name, const char *opt_name)
crypto_read_openvpn_key	crypto.h	/^void crypto_read_openvpn_key(const struct key_type *key_type,$/;"	p	signature:(const struct key_type *key_type, struct key_ctx_bi *ctx, const char *key_file, const char *key_inline, const int key_direction, const char *key_name, const char *opt_name)
crypto_realloc	crypto_openssl.c	/^crypto_realloc(void *ptr, size_t size, const char *file, int line)$/;"	f	file:	signature:(void *ptr, size_t size, const char *file, int line)
crypto_uninit_lib	crypto_backend.h	/^void crypto_uninit_lib(void);$/;"	p	signature:(void)
crypto_uninit_lib	crypto_mbedtls.c	/^crypto_uninit_lib(void)$/;"	f	signature:(void)
crypto_uninit_lib	crypto_openssl.c	/^crypto_uninit_lib(void)$/;"	f	signature:(void)
cryptoapi_cert	options.h	/^    const char *cryptoapi_cert;$/;"	m	struct:options	access:public
ct_in	ssl_openssl.h	/^    BIO *ct_in;                 \/* write ciphertext to here *\/$/;"	m	struct:key_state_ssl	access:public
ct_out	ssl_openssl.h	/^    BIO *ct_out;                        \/* read ciphertext from here *\/$/;"	m	struct:key_state_ssl	access:public
ctl	event.h	/^    void (*ctl)(struct event_set *es, event_t event, unsigned int rwflags, void *arg);$/;"	m	struct:event_set_functions	access:public
ctrl_sd	socket.h	/^    socket_descriptor_t ctrl_sd; \/* only used for UDP over Socks *\/$/;"	m	struct:link_socket	access:public
ctx	ssl_mbedtls.h	/^    mbedtls_ssl_context *ctx;           \/**< mbedTLS connection context *\/$/;"	m	struct:key_state_ssl	access:public
ctx	ssl_openssl.h	/^    SSL_CTX *ctx;$/;"	m	struct:tls_root_ctx	access:public
current	options.h	/^    int current;$/;"	m	struct:connection_list	access:public
current_remote	socket.h	/^    struct addrinfo *current_remote; \/* remote used in the$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
custom_headers	proxy.h	/^    struct http_custom_header custom_headers[MAX_CUSTOM_HTTP_HEADER];$/;"	m	struct:http_proxy_options	typeref:struct:http_proxy_options::http_custom_header	access:public
daddr	proto.h	/^    struct  in6_addr daddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr	access:public
daddr	proto.h	/^    uint32_t daddr;$/;"	m	struct:openvpn_iphdr	access:public
daemon	options.h	/^    bool daemon;$/;"	m	struct:options	access:public
data	buffer.h	/^    uint8_t *data;              \/**< Pointer to the allocated memory. *\/$/;"	m	struct:buffer	access:public
data	ssl_mbedtls.h	/^    uint8_t *data;$/;"	m	struct:_buffer_entry	access:public
data_start	ssl_mbedtls.h	/^    size_t data_start;$/;"	m	struct:__anon11	access:public
datagram_overhead	socket.h	/^datagram_overhead(int proto)$/;"	f	signature:(int proto)
debug_file	buffer.h	/^    const char *debug_file;$/;"	m	struct:buffer	access:public
debug_line	buffer.h	/^    int debug_line;$/;"	m	struct:buffer	access:public
decompress	comp.h	/^    void (*decompress)(struct buffer *buf, struct buffer work,$/;"	m	struct:compress_alg	access:public
decompress_buf	openvpn.h	/^    struct buffer decompress_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
decrypt	crypto.h	/^    struct key_ctx decrypt;     \/**< cipher and\/or HMAC contexts for$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx	access:public
decrypt_buf	openvpn.h	/^    struct buffer decrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
default_allow	pf.h	/^    bool default_allow;$/;"	m	struct:pf_cn_set	access:public
default_allow	pf.h	/^    bool default_allow;$/;"	m	struct:pf_subnet_set	access:public
default_err	error.c	/^static FILE *default_err; \/* GLOBAL *\/$/;"	v	file:
default_metric	route.h	/^    int default_metric;$/;"	m	struct:route_ipv6_list	access:public
default_metric	route.h	/^    int default_metric;$/;"	m	struct:route_special_addr	access:public
default_msg_handler	block_dns.c	/^default_msg_handler(DWORD err, const char *msg)$/;"	f	file:	signature:(DWORD err, const char *msg)
default_out	error.c	/^static FILE *default_out; \/* GLOBAL *\/$/;"	v	file:
deferred_shutdown_signal	multi.h	/^    struct deferred_signal_schedule_entry deferred_shutdown_signal;$/;"	m	struct:multi_context	typeref:struct:multi_context::deferred_signal_schedule_entry	access:public
deferred_signal_schedule_entry	multi.h	/^struct deferred_signal_schedule_entry$/;"	s
deferred_signal_schedule_entry::se	multi.h	/^    struct schedule_entry se;$/;"	m	struct:deferred_signal_schedule_entry	typeref:struct:deferred_signal_schedule_entry::schedule_entry	access:public
deferred_signal_schedule_entry::signal_received	multi.h	/^    int signal_received;$/;"	m	struct:deferred_signal_schedule_entry	access:public
deferred_signal_schedule_entry::wakeup	multi.h	/^    struct timeval wakeup;$/;"	m	struct:deferred_signal_schedule_entry	typeref:struct:deferred_signal_schedule_entry::timeval	access:public
defined	fragment.h	/^    bool defined;               \/**< Whether reassembly is currently$/;"	m	struct:fragment	access:public
defined	interval.h	/^    bool defined;$/;"	m	struct:event_timeout	access:public
defined	manage.h	/^    bool defined;$/;"	m	struct:man_persist	access:public
defined	manage.h	/^    bool defined;$/;"	m	struct:man_settings	access:public
defined	misc.h	/^    bool defined;$/;"	m	struct:user_pass	access:public
defined	multi.h	/^    bool defined;$/;"	m	struct:multi_instance	access:public
defined	proxy.h	/^    bool defined;$/;"	m	struct:http_proxy_info	access:public
defined	ps.c	/^    bool defined;$/;"	m	struct:proxy_connection	file:	access:public
defined	socks.h	/^    bool defined;$/;"	m	struct:socks_proxy_info	access:public
defined_net_event_win32	win32.h	/^defined_net_event_win32(const struct rw_handle *event)$/;"	f	signature:(const struct rw_handle *event)
del	event.h	/^    void (*del)(struct event_set *es, event_t event);$/;"	m	struct:event_set_functions	access:public
del_bypass_routes	route.c	/^del_bypass_routes(struct route_bypass *rb,$/;"	f	file:	signature:(struct route_bypass *rb, in_addr_t gateway, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
del_route3	route.c	/^del_route3(in_addr_t network,$/;"	f	file:	signature:(in_addr_t network, in_addr_t netmask, in_addr_t gateway, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
del_route_ipapi	route.c	/^del_route_ipapi(const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	signature:(const struct route_ipv4 *r, const struct tuntap *tt)
del_route_ipapi	route.h	/^bool del_route_ipapi(const struct route_ipv4 *r, const struct tuntap *tt);$/;"	p	signature:(const struct route_ipv4 *r, const struct tuntap *tt)
del_route_ipv6_service	route.c	/^del_route_ipv6_service(const struct route_ipv6 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const struct route_ipv6 *r, const struct tuntap *tt)
del_route_ipv6_service	route.c	/^static bool del_route_ipv6_service(const struct route_ipv6 *, const struct tuntap *);$/;"	p	file:	signature:(const struct route_ipv6 *, const struct tuntap *)
del_route_service	route.c	/^del_route_service(const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const struct route_ipv4 *r, const struct tuntap *tt)
del_route_service	route.c	/^static bool del_route_service(const struct route_ipv4 *, const struct tuntap *);$/;"	p	file:	signature:(const struct route_ipv4 *, const struct tuntap *)
delayed_auth_pass_purge	ssl.c	/^delayed_auth_pass_purge(void)$/;"	f	signature:(void)
delayed_auth_pass_purge	ssl.h	/^void delayed_auth_pass_purge(void);$/;"	p	signature:(void)
delete_block_dns_filters	block_dns.c	/^delete_block_dns_filters(HANDLE engine_handle)$/;"	f	signature:(HANDLE engine_handle)
delete_block_dns_filters	block_dns.h	/^delete_block_dns_filters(HANDLE engine);$/;"	p	signature:(HANDLE engine)
delete_event	manage.h	/^    void (*delete_event) (void *arg, event_t event);$/;"	m	struct:management_callback	access:public
delete_route	route.c	/^delete_route(struct route_ipv4 *r,$/;"	f	file:	signature:(struct route_ipv4 *r, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
delete_route	route.c	/^static void delete_route(struct route_ipv4 *r, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es);$/;"	p	file:	signature:(struct route_ipv4 *r, const struct tuntap *tt, unsigned int flags, const struct route_gateway_info *rgi, const struct env_set *es)
delete_route_connected_v6_net	tun.c	/^delete_route_connected_v6_net(struct tuntap *tt,$/;"	f	signature:(struct tuntap *tt, const struct env_set *es)
delete_route_ipv6	route.c	/^delete_route_ipv6(const struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	signature:(const struct route_ipv6 *r6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
delete_route_ipv6	route.h	/^void delete_route_ipv6(const struct route_ipv6 *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es);$/;"	p	signature:(const struct route_ipv6 *r, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
delete_routes	route.c	/^delete_routes(struct route_list *rl, struct route_ipv6_list *rl6,$/;"	f	signature:(struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
delete_routes	route.h	/^void delete_routes(struct route_list *rl,$/;"	p	signature:(struct route_list *rl, struct route_ipv6_list *rl6, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
delete_temp_addresses	tun.c	/^delete_temp_addresses(DWORD index)$/;"	f	file:	signature:(DWORD index)
delta	occ.h	/^    int delta;                  \/* determine packet size to send by using$/;"	m	struct:mtu_load_test	access:public
dest	proto.h	/^    uint16_t dest;         \/* destination port *\/$/;"	m	struct:openvpn_tcphdr	access:public
dest	proto.h	/^    uint16_t dest;$/;"	m	struct:openvpn_udphdr	access:public
dest	proto.h	/^    uint8_t dest[OPENVPN_ETH_ALEN];   \/* destination ethernet addr *\/$/;"	m	struct:openvpn_ethhdr	access:public
dest	socket.h	/^    struct openvpn_sockaddr dest;$/;"	m	struct:link_socket_actual	typeref:struct:link_socket_actual::openvpn_sockaddr	access:public
dev	options.h	/^    const char *dev;$/;"	m	struct:options	access:public
dev_node	options.h	/^    const char *dev_node;$/;"	m	struct:options	access:public
dev_type	options.h	/^    const char *dev_type;$/;"	m	struct:options	access:public
dev_type_enum	tun.c	/^dev_type_enum(const char *dev, const char *dev_type)$/;"	f	signature:(const char *dev, const char *dev_type)
dev_type_enum	tun.h	/^int dev_type_enum(const char *dev, const char *dev_type);$/;"	p	signature:(const char *dev, const char *dev_type)
dev_type_string	tun.c	/^dev_type_string(const char *dev, const char *dev_type)$/;"	f	signature:(const char *dev, const char *dev_type)
dev_type_string	tun.h	/^const char *dev_type_string(const char *dev, const char *dev_type);$/;"	p	signature:(const char *dev, const char *dev_type)
dh_file	options.h	/^    const char *dh_file;$/;"	m	struct:options	access:public
dh_file_inline	options.h	/^    const char *dh_file_inline;$/;"	m	struct:options	access:public
dhcp	dhcp.h	/^    struct dhcp dhcp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::dhcp	access:public
dhcp	dhcp.h	/^struct dhcp {$/;"	s
dhcp::chaddr	dhcp.h	/^    uint8_t chaddr[16]; \/* client hardware address *\/$/;"	m	struct:dhcp	access:public
dhcp::ciaddr	dhcp.h	/^    uint32_t ciaddr;   \/* client IP address, client sets if known *\/$/;"	m	struct:dhcp	access:public
dhcp::file	dhcp.h	/^    uint8_t file[128]; \/* boot file name *\/$/;"	m	struct:dhcp	access:public
dhcp::flags	dhcp.h	/^    uint16_t flags;$/;"	m	struct:dhcp	access:public
dhcp::giaddr	dhcp.h	/^    uint32_t giaddr;   \/* relay agent IP address *\/$/;"	m	struct:dhcp	access:public
dhcp::hlen	dhcp.h	/^    uint8_t hlen;      \/* hardware address length (e.g. '6' for 10Mb Ethernet) *\/$/;"	m	struct:dhcp	access:public
dhcp::hops	dhcp.h	/^    uint8_t hops;      \/* client sets to 0, may be used by relay agents *\/$/;"	m	struct:dhcp	access:public
dhcp::htype	dhcp.h	/^    uint8_t htype;     \/* hardware address type (e.g. '1' = 10Mb Ethernet) *\/$/;"	m	struct:dhcp	access:public
dhcp::magic	dhcp.h	/^    uint32_t magic;    \/* must be 0x63825363 (network order) *\/$/;"	m	struct:dhcp	access:public
dhcp::op	dhcp.h	/^    uint8_t op;        \/* message op *\/$/;"	m	struct:dhcp	access:public
dhcp::secs	dhcp.h	/^    uint16_t secs;     \/* seconds since request process began, set by client *\/$/;"	m	struct:dhcp	access:public
dhcp::siaddr	dhcp.h	/^    uint32_t siaddr;   \/* server IP address *\/$/;"	m	struct:dhcp	access:public
dhcp::sname	dhcp.h	/^    uint8_t sname[64]; \/* optional server host name *\/$/;"	m	struct:dhcp	access:public
dhcp::xid	dhcp.h	/^    uint32_t xid;      \/* transaction ID, chosen by client *\/$/;"	m	struct:dhcp	access:public
dhcp::yiaddr	dhcp.h	/^    uint32_t yiaddr;   \/* 'your' IP address -- server's response to client *\/$/;"	m	struct:dhcp	access:public
dhcp_extract_router_msg	dhcp.c	/^dhcp_extract_router_msg(struct buffer *ipbuf)$/;"	f	signature:(struct buffer *ipbuf)
dhcp_extract_router_msg	dhcp.h	/^in_addr_t dhcp_extract_router_msg(struct buffer *ipbuf);$/;"	p	signature:(struct buffer *ipbuf)
dhcp_full	dhcp.h	/^struct dhcp_full {$/;"	s
dhcp_full::dhcp	dhcp.h	/^    struct dhcp dhcp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::dhcp	access:public
dhcp_full::ip	dhcp.h	/^    struct openvpn_iphdr ip;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_iphdr	access:public
dhcp_full::options	dhcp.h	/^    uint8_t options[DHCP_OPTIONS_BUFFER_SIZE];$/;"	m	struct:dhcp_full	access:public
dhcp_full::udp	dhcp.h	/^    struct openvpn_udphdr udp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_udphdr	access:public
dhcp_lease_time	tun.h	/^    int dhcp_lease_time;$/;"	m	struct:tuntap_options	access:public
dhcp_masq_addr	tun.c	/^dhcp_masq_addr(const in_addr_t local, const in_addr_t netmask, const int offset)$/;"	f	file:	signature:(const in_addr_t local, const in_addr_t netmask, const int offset)
dhcp_masq_custom_offset	tun.h	/^    bool dhcp_masq_custom_offset;$/;"	m	struct:tuntap_options	access:public
dhcp_masq_offset	tun.h	/^    int dhcp_masq_offset;$/;"	m	struct:tuntap_options	access:public
dhcp_option_address_parse	options.c	/^dhcp_option_address_parse(const char *name, const char *parm, in_addr_t *array, int *len, int msglevel)$/;"	f	file:	signature:(const char *name, const char *parm, in_addr_t *array, int *len, int msglevel)
dhcp_option_dns6_parse	options.c	/^dhcp_option_dns6_parse(const char *parm, struct in6_addr *dns6_list, int *len, int msglevel)$/;"	f	file:	signature:(const char *parm, struct in6_addr *dns6_list, int *len, int msglevel)
dhcp_options	tun.h	/^    bool dhcp_options;$/;"	m	struct:tuntap_options	access:public
dhcp_pre_release	tun.h	/^    bool dhcp_pre_release;$/;"	m	struct:tuntap_options	access:public
dhcp_release	tun.c	/^dhcp_release(const struct tuntap *tt)$/;"	f	file:	signature:(const struct tuntap *tt)
dhcp_release_by_adapter_index	tun.c	/^dhcp_release_by_adapter_index(const DWORD adapter_index)$/;"	f	signature:(const DWORD adapter_index)
dhcp_release_by_adapter_index	tun.h	/^bool dhcp_release_by_adapter_index(const DWORD adapter_index);$/;"	p	signature:(const DWORD adapter_index)
dhcp_renew	tun.c	/^dhcp_renew(const struct tuntap *tt)$/;"	f	file:	signature:(const struct tuntap *tt)
dhcp_renew	tun.h	/^    bool dhcp_renew;$/;"	m	struct:tuntap_options	access:public
dhcp_renew_by_adapter_index	tun.c	/^dhcp_renew_by_adapter_index(const DWORD adapter_index)$/;"	f	signature:(const DWORD adapter_index)
dhcp_renew_by_adapter_index	tun.h	/^bool dhcp_renew_by_adapter_index(const DWORD adapter_index);$/;"	p	signature:(const DWORD adapter_index)
dhcp_status	tun.c	/^dhcp_status(DWORD index)$/;"	f	file:	signature:(DWORD index)
dhm_ctx	ssl_mbedtls.h	/^    mbedtls_dhm_context *dhm_ctx;       \/**< Diffie-Helmann-Merkle context *\/$/;"	m	struct:tls_root_ctx	access:public
did_cid_hash	multi.h	/^    bool did_cid_hash;$/;"	m	struct:multi_instance	access:public
did_ifconfig	tun.h	/^    bool did_ifconfig;$/;"	m	struct:tuntap	access:public
did_ifconfig_ipv6_setup	tun.h	/^    bool did_ifconfig_ipv6_setup;$/;"	m	struct:tuntap	access:public
did_ifconfig_setup	tun.h	/^    bool did_ifconfig_setup;$/;"	m	struct:tuntap	access:public
did_iroutes	multi.h	/^    bool did_iroutes;$/;"	m	struct:multi_instance	access:public
did_iter	multi.h	/^    bool did_iter;$/;"	m	struct:multi_instance	access:public
did_open_context	multi.h	/^    bool did_open_context;$/;"	m	struct:multi_instance	access:public
did_open_tun	openvpn.h	/^    bool did_open_tun;$/;"	m	struct:context_2	access:public
did_pre_pull_restore	openvpn.h	/^    bool did_pre_pull_restore;$/;"	m	struct:context_2	access:public
did_real_hash	multi.h	/^    bool did_real_hash;$/;"	m	struct:multi_instance	access:public
did_we_daemonize	openvpn.h	/^    bool did_we_daemonize;      \/**< Whether demonization has already$/;"	m	struct:context	access:public
digest	crypto.h	/^    const md_kt_t *digest;      \/**< Message digest static parameters *\/$/;"	m	struct:key_type	access:public
digest	crypto.h	/^    uint8_t digest[SHA256_DIGEST_LENGTH];$/;"	m	struct:sha256_digest	access:public
disable	options.h	/^    bool disable;$/;"	m	struct:options	access:public
disable_nbt	tun.h	/^    bool disable_nbt;$/;"	m	struct:tuntap_options	access:public
disable_occ	ssl_common.h	/^    bool disable_occ;$/;"	m	struct:tls_options	access:public
display_form	socket.c	/^    const char *display_form;$/;"	m	struct:proto_names	file:	access:public
dll_resolve_symbol	plugin.c	/^dll_resolve_symbol(HMODULE module, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)$/;"	f	file:	signature:(HMODULE module, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)
dmsg	error.h	153;"	d
dmsg	error.h	155;"	d
dmsg	error.h	161;"	d
dmsg	error.h	163;"	d
dmsg	error.h	174;"	d
dns	tun.h	/^    in_addr_t dns[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
dns6	tun.h	/^    struct in6_addr dns6[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	typeref:struct:tuntap_options::in6_addr	access:public
dns6_len	tun.h	/^    int dns6_len;$/;"	m	struct:tuntap_options	access:public
dns_addr_safe	socket.c	/^dns_addr_safe(const char *addr)$/;"	f	file:	signature:(const char *addr)
dns_cache	openvpn.h	/^    struct cached_dns_entry *dns_cache;$/;"	m	struct:context_1	typeref:struct:context_1::cached_dns_entry	access:public
dns_cache	socket.h	/^    struct cached_dns_entry *dns_cache;$/;"	m	struct:link_socket	typeref:struct:link_socket::cached_dns_entry	access:public
dns_len	tun.h	/^    int dns_len;$/;"	m	struct:tuntap_options	access:public
do_address_service	tun.c	/^do_address_service(const bool add, const short family, const struct tuntap *tt)$/;"	f	file:	signature:(const bool add, const short family, const struct tuntap *tt)
do_alloc_route_list	init.c	/^do_alloc_route_list(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_check_if_restart_permitted	init.c	/^do_close_check_if_restart_permitted(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_event_set	init.c	/^do_close_event_set(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_fragment	init.c	/^do_close_fragment(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_free_buf	init.c	/^do_close_free_buf(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_free_key_schedule	init.c	/^do_close_free_key_schedule(struct context *c, bool free_ssl_ctx)$/;"	f	file:	signature:(struct context *c, bool free_ssl_ctx)
do_close_ifconfig_pool_persist	init.c	/^do_close_ifconfig_pool_persist(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_link_socket	init.c	/^do_close_link_socket(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_packet_id	init.c	/^do_close_packet_id(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_plugins	init.c	/^do_close_plugins(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_status_output	init.c	/^do_close_status_output(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_tls	init.c	/^do_close_tls(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_close_tun	init.c	/^do_close_tun(struct context *c, bool force)$/;"	f	file:	signature:(struct context *c, bool force)
do_close_tun_simple	init.c	/^do_close_tun_simple(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_compute_occ_strings	init.c	/^do_compute_occ_strings(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_deferred_options	init.c	/^do_deferred_options(struct context *c, const unsigned int found)$/;"	f	signature:(struct context *c, const unsigned int found)
do_deferred_options	init.h	/^bool do_deferred_options(struct context *c, const unsigned int found);$/;"	p	signature:(struct context *c, const unsigned int found)
do_dns6_service	tun.c	/^do_dns6_service(bool add, const struct tuntap *tt)$/;"	f	file:	signature:(bool add, const struct tuntap *tt)
do_env_set_destroy	init.c	/^do_env_set_destroy(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_event_set_init	init.c	/^do_event_set_init(struct context *c,$/;"	f	file:	signature:(struct context *c, bool need_us_timeout)
do_extract	dhcp.c	/^do_extract(struct dhcp *dhcp, int optlen)$/;"	f	file:	signature:(struct dhcp *dhcp, int optlen)
do_genkey	init.c	/^do_genkey(const struct options *options)$/;"	f	signature:(const struct options *options)
do_genkey	init.h	/^bool do_genkey(const struct options *options);$/;"	p	signature:(const struct options *options)
do_hold	init.c	/^do_hold(int holdtime)$/;"	f	file:	signature:(int holdtime)
do_ifconfig	tun.c	/^do_ifconfig(struct tuntap *tt,$/;"	f	signature:(struct tuntap *tt, const char *actual, int tun_mtu, const struct env_set *es)
do_ifconfig	tun.h	/^void do_ifconfig(struct tuntap *tt,$/;"	p	signature:(struct tuntap *tt, const char *actual, int tun_mtu, const struct env_set *es)
do_ifconfig_setenv	tun.c	/^do_ifconfig_setenv(const struct tuntap *tt, struct env_set *es)$/;"	f	signature:(const struct tuntap *tt, struct env_set *es)
do_ifconfig_setenv	tun.h	/^void do_ifconfig_setenv(const struct tuntap *tt,$/;"	p	signature:(const struct tuntap *tt, struct env_set *es)
do_inherit_env	init.c	/^do_inherit_env(struct context *c, const struct env_set *src)$/;"	f	file:	signature:(struct context *c, const struct env_set *src)
do_inherit_plugins	init.c	/^do_inherit_plugins(struct context *c, const struct context *src)$/;"	f	file:	signature:(struct context *c, const struct context *src)
do_init_buffers	init.c	/^do_init_buffers(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_crypto	init.c	/^do_init_crypto(struct context *c, const unsigned int flags)$/;"	f	file:	signature:(struct context *c, const unsigned int flags)
do_init_crypto_none	init.c	/^do_init_crypto_none(const struct context *c)$/;"	f	file:	signature:(const struct context *c)
do_init_crypto_static	init.c	/^do_init_crypto_static(struct context *c, const unsigned int flags)$/;"	f	file:	signature:(struct context *c, const unsigned int flags)
do_init_crypto_tls	init.c	/^do_init_crypto_tls(struct context *c, const unsigned int flags)$/;"	f	file:	signature:(struct context *c, const unsigned int flags)
do_init_crypto_tls_c1	init.c	/^do_init_crypto_tls_c1(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_finalize_tls_frame	init.c	/^do_init_finalize_tls_frame(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_first_time	init.c	/^do_init_first_time(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_first_time	init.c	/^static void do_init_first_time(struct context *c);$/;"	p	file:	signature:(struct context *c)
do_init_fragment	init.c	/^do_init_fragment(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_frame	init.c	/^do_init_frame(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_frame_tls	init.c	/^do_init_frame_tls(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_route_ipv6_list	init.c	/^do_init_route_ipv6_list(const struct options *options,$/;"	f	file:	signature:(const struct options *options, struct route_ipv6_list *route_ipv6_list, const struct link_socket_info *link_socket_info, struct env_set *es)
do_init_route_list	init.c	/^do_init_route_list(const struct options *options,$/;"	f	file:	signature:(const struct options *options, struct route_list *route_list, const struct link_socket_info *link_socket_info, struct env_set *es)
do_init_server_poll_timeout	init.c	/^do_init_server_poll_timeout(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_socket_1	init.c	/^do_init_socket_1(struct context *c, const int mode)$/;"	f	file:	signature:(struct context *c, const int mode)
do_init_socket_2	init.c	/^do_init_socket_2(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_timers	init.c	/^do_init_timers(struct context *c, bool deferred)$/;"	f	file:	signature:(struct context *c, bool deferred)
do_init_traffic_shaper	init.c	/^do_init_traffic_shaper(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_init_tun	init.c	/^do_init_tun(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_link_socket_new	init.c	/^do_link_socket_new(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_lz4_compress	comp-lz4.c	/^do_lz4_compress(struct buffer *buf,$/;"	f	file:	signature:(struct buffer *buf, struct buffer *work, struct compress_context *compctx, const struct frame *frame)
do_lz4_decompress	comp-lz4.c	/^do_lz4_decompress(size_t zlen_max,$/;"	f	file:	signature:(size_t zlen_max, struct buffer *work, struct buffer *buf, struct compress_context *compctx)
do_open_ifconfig_pool_persist	init.c	/^do_open_ifconfig_pool_persist(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_open_status_output	init.c	/^do_open_status_output(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_open_tun	init.c	/^do_open_tun(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_option_warnings	init.c	/^do_option_warnings(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_persist_tuntap	init.c	/^do_persist_tuntap(const struct options *options)$/;"	f	signature:(const struct options *options)
do_persist_tuntap	init.h	/^bool do_persist_tuntap(const struct options *options);$/;"	p	signature:(const struct options *options)
do_preresolve	socket.c	/^do_preresolve(struct context *c)$/;"	f	signature:(struct context *c)
do_preresolve	socket.h	/^void do_preresolve(struct context *c);$/;"	p	signature:(struct context *c)
do_preresolve_host	socket.c	/^do_preresolve_host(struct context *c,$/;"	f	file:	signature:(struct context *c, const char *hostname, const char *servname, const int af, const int flags)
do_print_data_channel_mtu_parms	init.c	/^do_print_data_channel_mtu_parms(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_route	init.c	/^do_route(const struct options *options,$/;"	f	signature:(const struct options *options, struct route_list *route_list, struct route_ipv6_list *route_ipv6_list, const struct tuntap *tt, const struct plugin_list *plugins, struct env_set *es)
do_route	init.h	/^void do_route(const struct options *options,$/;"	p	signature:(const struct options *options, struct route_list *route_list, struct route_ipv6_list *route_ipv6_list, const struct tuntap *tt, const struct plugin_list *plugins, struct env_set *es)
do_route_ipv4_service	route.c	/^do_route_ipv4_service(const bool add, const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const bool add, const struct route_ipv4 *r, const struct tuntap *tt)
do_route_ipv6_service	route.c	/^do_route_ipv6_service(const bool add, const struct route_ipv6 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const bool add, const struct route_ipv6 *r, const struct tuntap *tt)
do_route_service	route.c	/^do_route_service(const bool add, const route_message_t *rt, const size_t size, HANDLE pipe)$/;"	f	file:	signature:(const bool add, const route_message_t *rt, const size_t size, HANDLE pipe)
do_setenv_name	ssl_verify_mbedtls.c	/^do_setenv_name(struct env_set *es, const struct x509_track *xt,$/;"	f	file:	signature:(struct env_set *es, const struct x509_track *xt, const mbedtls_x509_crt *cert, int depth, struct gc_arena *gc)
do_setenv_x509	ssl_verify_mbedtls.c	/^do_setenv_x509(struct env_set *es, const char *name, char *value, int depth)$/;"	f	file:	signature:(struct env_set *es, const char *name, char *value, int depth)
do_setenv_x509	ssl_verify_openssl.c	/^do_setenv_x509(struct env_set *es, const char *name, char *value, int depth)$/;"	f	file:	signature:(struct env_set *es, const char *name, char *value, int depth)
do_setup_fast_io	init.c	/^do_setup_fast_io(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_signal_on_tls_errors	init.c	/^do_signal_on_tls_errors(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_startup_pause	init.c	/^do_startup_pause(struct context *c)$/;"	f	file:	signature:(struct context *c)
do_test_crypto	init.c	/^do_test_crypto(const struct options *o)$/;"	f	signature:(const struct options *o)
do_test_crypto	init.h	/^bool do_test_crypto(const struct options *o);$/;"	p	signature:(const struct options *o)
do_uid_gid_chroot	init.c	/^do_uid_gid_chroot(struct context *c, bool no_delay)$/;"	f	file:	signature:(struct context *c, bool no_delay)
do_up	init.c	/^do_up(struct context *c, bool pulled_options, unsigned int option_types_found)$/;"	f	signature:(struct context *c, bool pulled_options, unsigned int option_types_found)
do_up	init.h	/^bool do_up(struct context *c,$/;"	p	signature:(struct context *c, bool pulled_options, unsigned int option_types_found)
do_up_ran	openvpn.h	/^    bool do_up_ran;$/;"	m	struct:context_2	access:public
doff_res	proto.h	/^    uint8_t doff_res;$/;"	m	struct:openvpn_tcphdr	access:public
domain	tun.h	/^    const char *domain;      \/* DOMAIN (15) *\/$/;"	m	struct:tuntap_options	access:public
dont_mute	error.c	/^dont_mute(unsigned int flags)$/;"	f	signature:(unsigned int flags)
dont_mute	error.h	/^bool dont_mute(unsigned int flags);$/;"	p	signature:(unsigned int flags)
down_high	gremlin.c	/^static const int down_high[] = { 10, 60, 120 };$/;"	v	file:
down_low	gremlin.c	/^static const int down_low[] =  {  5, 10,  10 };$/;"	v	file:
down_pre	options.h	/^    bool down_pre;$/;"	m	struct:options	access:public
down_script	options.h	/^    const char *down_script;$/;"	m	struct:options	access:public
dragonfly_modify_read_write_return	tun.c	/^dragonfly_modify_read_write_return(int len)$/;"	f	file:	signature:(int len)
drop_accept	pf.c	/^drop_accept(const bool accept)$/;"	f	file:	signature:(const bool accept)
drop_freq	gremlin.c	/^static const int drop_freq[] = { 500, 100, 50 };$/;"	v	file:
drop_if_recursive_routing	forward.c	/^drop_if_recursive_routing(struct context *c, struct buffer *buf)$/;"	f	file:	signature:(struct context *c, struct buffer *buf)
dummy	comp-lz4.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	comp-lz4.h	/^    int dummy;$/;"	m	struct:lz4_workspace	access:public
dummy	compstub.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	cryptoapi.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	fragment.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	gremlin.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	list.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	lzo.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	mbuf.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	mroute.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	multi.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	ntlm.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	occ.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	openvpn.h	/^    int dummy;$/;"	m	struct:packet_id_persist	access:public
dummy	perf.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	pkcs11.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	plugin.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	plugin.h	/^struct plugin_list { int dummy; };$/;"	m	struct:plugin_list	access:public
dummy	plugin.h	/^struct plugin_return { int dummy; };$/;"	m	struct:plugin_return	access:public
dummy	reliable.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	session_id.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	shaper.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	ssl.c	/^dummy(void)$/;"	f	file:	signature:(void)
dummy	tun.h	/^    int dummy; \/* not used *\/$/;"	m	struct:tuntap_options	access:public
duplicate_cn	options.h	/^    bool duplicate_cn;$/;"	m	struct:options	access:public
duplicate_cn	pool.h	/^    bool duplicate_cn;$/;"	m	struct:ifconfig_pool	access:public
earliest_wakeup	multi.h	/^    struct multi_instance *earliest_wakeup;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
earliest_wakeup	schedule.h	/^    struct schedule_entry *earliest_wakeup; \/* cached earliest wakeup *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry	access:public
ecdh_curve	options.h	/^    const char *ecdh_curve;$/;"	m	struct:options	access:public
echo	console.h	/^    bool echo;                \/**< True: The user should see what is being typed, otherwise mask it *\/$/;"	m	struct:_query_user	access:public
echo	manage.h	/^    struct log_history *echo; \/* saved --echo strings *\/$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
echo_buffer_size	manage.h	/^    int echo_buffer_size;$/;"	m	struct:man_settings	access:public
echo_realtime	manage.h	/^    bool echo_realtime;$/;"	m	struct:man_connection	access:public
ekm_label	ssl_common.h	/^    const char *ekm_label;$/;"	m	struct:tls_options	access:public
ekm_label_size	ssl_common.h	/^    size_t ekm_label_size;$/;"	m	struct:tls_options	access:public
ekm_size	ssl_common.h	/^    size_t ekm_size;$/;"	m	struct:tls_options	access:public
elem	list.h	/^    struct hash_element *elem;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element	access:public
enable	pushlist.h	/^    bool enable;$/;"	m	struct:push_entry	access:public
enable_c2c	multi.h	/^    bool enable_c2c;$/;"	m	struct:multi_context	access:public
enable_c2c	options.h	/^    bool enable_c2c;$/;"	m	struct:options	access:public
enabled	pf.h	/^    bool enabled;$/;"	m	struct:pf_context	access:public
encrypt	crypto.h	/^    struct key_ctx encrypt;     \/**< Cipher and\/or HMAC contexts for sending$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx	access:public
encrypt_buf	openvpn.h	/^    struct buffer encrypt_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
encrypt_sign	forward.c	/^encrypt_sign(struct context *c, bool comp_frag)$/;"	f	signature:(struct context *c, bool comp_frag)
encrypt_sign	forward.h	/^void encrypt_sign(struct context *c, bool comp_frag);$/;"	p	signature:(struct context *c, bool comp_frag)
end	interval.h	/^    struct timeval end;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval	access:public
endless_buf_read	ssl_mbedtls.c	/^endless_buf_read( endless_buffer *in, unsigned char *out, size_t out_len )$/;"	f	file:	signature:( endless_buffer *in, unsigned char *out, size_t out_len )
endless_buf_write	ssl_mbedtls.c	/^endless_buf_write( endless_buffer *out, const unsigned char *in, size_t len )$/;"	f	file:	signature:( endless_buffer *out, const unsigned char *in, size_t len )
endless_buffer	ssl_mbedtls.h	/^} endless_buffer;$/;"	t	typeref:struct:__anon11
endpoint	ssl_mbedtls.h	/^    int endpoint;               \/**< Whether or not this is a server or a client *\/$/;"	m	struct:tls_root_ctx	access:public
engine	options.h	/^    const char *engine;$/;"	m	struct:options	access:public
engine_initialized	crypto_openssl.c	/^static bool engine_initialized = false; \/* GLOBAL *\/$/;"	v	file:
engine_persist	crypto_openssl.c	/^static ENGINE *engine_persist = NULL;   \/* GLOBAL *\/$/;"	v	file:
entries	clinat.h	/^    struct client_nat_entry entries[MAX_CLIENT_NAT];$/;"	m	struct:client_nat_option_list	typeref:struct:client_nat_option_list::client_nat_entry	access:public
env_allowed	misc.c	/^env_allowed(const char *str)$/;"	f	signature:(const char *str)
env_allowed	misc.h	/^bool env_allowed(const char *str);$/;"	p	signature:(const char *str)
env_block	win32.c	/^env_block(const struct env_set *es)$/;"	f	file:	signature:(const struct env_set *es)
env_filter_level	manage.h	/^    int env_filter_level;$/;"	m	struct:man_connection	access:public
env_filter_match	manage.c	/^env_filter_match(const char *env_str, const int env_filter_level)$/;"	f	file:	signature:(const char *env_str, const int env_filter_level)
env_item	misc.h	/^struct env_item {$/;"	s
env_item::next	misc.h	/^    struct env_item *next;$/;"	m	struct:env_item	typeref:struct:env_item::env_item	access:public
env_item::string	misc.h	/^    char *string;$/;"	m	struct:env_item	access:public
env_safe_to_print	misc.c	/^env_safe_to_print(const char *str)$/;"	f	signature:(const char *str)
env_safe_to_print	misc.h	/^bool env_safe_to_print(const char *str);$/;"	p	signature:(const char *str)
env_set	misc.h	/^struct env_set {$/;"	s
env_set::gc	misc.h	/^    struct gc_arena *gc;$/;"	m	struct:env_set	typeref:struct:env_set::gc_arena	access:public
env_set::list	misc.h	/^    struct env_item *list;$/;"	m	struct:env_set	typeref:struct:env_set::env_item	access:public
env_set_add	misc.c	/^env_set_add(struct env_set *es, const char *str)$/;"	f	signature:(struct env_set *es, const char *str)
env_set_add	misc.h	/^void env_set_add(struct env_set *es, const char *str);$/;"	p	signature:(struct env_set *es, const char *str)
env_set_add_nolock	misc.c	/^env_set_add_nolock(struct env_set *es, const char *str)$/;"	f	file:	signature:(struct env_set *es, const char *str)
env_set_create	misc.c	/^env_set_create(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
env_set_create	misc.h	/^struct env_set *env_set_create(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
env_set_del	misc.c	/^env_set_del(struct env_set *es, const char *str)$/;"	f	signature:(struct env_set *es, const char *str)
env_set_del	misc.h	/^bool env_set_del(struct env_set *es, const char *str);$/;"	p	signature:(struct env_set *es, const char *str)
env_set_del_nolock	misc.c	/^env_set_del_nolock(struct env_set *es, const char *str)$/;"	f	file:	signature:(struct env_set *es, const char *str)
env_set_destroy	misc.c	/^env_set_destroy(struct env_set *es)$/;"	f	signature:(struct env_set *es)
env_set_destroy	misc.h	/^void env_set_destroy(struct env_set *es);$/;"	p	signature:(struct env_set *es)
env_set_get	misc.c	/^env_set_get(const struct env_set *es, const char *name)$/;"	f	signature:(const struct env_set *es, const char *name)
env_set_get	misc.h	/^const char *env_set_get(const struct env_set *es, const char *name);$/;"	p	signature:(const struct env_set *es, const char *name)
env_set_inherit	misc.c	/^env_set_inherit(struct env_set *es, const struct env_set *src)$/;"	f	signature:(struct env_set *es, const struct env_set *src)
env_set_inherit	misc.h	/^void env_set_inherit(struct env_set *es, const struct env_set *src);$/;"	p	signature:(struct env_set *es, const struct env_set *src)
env_set_print	misc.c	/^env_set_print(int msglevel, const struct env_set *es)$/;"	f	signature:(int msglevel, const struct env_set *es)
env_set_print	misc.h	/^void env_set_print(int msglevel, const struct env_set *es);$/;"	p	signature:(int msglevel, const struct env_set *es)
env_string_equal	misc.c	/^env_string_equal(const char *s1, const char *s2)$/;"	f	file:	signature:(const char *s1, const char *s2)
ep_ctl	event.c	/^ep_ctl(struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct event_set *es, event_t event, unsigned int rwflags, void *arg)
ep_del	event.c	/^ep_del(struct event_set *es, event_t event)$/;"	f	file:	signature:(struct event_set *es, event_t event)
ep_free	event.c	/^ep_free(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
ep_init	event.c	/^ep_init(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
ep_reset	event.c	/^ep_reset(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
ep_set	event.c	/^struct ep_set$/;"	s	file:
ep_set::epfd	event.c	/^    int epfd;$/;"	m	struct:ep_set	file:	access:public
ep_set::events	event.c	/^    struct epoll_event *events;$/;"	m	struct:ep_set	typeref:struct:ep_set::epoll_event	file:	access:public
ep_set::fast	event.c	/^    bool fast;$/;"	m	struct:ep_set	file:	access:public
ep_set::func	event.c	/^    struct event_set_functions func;$/;"	m	struct:ep_set	typeref:struct:ep_set::event_set_functions	file:	access:public
ep_set::maxevents	event.c	/^    int maxevents;$/;"	m	struct:ep_set	file:	access:public
ep_wait	event.c	/^ep_wait(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
epfd	event.c	/^    int epfd;$/;"	m	struct:ep_set	file:	access:public
err_put_ms_error	cryptoapi.c	/^err_put_ms_error(DWORD ms_err, int func, const char *file, int line)$/;"	f	file:	signature:(DWORD ms_err, int func, const char *file, int line)
error	socket.h	/^    bool error; \/* if true, fatal TCP error has occurred,$/;"	m	struct:stream_buf	access:public
error_reset	error.c	/^error_reset(void)$/;"	f	signature:(void)
error_reset	error.h	/^void error_reset(void);$/;"	p	signature:(void)
errors	status.h	/^    bool errors;$/;"	m	struct:status_output	access:public
errors_to_stderr	error.c	/^errors_to_stderr(void)$/;"	f	signature:(void)
errors_to_stderr	error.h	/^void errors_to_stderr(void);$/;"	p	signature:(void)
es	manage.h	/^    struct event_set *es;$/;"	m	struct:man_connection	typeref:struct:man_connection::event_set	access:public
es	mtcp.h	/^    struct event_set *es;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set	access:public
es	openvpn.h	/^    struct env_set *es;         \/**< Set of environment variables. *\/$/;"	m	struct:context	typeref:struct:context::env_set	access:public
es	openvpn.h	/^    struct env_set *es;$/;"	m	struct:context_2	typeref:struct:context_2::env_set	access:public
es	ssl_common.h	/^    struct env_set *es;$/;"	m	struct:tls_options	typeref:struct:tls_options::env_set	access:public
es_owned	openvpn.h	/^    bool es_owned;$/;"	m	struct:context_2	access:public
esr	event.c	/^    struct event_set_return *esr;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_return	file:	access:public
esr	mtcp.h	/^    struct event_set_return *esr;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set_return	access:public
establish_http_proxy_passthru	proxy.c	/^establish_http_proxy_passthru(struct http_proxy_info *p,$/;"	f	signature:(struct http_proxy_info *p, socket_descriptor_t sd, const char *host, const char *port, struct event_timeout *server_poll_timeout, struct buffer *lookahead, volatile int *signal_received)
establish_http_proxy_passthru	proxy.h	/^bool establish_http_proxy_passthru(struct http_proxy_info *p,$/;"	p	signature:(struct http_proxy_info *p, socket_descriptor_t sd, const char *host, const char *port, struct event_timeout *server_poll_timeout, struct buffer *lookahead, volatile int *signal_received)
establish_socks_proxy_passthru	socks.c	/^establish_socks_proxy_passthru(struct socks_proxy_info *p,$/;"	f	signature:(struct socks_proxy_info *p, socket_descriptor_t sd, const char *host, const char *servname, volatile int *signal_received)
establish_socks_proxy_passthru	socks.h	/^void establish_socks_proxy_passthru(struct socks_proxy_info *p,$/;"	p	signature:(struct socks_proxy_info *p, socket_descriptor_t sd, const char *host, const char *servname, volatile int *signal_received)
establish_socks_proxy_udpassoc	socks.c	/^establish_socks_proxy_udpassoc(struct socks_proxy_info *p,$/;"	f	signature:(struct socks_proxy_info *p, socket_descriptor_t ctrl_sd, socket_descriptor_t udp_sd, struct openvpn_sockaddr *relay_addr, volatile int *signal_received)
establish_socks_proxy_udpassoc	socks.h	/^void establish_socks_proxy_udpassoc(struct socks_proxy_info *p,$/;"	p	signature:(struct socks_proxy_info *p, socket_descriptor_t ctrl_sd, socket_descriptor_t udp_sd, struct openvpn_sockaddr *relay_addr, volatile int *signal_received)
established	ssl_common.h	/^    time_t established;         \/* when our state went S_ACTIVE *\/$/;"	m	struct:key_state	access:public
et	status.h	/^    struct event_timeout et;$/;"	m	struct:status_output	typeref:struct:status_output::event_timeout	access:public
eth_addr	mroute.h	/^        uint8_t eth_addr[OPENVPN_ETH_ALEN];$/;"	m	union:mroute_addr::__anon4	access:public
eth_addr	mroute.h	103;"	d
event_ctl	event.h	/^event_ctl(struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	signature:(struct event_set *es, event_t event, unsigned int rwflags, void *arg)
event_del	event.h	/^event_del(struct event_set *es, event_t event)$/;"	f	signature:(struct event_set *es, event_t event)
event_free	event.h	/^event_free(struct event_set *es)$/;"	f	signature:(struct event_set *es)
event_mask	win32.h	/^    long event_mask;$/;"	m	struct:net_event_win32	access:public
event_reset	event.h	/^event_reset(struct event_set *es)$/;"	f	signature:(struct event_set *es)
event_set	event.h	/^struct event_set$/;"	s
event_set	openvpn.h	/^    struct event_set *event_set;$/;"	m	struct:context_2	typeref:struct:context_2::event_set	access:public
event_set::func	event.h	/^    struct event_set_functions func;$/;"	m	struct:event_set	typeref:struct:event_set::event_set_functions	access:public
event_set_functions	event.h	/^struct event_set_functions$/;"	s
event_set_functions::ctl	event.h	/^    void (*ctl)(struct event_set *es, event_t event, unsigned int rwflags, void *arg);$/;"	m	struct:event_set_functions	access:public
event_set_functions::del	event.h	/^    void (*del)(struct event_set *es, event_t event);$/;"	m	struct:event_set_functions	access:public
event_set_functions::free	event.h	/^    void (*free)(struct event_set *es);$/;"	m	struct:event_set_functions	access:public
event_set_functions::reset	event.h	/^    void (*reset)(struct event_set *es);$/;"	m	struct:event_set_functions	access:public
event_set_functions::wait	event.h	/^    int (*wait)(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen);$/;"	m	struct:event_set_functions	access:public
event_set_init	event.c	/^event_set_init(int *maxevents, unsigned int flags)$/;"	f	signature:(int *maxevents, unsigned int flags)
event_set_init	event.h	/^struct event_set *event_set_init(int *maxevents, unsigned int flags);$/;"	p	signature:(int *maxevents, unsigned int flags)
event_set_init_scalable	event.c	/^event_set_init_scalable(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
event_set_init_simple	event.c	/^event_set_init_simple(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
event_set_max	openvpn.h	/^    int event_set_max;$/;"	m	struct:context_2	access:public
event_set_owned	openvpn.h	/^    bool event_set_owned;$/;"	m	struct:context_2	access:public
event_set_return	event.h	/^struct event_set_return$/;"	s
event_set_return::arg	event.h	/^    void *arg;$/;"	m	struct:event_set_return	access:public
event_set_return::rwflags	event.h	/^    unsigned int rwflags;$/;"	m	struct:event_set_return	access:public
event_set_return_init	event.h	/^event_set_return_init(struct event_set_return *esr)$/;"	f	signature:(struct event_set_return *esr)
event_set_status	openvpn.h	/^    unsigned int event_set_status;$/;"	m	struct:context_2	access:public
event_t	event.h	/^typedef const struct rw_handle *event_t;$/;"	t	typeref:struct:rw_handle
event_t	event.h	/^typedef int event_t;$/;"	t
event_timeout	interval.h	/^struct event_timeout$/;"	s
event_timeout::defined	interval.h	/^    bool defined;$/;"	m	struct:event_timeout	access:public
event_timeout::last	interval.h	/^    time_t last; \/* time of last event *\/$/;"	m	struct:event_timeout	access:public
event_timeout::n	interval.h	/^    interval_t n;$/;"	m	struct:event_timeout	access:public
event_timeout_clear	interval.h	/^event_timeout_clear(struct event_timeout *et)$/;"	f	signature:(struct event_timeout *et)
event_timeout_clear_ret	interval.h	/^event_timeout_clear_ret(void)$/;"	f	signature:(void)
event_timeout_defined	interval.h	/^event_timeout_defined(const struct event_timeout *et)$/;"	f	signature:(const struct event_timeout *et)
event_timeout_init	interval.h	/^event_timeout_init(struct event_timeout *et, interval_t n, const time_t local_now)$/;"	f	signature:(struct event_timeout *et, interval_t n, const time_t local_now)
event_timeout_modify_wakeup	interval.h	/^event_timeout_modify_wakeup(struct event_timeout *et, interval_t n)$/;"	f	signature:(struct event_timeout *et, interval_t n)
event_timeout_remaining	interval.h	/^event_timeout_remaining(struct event_timeout *et)$/;"	f	signature:(struct event_timeout *et)
event_timeout_reset	interval.h	/^event_timeout_reset(struct event_timeout *et)$/;"	f	signature:(struct event_timeout *et)
event_timeout_trigger	interval.c	/^event_timeout_trigger(struct event_timeout *et,$/;"	f	signature:(struct event_timeout *et, struct timeval *tv, const int et_const_retry)
event_timeout_trigger	interval.h	/^bool event_timeout_trigger(struct event_timeout *et,$/;"	p	signature:(struct event_timeout *et, struct timeval *tv, const int et_const_retry)
event_wait	event.h	/^event_wait(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
events	event.c	/^    HANDLE *events;$/;"	m	struct:we_set	file:	access:public
events	event.c	/^    struct epoll_event *events;$/;"	m	struct:ep_set	typeref:struct:ep_set::epoll_event	file:	access:public
events	event.c	/^    struct pollfd *events;$/;"	m	struct:po_set	typeref:struct:po_set::pollfd	file:	access:public
exclude	pf.h	/^    bool exclude;$/;"	m	struct:ipv4_subnet	access:public
exclude	pf.h	/^    bool exclude;$/;"	m	struct:pf_cn	access:public
exit_event_initial_state	options.h	/^    bool exit_event_initial_state;$/;"	m	struct:options	access:public
exit_event_name	options.h	/^    const char *exit_event_name;$/;"	m	struct:options	access:public
explicit_exit_notification	options.h	/^    int explicit_exit_notification; \/* Explicitly tell peer when we are exiting via OCC_EXIT or [RESTART] message *\/$/;"	m	struct:connection_entry	access:public
explicit_exit_notification_interval	openvpn.h	/^    struct event_timeout explicit_exit_notification_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
explicit_exit_notification_time_wait	openvpn.h	/^    time_t explicit_exit_notification_time_wait;$/;"	m	struct:context_2	access:public
ext_cert_input	manage.h	/^    struct buffer_list *ext_cert_input;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
ext_cert_state	manage.h	/^    int ext_cert_state;$/;"	m	struct:man_connection	access:public
ext_key_input	manage.h	/^    struct buffer_list *ext_key_input;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
ext_key_state	manage.h	/^    int ext_key_state;$/;"	m	struct:man_connection	access:public
external_context	ssl_mbedtls.c	/^struct external_context {$/;"	s	file:
external_context::signature_length	ssl_mbedtls.c	/^    size_t signature_length;$/;"	m	struct:external_context	file:	access:public
external_key	ssl_mbedtls.h	/^    struct external_context *external_key; \/**< Management external key *\/$/;"	m	struct:tls_root_ctx	typeref:struct:tls_root_ctx::external_context	access:public
external_key_len	ssl_mbedtls.c	/^external_key_len(void *vctx)$/;"	f	file:	signature:(void *vctx)
external_pkcs1_sign	ssl_mbedtls.c	/^external_pkcs1_sign( void *ctx_voidptr,$/;"	f	file:	signature:( void *ctx_voidptr, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng, int mode, mbedtls_md_type_t md_alg, unsigned int hashlen, const unsigned char *hash, unsigned char *sig )
extra_buffer	mtu.h	/^    int extra_buffer;           \/**< Maximum number of bytes that$/;"	m	struct:frame	access:public
extra_certs_file	options.h	/^    const char *extra_certs_file;$/;"	m	struct:options	access:public
extra_certs_file_inline	options.h	/^    const char *extra_certs_file_inline;$/;"	m	struct:options	access:public
extra_frame	mtu.h	/^    int extra_frame;            \/**< Maximum number of bytes that all$/;"	m	struct:frame	access:public
extra_link	mtu.h	/^    int extra_link;             \/**< Maximum number of bytes in excess of$/;"	m	struct:frame	access:public
extra_tun	mtu.h	/^    int extra_tun;              \/**< Maximum number of bytes in excess of$/;"	m	struct:frame	access:public
extract_x509_extension	ssl_verify_openssl.c	/^extract_x509_extension(X509 *cert, char *fieldname, char *out, int size)$/;"	f	file:	signature:(X509 *cert, char *fieldname, char *out, int size)
extract_x509_field_ssl	ssl_verify_openssl.c	/^extract_x509_field_ssl(X509_NAME *x509, const char *field_name, char *out,$/;"	f	file:	signature:(X509_NAME *x509, const char *field_name, char *out, int size)
extract_x509_field_test	ssl.h	/^void extract_x509_field_test(void);$/;"	p	signature:(void)
factor	shaper.h	/^    double factor;$/;"	m	struct:shaper	access:public
factor	shaper.h	/^    int factor;$/;"	m	struct:shaper	access:public
fail_user_pass	misc.h	/^void fail_user_pass(const char *prefix,$/;"	p	signature:(const char *prefix, const unsigned int flags, const char *reason)
fast	event.c	/^    bool fast;$/;"	m	struct:ep_set	file:	access:public
fast	event.c	/^    bool fast;$/;"	m	struct:po_set	file:	access:public
fast	event.c	/^    bool fast;$/;"	m	struct:se_set	file:	access:public
fast	event.c	/^    bool fast;$/;"	m	struct:we_set	file:	access:public
fast_io	openvpn.h	/^    bool fast_io;$/;"	m	struct:context_2	access:public
fast_io	options.h	/^    bool fast_io;$/;"	m	struct:options	access:public
fd	packet_id.h	/^    int fd;$/;"	m	struct:packet_id_persist	access:public
fd	status.h	/^    int fd;$/;"	m	struct:status_output	access:public
fd	tun.h	/^    int fd; \/* file descriptor for TUN\/TAP dev *\/$/;"	m	struct:tuntap	access:public
fdtosend	manage.h	/^    int fdtosend;$/;"	m	struct:man_connection	access:public
file	dhcp.h	/^    uint8_t file[128]; \/* boot file name *\/$/;"	m	struct:dhcp	access:public
file	pool.h	/^    struct status_output *file;$/;"	m	struct:ifconfig_pool_persist	typeref:struct:ifconfig_pool_persist::status_output	access:public
file_last_mod	pf.h	/^    time_t file_last_mod;$/;"	m	struct:pf_context	access:public
filename	packet_id.h	/^    const char *filename;$/;"	m	struct:packet_id_persist	access:public
filename	pf.h	/^    char *filename;$/;"	m	struct:pf_context	access:public
filename	status.h	/^    char *filename;$/;"	m	struct:status_output	access:public
find_certificate_in_store	cryptoapi.c	/^find_certificate_in_store(const char *cert_prop, HCERTSTORE cert_store)$/;"	f	file:	signature:(const char *cert_prop, HCERTSTORE cert_store)
finish	cryptoapi.c	/^finish(RSA *rsa)$/;"	f	file:	signature:(RSA *rsa)
first_block	ssl_mbedtls.h	/^    buffer_entry *first_block;$/;"	m	struct:__anon11	access:public
first_time	openvpn.h	/^    bool first_time;            \/**< True on the first iteration of$/;"	m	struct:context	access:public
fixed	pool.h	/^    bool fixed;$/;"	m	struct:ifconfig_pool_entry	access:public
fixed	pool.h	/^    bool fixed;$/;"	m	struct:ifconfig_pool_persist	access:public
fixup_key	crypto.c	/^fixup_key(struct key *key, const struct key_type *kt)$/;"	f	signature:(struct key *key, const struct key_type *kt)
fixup_key	crypto.h	/^void fixup_key(struct key *key, const struct key_type *kt);$/;"	p	signature:(struct key *key, const struct key_type *kt)
flags	comp.h	/^    unsigned int flags;$/;"	m	struct:compress_context	access:public
flags	comp.h	/^    unsigned int flags;$/;"	m	struct:compress_options	access:public
flags	crypto.h	/^    unsigned int flags;         \/**< Bit-flags determining behavior of$/;"	m	struct:crypto_options	access:public
flags	dhcp.h	/^    uint16_t flags;$/;"	m	struct:dhcp	access:public
flags	manage.h	/^    unsigned int flags; \/* MF_x flags *\/$/;"	m	struct:man_settings	access:public
flags	manage.h	/^    unsigned int flags;$/;"	m	struct:man_def_auth_context	access:public
flags	manage.h	/^    unsigned int flags;$/;"	m	struct:management_callback	access:public
flags	mbuf.h	/^    unsigned int flags;$/;"	m	struct:mbuf_buffer	access:public
flags	misc.h	/^    unsigned int flags;$/;"	m	struct:auth_challenge_info	access:public
flags	misc.h	/^    unsigned int flags;$/;"	m	struct:static_challenge_info	access:public
flags	mtcp.c	/^    unsigned int flags;$/;"	m	struct:ta_iow_flags	file:	access:public
flags	multi.h	/^    unsigned int flags;$/;"	m	struct:multi_route	access:public
flags	options.h	/^    unsigned int flags;$/;"	m	struct:connection_entry	access:public
flags	proto.h	/^    uint8_t flags;$/;"	m	struct:openvpn_tcphdr	access:public
flags	route.h	/^    unsigned int flags;                         \/* RT_ flags, see route_ipv4 *\/$/;"	m	struct:route_ipv6	access:public
flags	route.h	/^    unsigned int flags;                 \/* RG_x flags, see route_option_list *\/$/;"	m	struct:route_ipv6_list	access:public
flags	route.h	/^    unsigned int flags;         \/* RG_x flags, see route_option-list *\/$/;"	m	struct:route_ipv6_option_list	access:public
flags	route.h	/^    unsigned int flags;   \/* RG_x flags *\/$/;"	m	struct:route_list	access:public
flags	route.h	/^    unsigned int flags; \/* RG_x flags *\/$/;"	m	struct:route_option_list	access:public
flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_gateway_info	access:public
flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_ipv4	access:public
flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_ipv6_gateway_info	access:public
flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_special_addr	access:public
flags	socket.h	/^    int flags;$/;"	m	struct:cached_dns_entry	access:public
flags	ssl_verify.h	/^    unsigned int flags;$/;"	m	struct:x509_track	access:public
flags	status.h	/^    unsigned int flags;$/;"	m	struct:status_output	access:public
flags	win32.h	/^    DWORD flags;$/;"	m	struct:overlapped_io	access:public
flags_default	status.h	/^    unsigned int flags_default;$/;"	m	struct:virtual_output	access:public
flip	gremlin.c	/^flip(int n)$/;"	f	file:	signature:(int n)
flow_lbl	proto.h	/^    uint8_t flow_lbl[3];$/;"	m	struct:openvpn_ipv6hdr	access:public
flush_payload_buffer	ssl.c	/^flush_payload_buffer(struct key_state *ks)$/;"	f	file:	signature:(struct key_state *ks)
foreground_fd	ps.h	/^    socket_descriptor_t foreground_fd;$/;"	m	struct:port_share	access:public
foreign_network	clinat.h	/^    in_addr_t foreign_network;$/;"	m	struct:client_nat_entry	access:public
foreign_option	options.c	/^foreign_option(struct options *o, char *argv[], int len, struct env_set *es)$/;"	f	file:	signature:(struct options *o, char *argv[], int len, struct env_set *es)
foreign_option_index	options.h	/^    int foreign_option_index;$/;"	m	struct:options	access:public
foreign_option_index	options.h	/^    int foreign_option_index;$/;"	m	struct:options_pre_pull	access:public
fork_dhcp_action	tun.c	/^fork_dhcp_action(struct tuntap *tt)$/;"	f	file:	signature:(struct tuntap *tt)
fork_register_dns_action	tun.c	/^fork_register_dns_action(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
fork_register_dns_action	tun.h	/^void fork_register_dns_action(struct tuntap *tt);$/;"	p	signature:(struct tuntap *tt)
fork_to_self	win32.c	/^fork_to_self(const char *cmdline)$/;"	f	signature:(const char *cmdline)
fork_to_self	win32.h	/^void fork_to_self(const char *cmdline);$/;"	p	signature:(const char *cmdline)
forked	error.c	/^static bool forked;         \/* GLOBAL *\/$/;"	v	file:
format_common_name	init.c	/^format_common_name(struct context *c, struct gc_arena *gc)$/;"	f	signature:(struct context *c, struct gc_arena *gc)
format_common_name	init.h	/^const char *format_common_name(struct context *c, struct gc_arena *gc);$/;"	p	signature:(struct context *c, struct gc_arena *gc)
format_extended_socket_error	mtu.c	/^format_extended_socket_error(int fd, int *mtu, struct gc_arena *gc)$/;"	f	signature:(int fd, int *mtu, struct gc_arena *gc)
format_extended_socket_error	mtu.h	/^const char *format_extended_socket_error(int fd, int *mtu, struct gc_arena *gc);$/;"	p	signature:(int fd, int *mtu, struct gc_arena *gc)
format_hex	buffer.h	/^format_hex(const uint8_t *data, int size, int maxoutput, struct gc_arena *gc)$/;"	f	signature:(const uint8_t *data, int size, int maxoutput, struct gc_arena *gc)
format_hex_ex	buffer.c	/^format_hex_ex(const uint8_t *data, int size, int maxoutput,$/;"	f	signature:(const uint8_t *data, int size, int maxoutput, unsigned int space_break_flags, const char *separator, struct gc_arena *gc)
format_hex_ex	buffer.h	/^format_hex_ex(const uint8_t *data, int size, int maxoutput,$/;"	p	signature:(const uint8_t *data, int size, int maxoutput, unsigned int space_break_flags, const char *separator, struct gc_arena *gc)
format_ip_addr_string	tun.c	/^format_ip_addr_string(const IP_ADDR_STRING *ip, struct gc_arena *gc)$/;"	f	file:	signature:(const IP_ADDR_STRING *ip, struct gc_arena *gc)
format_route_entry	route.c	/^format_route_entry(const MIB_IPFORWARDROW *r, struct gc_arena *gc)$/;"	f	file:	signature:(const MIB_IPFORWARDROW *r, struct gc_arena *gc)
forward_compatible	options.h	/^    bool forward_compatible;$/;"	m	struct:options	access:public
fp	options.c	/^        FILE *fp;$/;"	m	union:in_src::__anon3	file:	access:public
frag_off	proto.h	/^    uint16_t frag_off;$/;"	m	struct:openvpn_iphdr	access:public
fragment	fragment.h	/^struct fragment {$/;"	s
fragment	openvpn.h	/^    struct fragment_master *fragment;$/;"	m	struct:context_2	typeref:struct:context_2::fragment_master	access:public
fragment	options.h	/^    int fragment;        \/* internal fragmentation size *\/$/;"	m	struct:connection_entry	access:public
fragment::buf	fragment.h	/^    struct buffer buf;          \/**< Buffer in which received datagrams$/;"	m	struct:fragment	typeref:struct:fragment::buffer	access:public
fragment::defined	fragment.h	/^    bool defined;               \/**< Whether reassembly is currently$/;"	m	struct:fragment	access:public
fragment::map	fragment.h	/^    unsigned int map;$/;"	m	struct:fragment	access:public
fragment::max_frag_size	fragment.h	/^    int max_frag_size;          \/**< Maximum size of each %fragment. *\/$/;"	m	struct:fragment	access:public
fragment::timestamp	fragment.h	/^    time_t timestamp;           \/**< Timestamp for time-to-live purposes. *\/$/;"	m	struct:fragment	access:public
fragment_frame_init	fragment.c	/^fragment_frame_init(struct fragment_master *f, const struct frame *frame)$/;"	f	signature:(struct fragment_master *f, const struct frame *frame)
fragment_frame_init	fragment.h	/^void fragment_frame_init(struct fragment_master *f, const struct frame *frame);$/;"	p	signature:(struct fragment_master *f, const struct frame *frame)
fragment_free	fragment.c	/^fragment_free(struct fragment_master *f)$/;"	f	signature:(struct fragment_master *f)
fragment_free	fragment.h	/^void fragment_free(struct fragment_master *f);$/;"	p	signature:(struct fragment_master *f)
fragment_header_format	common.h	61;"	d
fragment_header_type	fragment.h	/^typedef uint32_t fragment_header_type;$/;"	t
fragment_housekeeping	fragment.h	/^fragment_housekeeping(struct fragment_master *f, struct frame *frame, struct timeval *tv)$/;"	f	signature:(struct fragment_master *f, struct frame *frame, struct timeval *tv)
fragment_incoming	fragment.c	/^fragment_incoming(struct fragment_master *f, struct buffer *buf,$/;"	f	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_incoming	fragment.h	/^void fragment_incoming(struct fragment_master *f, struct buffer *buf,$/;"	p	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_init	fragment.c	/^fragment_init(struct frame *frame)$/;"	f	signature:(struct frame *frame)
fragment_init	fragment.h	/^struct fragment_master *fragment_init(struct frame *frame);$/;"	p	signature:(struct frame *frame)
fragment_list	fragment.h	/^struct fragment_list {$/;"	s
fragment_list::fragments	fragment.h	/^    struct fragment fragments[N_FRAG_BUF];$/;"	m	struct:fragment_list	typeref:struct:fragment_list::fragment	access:public
fragment_list::index	fragment.h	/^    int index;                  \/**< Index of the packet being reassembled$/;"	m	struct:fragment_list	access:public
fragment_list::seq_id	fragment.h	/^    int seq_id;                 \/**< Highest fragmentation sequence ID of$/;"	m	struct:fragment_list	access:public
fragment_list_buf_free	fragment.c	/^fragment_list_buf_free(struct fragment_list *list)$/;"	f	file:	signature:(struct fragment_list *list)
fragment_list_buf_init	fragment.c	/^fragment_list_buf_init(struct fragment_list *list, const struct frame *frame)$/;"	f	file:	signature:(struct fragment_list *list, const struct frame *frame)
fragment_list_get_buf	fragment.c	/^fragment_list_get_buf(struct fragment_list *list, int seq_id)$/;"	f	file:	signature:(struct fragment_list *list, int seq_id)
fragment_master	fragment.h	/^struct fragment_master {$/;"	s
fragment_master::incoming	fragment.h	/^    struct fragment_list incoming;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::fragment_list	access:public
fragment_master::outgoing	fragment.h	/^    struct buffer outgoing;     \/**< Buffer containing the remaining parts$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer	access:public
fragment_master::outgoing_frag_id	fragment.h	/^    int outgoing_frag_id;       \/**< The fragment ID of the next part to$/;"	m	struct:fragment_master	access:public
fragment_master::outgoing_frag_size	fragment.h	/^    int outgoing_frag_size;     \/**< Size in bytes of each part to be$/;"	m	struct:fragment_master	access:public
fragment_master::outgoing_return	fragment.h	/^    struct buffer outgoing_return;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer	access:public
fragment_master::outgoing_seq_id	fragment.h	/^    int outgoing_seq_id;        \/**< Fragment sequence ID of the current$/;"	m	struct:fragment_master	access:public
fragment_master::received_os_mtu_hint	fragment.h	/^    bool received_os_mtu_hint;  \/**< Whether the operating system has$/;"	m	struct:fragment_master	access:public
fragment_master::wakeup	fragment.h	/^    struct event_timeout wakeup; \/**< Timeout structure used by the main$/;"	m	struct:fragment_master	typeref:struct:fragment_master::event_timeout	access:public
fragment_outgoing	fragment.c	/^fragment_outgoing(struct fragment_master *f, struct buffer *buf,$/;"	f	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_outgoing	fragment.h	/^void fragment_outgoing(struct fragment_master *f, struct buffer *buf,$/;"	p	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_outgoing_defined	fragment.h	/^fragment_outgoing_defined(struct fragment_master *f)$/;"	f	signature:(struct fragment_master *f)
fragment_prepend_flags	fragment.c	/^fragment_prepend_flags(struct buffer *buf,$/;"	f	file:	signature:(struct buffer *buf, int type, int seq_id, int frag_id, int frag_size)
fragment_ready_to_send	fragment.c	/^fragment_ready_to_send(struct fragment_master *f, struct buffer *buf,$/;"	f	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_ready_to_send	fragment.h	/^bool fragment_ready_to_send(struct fragment_master *f, struct buffer *buf,$/;"	p	signature:(struct fragment_master *f, struct buffer *buf, const struct frame *frame)
fragment_ttl_reap	fragment.c	/^fragment_ttl_reap(struct fragment_master *f)$/;"	f	file:	signature:(struct fragment_master *f)
fragment_wakeup	fragment.c	/^fragment_wakeup(struct fragment_master *f, struct frame *frame)$/;"	f	signature:(struct fragment_master *f, struct frame *frame)
fragment_wakeup	fragment.h	/^void fragment_wakeup(struct fragment_master *f, struct frame *frame);$/;"	p	signature:(struct fragment_master *f, struct frame *frame)
fragments	fragment.h	/^    struct fragment fragments[N_FRAG_BUF];$/;"	m	struct:fragment_list	typeref:struct:fragment_list::fragment	access:public
frame	mtu.h	/^struct frame {$/;"	s
frame	openvpn.h	/^    struct frame frame;                         \/* Active frame parameters *\/$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
frame	ssl.h	/^    struct frame frame;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::frame	access:public
frame	ssl_common.h	/^    struct frame frame;$/;"	m	struct:tls_options	typeref:struct:tls_options::frame	access:public
frame::align_adjust	mtu.h	/^    int align_adjust;$/;"	m	struct:frame	access:public
frame::align_flags	mtu.h	/^    unsigned int align_flags;$/;"	m	struct:frame	access:public
frame::extra_buffer	mtu.h	/^    int extra_buffer;           \/**< Maximum number of bytes that$/;"	m	struct:frame	access:public
frame::extra_frame	mtu.h	/^    int extra_frame;            \/**< Maximum number of bytes that all$/;"	m	struct:frame	access:public
frame::extra_link	mtu.h	/^    int extra_link;             \/**< Maximum number of bytes in excess of$/;"	m	struct:frame	access:public
frame::extra_tun	mtu.h	/^    int extra_tun;              \/**< Maximum number of bytes in excess of$/;"	m	struct:frame	access:public
frame::link_mtu	mtu.h	/^    int link_mtu;               \/**< Maximum packet size to be sent over$/;"	m	struct:frame	access:public
frame::link_mtu_dynamic	mtu.h	/^    int link_mtu_dynamic;       \/**< Dynamic MTU value for the external$/;"	m	struct:frame	access:public
frame_add_to_align_adjust	mtu.h	/^frame_add_to_align_adjust(struct frame *frame, const int increment)$/;"	f	signature:(struct frame *frame, const int increment)
frame_add_to_extra_buffer	mtu.h	/^frame_add_to_extra_buffer(struct frame *frame, const int increment)$/;"	f	signature:(struct frame *frame, const int increment)
frame_add_to_extra_frame	mtu.h	/^frame_add_to_extra_frame(struct frame *frame, const unsigned int increment)$/;"	f	signature:(struct frame *frame, const unsigned int increment)
frame_add_to_extra_link	mtu.h	/^frame_add_to_extra_link(struct frame *frame, const int increment)$/;"	f	signature:(struct frame *frame, const int increment)
frame_add_to_extra_tun	mtu.h	/^frame_add_to_extra_tun(struct frame *frame, const int increment)$/;"	f	signature:(struct frame *frame, const int increment)
frame_add_to_link_mtu	mtu.h	/^frame_add_to_link_mtu(struct frame *frame, const int increment)$/;"	f	signature:(struct frame *frame, const int increment)
frame_adjust_path_mtu	socket.c	/^frame_adjust_path_mtu(struct frame *frame, int pmtu, int proto)$/;"	f	signature:(struct frame *frame, int pmtu, int proto)
frame_adjust_path_mtu	socket.h	/^void frame_adjust_path_mtu(struct frame *frame, int pmtu, int proto);$/;"	p	signature:(struct frame *frame, int pmtu, int proto)
frame_align_to_extra_frame	mtu.h	/^frame_align_to_extra_frame(struct frame *frame)$/;"	f	signature:(struct frame *frame)
frame_defined	mtu.h	/^frame_defined(const struct frame *frame)$/;"	f	signature:(const struct frame *frame)
frame_finalize	mtu.c	/^frame_finalize(struct frame *frame,$/;"	f	signature:(struct frame *frame, bool link_mtu_defined, int link_mtu, bool tun_mtu_defined, int tun_mtu)
frame_finalize	mtu.h	/^void frame_finalize(struct frame *frame,$/;"	p	signature:(struct frame *frame, bool link_mtu_defined, int link_mtu, bool tun_mtu_defined, int tun_mtu)
frame_finalize_options	init.c	/^frame_finalize_options(struct context *c, const struct options *o)$/;"	f	file:	signature:(struct context *c, const struct options *o)
frame_fragment	openvpn.h	/^    struct frame frame_fragment;$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
frame_fragment_omit	openvpn.h	/^    struct frame frame_fragment_omit;$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
frame_headroom	mtu.h	/^frame_headroom(const struct frame *f, const unsigned int flag_mask)$/;"	f	signature:(const struct frame *f, const unsigned int flag_mask)
frame_init_mssfix	mtu.c	/^frame_init_mssfix(struct frame *frame, const struct options *options)$/;"	f	signature:(struct frame *frame, const struct options *options)
frame_init_mssfix	mtu.h	/^void frame_init_mssfix(struct frame *frame, const struct options *options);$/;"	p	signature:(struct frame *frame, const struct options *options)
frame_initial	openvpn.h	/^    struct frame frame_initial;                 \/* Restored on new session *\/$/;"	m	struct:context_2	typeref:struct:context_2::frame	access:public
frame_or_align_flags	mtu.h	/^frame_or_align_flags(struct frame *frame, const unsigned int flag_mask)$/;"	f	signature:(struct frame *frame, const unsigned int flag_mask)
frame_print	mtu.c	/^frame_print(const struct frame *frame,$/;"	f	signature:(const struct frame *frame, int level, const char *prefix)
frame_print	mtu.h	/^void frame_print(const struct frame *frame,$/;"	p	signature:(const struct frame *frame, int level, const char *prefix)
frame_remove_from_extra_frame	mtu.h	/^frame_remove_from_extra_frame(struct frame *frame, const unsigned int decrement)$/;"	f	signature:(struct frame *frame, const unsigned int decrement)
frame_set_mtu_dynamic	mtu.c	/^frame_set_mtu_dynamic(struct frame *frame, int mtu, unsigned int flags)$/;"	f	signature:(struct frame *frame, int mtu, unsigned int flags)
frame_set_mtu_dynamic	mtu.h	/^void frame_set_mtu_dynamic(struct frame *frame, int mtu, unsigned int flags);$/;"	p	signature:(struct frame *frame, int mtu, unsigned int flags)
frame_subtract_extra	mtu.c	/^frame_subtract_extra(struct frame *frame, const struct frame *src)$/;"	f	signature:(struct frame *frame, const struct frame *src)
frame_subtract_extra	mtu.h	/^void frame_subtract_extra(struct frame *frame, const struct frame *src);$/;"	p	signature:(struct frame *frame, const struct frame *src)
free	event.h	/^    void (*free)(struct event_set *es);$/;"	m	struct:event_set_functions	access:public
free_buf	buffer.c	/^free_buf(struct buffer *buf)$/;"	f	signature:(struct buffer *buf)
free_buf	buffer.h	/^void free_buf(struct buffer *buf);$/;"	p	signature:(struct buffer *buf)
free_context_buffers	init.c	/^free_context_buffers(struct context_buffers *b)$/;"	f	signature:(struct context_buffers *b)
free_context_buffers	init.h	/^void free_context_buffers(struct context_buffers *b);$/;"	p	signature:(struct context_buffers *b)
free_crypt_prov	cryptoapi.c	/^    BOOL free_crypt_prov;$/;"	m	struct:_CAPI_DATA	file:	access:public
free_fnc	buffer.h	/^    void (*free_fnc)(void *);$/;"	m	struct:gc_entry_special	access:public
free_key_ctx	crypto.c	/^free_key_ctx(struct key_ctx *ctx)$/;"	f	signature:(struct key_ctx *ctx)
free_key_ctx	crypto.h	/^void free_key_ctx(struct key_ctx *ctx);$/;"	p	signature:(struct key_ctx *ctx)
free_key_ctx_bi	crypto.c	/^free_key_ctx_bi(struct key_ctx_bi *ctx)$/;"	f	signature:(struct key_ctx_bi *ctx)
free_key_ctx_bi	crypto.h	/^void free_key_ctx_bi(struct key_ctx_bi *ctx);$/;"	p	signature:(struct key_ctx_bi *ctx)
free_ssl_lib	ssl.c	/^free_ssl_lib(void)$/;"	f	signature:(void)
free_ssl_lib	ssl.h	/^void free_ssl_lib(void);$/;"	p	signature:(void)
freebsd_modify_read_write_return	tun.c	/^freebsd_modify_read_write_return(int len)$/;"	f	file:	signature:(int len)
frequency_limit	otime.h	/^struct frequency_limit$/;"	s
frequency_limit::max	otime.h	/^    int max;$/;"	m	struct:frequency_limit	access:public
frequency_limit::n	otime.h	/^    int n;$/;"	m	struct:frequency_limit	access:public
frequency_limit::per	otime.h	/^    int per;$/;"	m	struct:frequency_limit	access:public
frequency_limit::reset	otime.h	/^    time_t reset;$/;"	m	struct:frequency_limit	access:public
frequency_limit_event_allowed	otime.c	/^frequency_limit_event_allowed(struct frequency_limit *f)$/;"	f	signature:(struct frequency_limit *f)
frequency_limit_event_allowed	otime.h	/^bool frequency_limit_event_allowed(struct frequency_limit *f);$/;"	p	signature:(struct frequency_limit *f)
frequency_limit_free	otime.c	/^frequency_limit_free(struct frequency_limit *f)$/;"	f	signature:(struct frequency_limit *f)
frequency_limit_free	otime.h	/^void frequency_limit_free(struct frequency_limit *f);$/;"	p	signature:(struct frequency_limit *f)
frequency_limit_init	otime.c	/^frequency_limit_init(int max, int per)$/;"	f	signature:(int max, int per)
frequency_limit_init	otime.h	/^struct frequency_limit *frequency_limit_init(int max, int per);$/;"	p	signature:(int max, int per)
from	openvpn.h	/^    struct link_socket_actual from;             \/* address of incoming datagram *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual	access:public
func	event.c	/^    struct event_set_functions func;$/;"	m	struct:ep_set	typeref:struct:ep_set::event_set_functions	file:	access:public
func	event.c	/^    struct event_set_functions func;$/;"	m	struct:po_set	typeref:struct:po_set::event_set_functions	file:	access:public
func	event.c	/^    struct event_set_functions func;$/;"	m	struct:se_set	typeref:struct:se_set::event_set_functions	file:	access:public
func	event.c	/^    struct event_set_functions func;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_functions	file:	access:public
func	event.h	/^    struct event_set_functions func;$/;"	m	struct:event_set	typeref:struct:event_set::event_set_functions	access:public
func	status.h	/^    void (*func) (void *arg, const unsigned int flags, const char *str);$/;"	m	struct:virtual_output	access:public
func1	plugin.h	/^    openvpn_plugin_func_v1 func1;$/;"	m	struct:plugin	access:public
func2	plugin.h	/^    openvpn_plugin_func_v2 func2;$/;"	m	struct:plugin	access:public
func3	plugin.h	/^    openvpn_plugin_func_v3 func3;$/;"	m	struct:plugin	access:public
future_trigger	interval.h	/^    time_t future_trigger;$/;"	m	struct:interval	access:public
gateway	route.h	/^    const char *gateway;        \/* e.g. "2001:db8:0::2" *\/$/;"	m	struct:route_ipv6_option	access:public
gateway	route.h	/^    const char *gateway;$/;"	m	struct:route_option	access:public
gateway	route.h	/^    in_addr_t gateway;$/;"	m	struct:route_ipv4	access:public
gateway	route.h	/^    struct in6_addr gateway;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr	access:public
gateway	route.h	/^    struct route_gateway_address gateway;$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address	access:public
gateway	route.h	/^    struct route_ipv6_gateway_address gateway;$/;"	m	struct:route_ipv6_gateway_info	typeref:struct:route_ipv6_gateway_info::route_ipv6_gateway_address	access:public
gc	misc.h	/^    struct gc_arena *gc;$/;"	m	struct:env_set	typeref:struct:env_set::gc_arena	access:public
gc	multi.h	/^    struct gc_arena gc;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::gc_arena	access:public
gc	openvpn.h	/^    struct gc_arena gc;         \/**< Garbage collection arena for$/;"	m	struct:context	typeref:struct:context::gc_arena	access:public
gc	openvpn.h	/^    struct gc_arena gc;         \/**< Garbage collection arena for$/;"	m	struct:context_2	typeref:struct:context_2::gc_arena	access:public
gc	options.h	/^    struct gc_arena gc;$/;"	m	struct:options	typeref:struct:options::gc_arena	access:public
gc	route.h	/^    struct gc_arena *gc;$/;"	m	struct:route_ipv6_option_list	typeref:struct:route_ipv6_option_list::gc_arena	access:public
gc	route.h	/^    struct gc_arena *gc;$/;"	m	struct:route_option_list	typeref:struct:route_option_list::gc_arena	access:public
gc	route.h	/^    struct gc_arena gc;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::gc_arena	access:public
gc	route.h	/^    struct gc_arena gc;$/;"	m	struct:route_list	typeref:struct:route_list::gc_arena	access:public
gc_addspecial	buffer.c	/^gc_addspecial(void *addr, void(free_function)(void *), struct gc_arena *a)$/;"	f	signature:(void *addr, void(free_function)(void *), struct gc_arena *a)
gc_addspecial	buffer.h	/^void gc_addspecial(void *addr, void (*free_function)(void *), struct gc_arena *a);$/;"	p	signature:(void *addr, void (*free_function)(void *), struct gc_arena *a)
gc_arena	buffer.h	/^struct gc_arena$/;"	s
gc_arena::list	buffer.h	/^    struct gc_entry *list;      \/**< First element of the linked list of$/;"	m	struct:gc_arena	typeref:struct:gc_arena::gc_entry	access:public
gc_arena::list_special	buffer.h	/^    struct gc_entry_special *list_special;$/;"	m	struct:gc_arena	typeref:struct:gc_arena::gc_entry_special	access:public
gc_defined	buffer.h	/^gc_defined(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
gc_detach	buffer.h	/^gc_detach(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
gc_entry	buffer.h	/^struct gc_entry$/;"	s
gc_entry::next	buffer.h	/^    struct gc_entry *next;      \/**< Pointer to the next item in the$/;"	m	struct:gc_entry	typeref:struct:gc_entry::gc_entry	access:public
gc_entry_special	buffer.h	/^struct gc_entry_special$/;"	s
gc_entry_special::addr	buffer.h	/^    void *addr;$/;"	m	struct:gc_entry_special	access:public
gc_entry_special::free_fnc	buffer.h	/^    void (*free_fnc)(void *);$/;"	m	struct:gc_entry_special	access:public
gc_entry_special::next	buffer.h	/^    struct gc_entry_special *next;$/;"	m	struct:gc_entry_special	typeref:struct:gc_entry_special::gc_entry_special	access:public
gc_free	buffer.h	/^gc_free(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
gc_freeaddrinfo_callback	buffer.h	/^gc_freeaddrinfo_callback(void *addr)$/;"	f	signature:(void *addr)
gc_init	buffer.h	/^gc_init(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
gc_malloc	buffer.h	/^void *gc_malloc(size_t size, bool clear, struct gc_arena *a);$/;"	p	signature:(size_t size, bool clear, struct gc_arena *a)
gc_malloc	buffer.h	158;"	d
gc_malloc_debug	buffer.c	/^gc_malloc_debug(size_t size, bool clear, struct gc_arena *a, const char *file, int line)$/;"	f	signature:(size_t size, bool clear, struct gc_arena *a, const char *file, int line)
gc_malloc_debug	buffer.h	/^void *gc_malloc_debug(size_t size, bool clear, struct gc_arena *a, const char *file, int line);$/;"	p	signature:(size_t size, bool clear, struct gc_arena *a, const char *file, int line)
gc_new	buffer.h	/^gc_new(void)$/;"	f	signature:(void)
gc_owned	options.h	/^    bool gc_owned;$/;"	m	struct:options	access:public
gc_reset	buffer.h	/^gc_reset(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
gc_transfer	buffer.c	/^gc_transfer(struct gc_arena *dest, struct gc_arena *src)$/;"	f	signature:(struct gc_arena *dest, struct gc_arena *src)
gc_transfer	buffer.h	/^void gc_transfer(struct gc_arena *dest, struct gc_arena *src);$/;"	p	signature:(struct gc_arena *dest, struct gc_arena *src)
gen_hmac_md5	ntlm.c	/^gen_hmac_md5(const uint8_t *data, int data_len, const uint8_t *key, int key_len,$/;"	f	file:	signature:(const uint8_t *data, int data_len, const uint8_t *key, int key_len, uint8_t *result)
gen_md4_hash	ntlm.c	/^gen_md4_hash(const uint8_t *data, int data_len, uint8_t *result)$/;"	f	file:	signature:(const uint8_t *data, int data_len, uint8_t *result)
gen_nonce	ntlm.c	/^gen_nonce(unsigned char *nonce)$/;"	f	file:	signature:(unsigned char *nonce)
gen_path	misc.c	/^gen_path(const char *directory, const char *filename, struct gc_arena *gc)$/;"	f	signature:(const char *directory, const char *filename, struct gc_arena *gc)
gen_path	misc.h	/^const char *gen_path(const char *directory, const char *filename, struct gc_arena *gc);$/;"	p	signature:(const char *directory, const char *filename, struct gc_arena *gc)
gen_timestamp	ntlm.c	/^gen_timestamp(uint8_t *timestamp)$/;"	f	file:	signature:(uint8_t *timestamp)
generate_ifconfig_broadcast_addr	tun.c	/^generate_ifconfig_broadcast_addr(in_addr_t local,$/;"	f	file:	signature:(in_addr_t local, in_addr_t netmask)
generate_key_expansion	ssl.c	/^generate_key_expansion(struct key_ctx_bi *key,$/;"	f	file:	signature:(struct key_ctx_bi *key, const struct key_type *key_type, const struct key_source2 *key_src, const struct session_id *client_sid, const struct session_id *server_sid, bool server)
generate_key_random	crypto.c	/^generate_key_random(struct key *key, const struct key_type *kt)$/;"	f	signature:(struct key *key, const struct key_type *kt)
generate_key_random	crypto.h	/^void generate_key_random(struct key *key, const struct key_type *kt);$/;"	p	signature:(struct key *key, const struct key_type *kt)
generate_prefix	multi.c	/^generate_prefix(struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_instance *mi)
genhash	pf.c	/^genhash(struct pf_cn_set *cns, const char *prefix, const int n_clients)$/;"	f	file:	signature:(struct pf_cn_set *cns, const char *prefix, const int n_clients)
genkey	options.h	/^    bool genkey;$/;"	m	struct:options	access:public
get_adapter	tun.c	/^get_adapter(const IP_ADAPTER_INFO *ai, DWORD index)$/;"	f	signature:(const IP_ADAPTER_INFO *ai, DWORD index)
get_adapter	tun.h	/^const IP_ADAPTER_INFO *get_adapter(const IP_ADAPTER_INFO *ai, DWORD index);$/;"	p	signature:(const IP_ADAPTER_INFO *ai, DWORD index)
get_adapter_index	tun.c	/^get_adapter_index(const char *guid)$/;"	f	file:	signature:(const char *guid)
get_adapter_index_flexible	tun.c	/^get_adapter_index_flexible(const char *name)  \/* actual name or GUID *\/$/;"	f	file:	signature:(const char *name)
get_adapter_index_flexible	tun.c	/^static DWORD get_adapter_index_flexible(const char *name);$/;"	p	file:	signature:(const char *name)
get_adapter_index_method_1	tun.c	/^get_adapter_index_method_1(const char *guid)$/;"	f	file:	signature:(const char *guid)
get_adapter_index_method_2	tun.c	/^get_adapter_index_method_2(const char *guid)$/;"	f	file:	signature:(const char *guid)
get_adapter_info	tun.c	/^get_adapter_info(DWORD index, struct gc_arena *gc)$/;"	f	signature:(DWORD index, struct gc_arena *gc)
get_adapter_info	tun.h	/^const IP_ADAPTER_INFO *get_adapter_info(DWORD index, struct gc_arena *gc);$/;"	p	signature:(DWORD index, struct gc_arena *gc)
get_adapter_info_list	tun.c	/^get_adapter_info_list(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
get_adapter_info_list	tun.h	/^const IP_ADAPTER_INFO *get_adapter_info_list(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
get_adapter_ip_netmask	tun.c	/^get_adapter_ip_netmask(const IP_ADAPTER_INFO *ai, const int n, in_addr_t *ip, in_addr_t *netmask)$/;"	f	file:	signature:(const IP_ADAPTER_INFO *ai, const int n, in_addr_t *ip, in_addr_t *netmask)
get_adapter_n_ip_netmask	tun.c	/^get_adapter_n_ip_netmask(const IP_ADAPTER_INFO *ai)$/;"	f	file:	signature:(const IP_ADAPTER_INFO *ai)
get_addr_generic	socket.c	/^get_addr_generic(sa_family_t af, unsigned int flags, const char *hostname,$/;"	f	file:	signature:(sa_family_t af, unsigned int flags, const char *hostname, void *network, unsigned int *netbits, int resolve_retry_seconds, volatile int *signal_received, int msglevel)
get_auth_challenge	misc.c	/^get_auth_challenge(const char *auth_challenge, struct gc_arena *gc)$/;"	f	signature:(const char *auth_challenge, struct gc_arena *gc)
get_auth_challenge	misc.h	/^struct auth_challenge_info *get_auth_challenge(const char *auth_challenge, struct gc_arena *gc);$/;"	p	signature:(const char *auth_challenge, struct gc_arena *gc)
get_bypass_addresses	route.c	/^get_bypass_addresses(struct route_bypass *rb, const unsigned int flags)   \/* PLATFORM-SPECIFIC *\/$/;"	f	file:	signature:(struct route_bypass *rb, const unsigned int flags)
get_bypass_addresses	route.c	/^get_bypass_addresses(struct route_bypass *rb, const unsigned int flags)$/;"	f	file:	signature:(struct route_bypass *rb, const unsigned int flags)
get_bypass_addresses	route.c	/^static void get_bypass_addresses(struct route_bypass *rb, const unsigned int flags);$/;"	p	file:	signature:(struct route_bypass *rb, const unsigned int flags)
get_cached_dns_entry	socket.c	/^get_cached_dns_entry(struct cached_dns_entry *dns_cache,$/;"	f	file:	signature:(struct cached_dns_entry *dns_cache, const char *hostname, const char *servname, int ai_family, int resolve_flags, struct addrinfo **ai)
get_cipher_name_pair	crypto.c	/^get_cipher_name_pair(const char *cipher_name)$/;"	f	file:	signature:(const char *cipher_name)
get_console_input	console_builtin.c	/^get_console_input(const char *prompt, const bool echo, char *input, const int capacity)$/;"	f	file:	signature:(const char *prompt, const bool echo, char *input, const int capacity)
get_console_input_systemd	console_systemd.c	/^get_console_input_systemd(const char *prompt, const bool echo, char *input, const int capacity)$/;"	f	file:	signature:(const char *prompt, const bool echo, char *input, const int capacity)
get_console_input_win32	console_builtin.c	/^get_console_input_win32(const char *prompt, const bool echo, char *input, const int capacity)$/;"	f	file:	signature:(const char *prompt, const bool echo, char *input, const int capacity)
get_debug_level	error.c	/^get_debug_level(void)$/;"	f	signature:(void)
get_debug_level	error.h	/^int get_debug_level(void);$/;"	p	signature:(void)
get_default_gateway	route.c	/^get_default_gateway(struct route_gateway_info *rgi)$/;"	f	signature:(struct route_gateway_info *rgi)
get_default_gateway	route.h	/^void get_default_gateway(struct route_gateway_info *rgi);$/;"	p	signature:(struct route_gateway_info *rgi)
get_default_gateway_ipv6	route.c	/^get_default_gateway_ipv6(struct route_ipv6_gateway_info *rgi6,$/;"	f	signature:(struct route_ipv6_gateway_info *rgi6, const struct in6_addr *dest)
get_default_gateway_ipv6	route.h	/^void get_default_gateway_ipv6(struct route_ipv6_gateway_info *rgi,$/;"	p	signature:(struct route_ipv6_gateway_info *rgi, const struct in6_addr *dest)
get_default_gateway_row	route.c	/^get_default_gateway_row(const MIB_IPFORWARDTABLE *routes)$/;"	f	file:	signature:(const MIB_IPFORWARDTABLE *routes)
get_device_guid	tun.c	/^get_device_guid(const char *name,$/;"	f	file:	signature:(const char *name, char *actual_name, int actual_name_size, const struct tap_reg *tap_reg, const struct panel_reg *panel_reg, struct gc_arena *gc)
get_dhcp_message_type	dhcp.c	/^get_dhcp_message_type(const struct dhcp *dhcp, const int optlen)$/;"	f	file:	signature:(const struct dhcp *dhcp, const int optlen)
get_highest_preference_tls_cipher	ssl_backend.h	/^void get_highest_preference_tls_cipher(char *buf, int size);$/;"	p	signature:(char *buf, int size)
get_highest_preference_tls_cipher	ssl_mbedtls.c	/^get_highest_preference_tls_cipher(char *buf, int size)$/;"	f	signature:(char *buf, int size)
get_highest_preference_tls_cipher	ssl_openssl.c	/^get_highest_preference_tls_cipher(char *buf, int size)$/;"	f	signature:(char *buf, int size)
get_interface_info	tun.c	/^get_interface_info(DWORD index, struct gc_arena *gc)$/;"	f	file:	signature:(DWORD index, struct gc_arena *gc)
get_interface_info_list	tun.c	/^get_interface_info_list(struct gc_arena *gc)$/;"	f	file:	signature:(struct gc_arena *gc)
get_interface_metric	block_dns.c	/^get_interface_metric(const NET_IFINDEX index, const ADDRESS_FAMILY family, int *is_auto)$/;"	f	signature:(const NET_IFINDEX index, const ADDRESS_FAMILY family, int *is_auto)
get_interface_metric	block_dns.h	/^get_interface_metric(const NET_IFINDEX index, const ADDRESS_FAMILY family, int *is_auto);$/;"	p	signature:(const NET_IFINDEX index, const ADDRESS_FAMILY family, int *is_auto)
get_ip_addr	options.c	/^get_ip_addr(const char *ip_string, int msglevel, bool *error)$/;"	f	file:	signature:(const char *ip_string, int msglevel, bool *error)
get_ipv6_addr	socket.c	/^get_ipv6_addr(const char *hostname, struct in6_addr *network,$/;"	f	signature:(const char *hostname, struct in6_addr *network, unsigned int *netbits, int msglevel)
get_ipv6_addr	socket.h	/^bool get_ipv6_addr(const char *hostname, struct in6_addr *network,$/;"	p	signature:(const char *hostname, struct in6_addr *network, unsigned int *netbits, int msglevel)
get_ipv6_addr_no_netbits	options.c	/^get_ipv6_addr_no_netbits(const char *addr, struct gc_arena *gc)$/;"	f	file:	signature:(const char *addr, struct gc_arena *gc)
get_key_value	proxy.c	/^get_key_value(const char *str,       \/* source string *\/$/;"	f	file:	signature:(const char *str, char *key, char *value, int max_key_len, int max_value_len, const char **endptr)
get_link_socket_info	forward-inline.h	/^get_link_socket_info(struct context *c)$/;"	f	signature:(struct context *c)
get_mute_cutoff	error.c	/^get_mute_cutoff(void)$/;"	f	signature:(void)
get_mute_cutoff	error.h	/^int get_mute_cutoff(void);$/;"	p	signature:(void)
get_orig_stderr	error.c	/^get_orig_stderr(void)$/;"	f	signature:(void)
get_orig_stderr	error.h	/^HANDLE get_orig_stderr(void);$/;"	p	signature:(void)
get_pa_var	proxy.c	/^get_pa_var(const char *key, const char *pa, struct gc_arena *gc)$/;"	f	file:	signature:(const char *key, const char *pa, struct gc_arena *gc)
get_packet_flood_parms	gremlin.c	/^get_packet_flood_parms(int level)$/;"	f	signature:(int level)
get_packet_flood_parms	gremlin.h	/^struct packet_flood_parms get_packet_flood_parms(int level);$/;"	p	signature:(int level)
get_panel_reg	tun.c	/^get_panel_reg(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
get_peer_info	manage.h	/^    char *(*get_peer_info) (void *arg, const unsigned long cid);$/;"	m	struct:management_callback	access:public
get_per_adapter_info	tun.c	/^get_per_adapter_info(const DWORD index, struct gc_arena *gc)$/;"	f	signature:(const DWORD index, struct gc_arena *gc)
get_per_adapter_info	tun.h	/^const IP_PER_ADAPTER_INFO *get_per_adapter_info(const DWORD index, struct gc_arena *gc);$/;"	p	signature:(const DWORD index, struct gc_arena *gc)
get_perf	perf.c	/^get_perf(int sdelta)$/;"	f	file:	signature:(int sdelta)
get_perf_index	perf.c	/^get_perf_index(int sdelta)$/;"	f	file:	signature:(int sdelta)
get_proxy_authenticate	proxy.c	/^get_proxy_authenticate(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, int timeout, char **data, struct gc_arena *gc, volatile int *signal_received)
get_random	crypto.c	/^get_random(void)$/;"	f	signature:(void)
get_random	misc.h	/^long int get_random(void);$/;"	p	signature:(void)
get_random	misc.h	155;"	d
get_server_poll_remaining_time	forward.c	/^get_server_poll_remaining_time(struct event_timeout *server_poll_timeout)$/;"	f	signature:(struct event_timeout *server_poll_timeout)
get_server_poll_remaining_time	forward.h	/^int get_server_poll_remaining_time(struct event_timeout *server_poll_timeout);$/;"	p	signature:(struct event_timeout *server_poll_timeout)
get_signal	sig.h	/^get_signal(volatile int *sig)$/;"	f	signature:(volatile int *sig)
get_special_addr	route.c	/^get_special_addr(const struct route_list *rl,$/;"	f	file:	signature:(const struct route_list *rl, const char *string, in_addr_t *out, bool *status)
get_ssl_library_version	ssl_backend.h	/^const char *get_ssl_library_version(void);$/;"	p	signature:(void)
get_ssl_library_version	ssl_mbedtls.c	/^get_ssl_library_version(void)$/;"	f	signature:(void)
get_ssl_library_version	ssl_openssl.c	/^get_ssl_library_version(void)$/;"	f	signature:(void)
get_stack_index	perf.c	/^get_stack_index(int sdelta)$/;"	f	file:	signature:(int sdelta)
get_tap_reg	tun.c	/^get_tap_reg(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
get_tun_adapter	tun.c	/^get_tun_adapter(const struct tuntap *tt, const IP_ADAPTER_INFO *list)$/;"	f	signature:(const struct tuntap *tt, const IP_ADAPTER_INFO *list)
get_tun_adapter	tun.h	/^const IP_ADAPTER_INFO *get_tun_adapter(const struct tuntap *tt, const IP_ADAPTER_INFO *list);$/;"	p	signature:(const struct tuntap *tt, const IP_ADAPTER_INFO *list)
get_tun_ip_ver	proto.h	/^get_tun_ip_ver(int tunnel_type, struct buffer *buf, int *ip_hdr_offset)$/;"	f	signature:(int tunnel_type, struct buffer *buf, int *ip_hdr_offset)
get_unspecified_device_guid	tun.c	/^get_unspecified_device_guid(const int device_number,$/;"	f	file:	signature:(const int device_number, char *actual_name, int actual_name_size, const struct tap_reg *tap_reg_src, const struct panel_reg *panel_reg_src, struct gc_arena *gc)
get_user_pass	misc.h	/^get_user_pass(struct user_pass *up,$/;"	f	signature:(struct user_pass *up, const char *auth_file, const char *prefix, const unsigned int flags)
get_user_pass_auto_userid	misc.c	/^get_user_pass_auto_userid(struct user_pass *up, const char *tag)$/;"	f	signature:(struct user_pass *up, const char *tag)
get_user_pass_auto_userid	misc.h	/^void get_user_pass_auto_userid(struct user_pass *up, const char *tag);$/;"	p	signature:(struct user_pass *up, const char *tag)
get_user_pass_cr	misc.c	/^get_user_pass_cr(struct user_pass *up,$/;"	f	signature:(struct user_pass *up, const char *auth_file, const char *prefix, const unsigned int flags, const char *auth_challenge)
get_user_pass_cr	misc.h	/^bool get_user_pass_cr(struct user_pass *up,$/;"	p	signature:(struct user_pass *up, const char *auth_file, const char *prefix, const unsigned int flags, const char *auth_challenge)
get_user_pass_http	proxy.c	/^get_user_pass_http(struct http_proxy_info *p, const bool force)$/;"	f	file:	signature:(struct http_proxy_info *p, const bool force)
get_win_sys_path	win32.c	/^get_win_sys_path(void)$/;"	f	signature:(void)
get_win_sys_path	win32.h	/^char *get_win_sys_path(void);$/;"	p	signature:(void)
get_windows_routing_table	route.c	/^get_windows_routing_table(struct gc_arena *gc)$/;"	f	file:	signature:(struct gc_arena *gc)
getaddr	socket.c	/^getaddr(unsigned int flags,$/;"	f	signature:(unsigned int flags, const char *hostname, int resolve_retry_seconds, bool *succeeded, volatile int *signal_received)
getaddr	socket.h	/^in_addr_t getaddr(unsigned int flags,$/;"	p	signature:(unsigned int flags, const char *hostname, int resolve_retry_seconds, bool *succeeded, volatile int *signal_received)
giaddr	dhcp.h	/^    uint32_t giaddr;   \/* relay agent IP address *\/$/;"	m	struct:dhcp	access:public
global_auth_retry	options.c	/^static int global_auth_retry; \/* GLOBAL *\/$/;"	v	file:
gr	platform.h	/^    struct group *gr;$/;"	m	struct:platform_state_group	typeref:struct:platform_state_group::group	access:public
gremlin	options.h	/^    int gremlin;$/;"	m	struct:options	access:public
gremlin	socket.h	/^    int gremlin; \/* --gremlin bits *\/$/;"	m	struct:link_socket	access:public
gremlin	ssl_common.h	/^    int gremlin;$/;"	m	struct:tls_options	access:public
gremlin_flood_clients	multi.c	/^gremlin_flood_clients(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
groupname	options.h	/^    const char *groupname;$/;"	m	struct:options	access:public
groupname	platform.h	/^    const char *groupname;$/;"	m	struct:platform_state_group	access:public
gt	schedule.h	/^    struct schedule_entry *gt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
guess_tuntap_dev	tun.c	/^guess_tuntap_dev(const char *dev,$/;"	f	signature:(const char *dev, const char *dev_type, const char *dev_node, struct gc_arena *gc)
guess_tuntap_dev	tun.h	/^const char *guess_tuntap_dev(const char *dev,$/;"	p	signature:(const char *dev, const char *dev_type, const char *dev_node, struct gc_arena *gc)
guid	tun.h	/^    const char *guid;$/;"	m	struct:panel_reg	access:public
guid	tun.h	/^    const char *guid;$/;"	m	struct:tap_reg	access:public
guid_to_name	tun.c	/^guid_to_name(const char *guid, const struct panel_reg *panel_reg)$/;"	f	file:	signature:(const char *guid, const struct panel_reg *panel_reg)
halt	manage.h	/^    bool halt;$/;"	m	struct:man_connection	access:public
halt	multi.h	/^    bool halt;$/;"	m	struct:multi_instance	access:public
halt_non_edge_triggered_signals	sig.h	/^halt_non_edge_triggered_signals(void)$/;"	f	signature:(void)
hand	tun.h	/^    HANDLE hand;$/;"	m	struct:tuntap	access:public
hand	win32.h	/^    HANDLE hand;$/;"	m	struct:semaphore	access:public
handle	plugin.h	/^    void *handle;$/;"	m	struct:plugin	access:public
handle	win32.h	/^    struct rw_handle handle;$/;"	m	struct:net_event_win32	typeref:struct:net_event_win32::rw_handle	access:public
handshake_window	options.h	/^    int handshake_window;$/;"	m	struct:options	access:public
handshake_window	ssl_common.h	/^    int handshake_window;$/;"	m	struct:tls_options	access:public
has_digit	buffer.h	/^has_digit(const unsigned char *src)$/;"	f	signature:(const unsigned char *src)
hash	list.h	/^    struct hash *hash;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash	access:public
hash	list.h	/^struct hash$/;"	s
hash	multi.h	/^    struct hash *hash;          \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
hash::buckets	list.h	/^    struct hash_bucket *buckets;$/;"	m	struct:hash	typeref:struct:hash::hash_bucket	access:public
hash::compare_function	list.h	/^    bool (*compare_function)(const void *key1, const void *key2); \/* return true if equal *\/$/;"	m	struct:hash	access:public
hash::hash_function	list.h	/^    uint32_t (*hash_function)(const void *key, uint32_t iv);$/;"	m	struct:hash	access:public
hash::iv	list.h	/^    uint32_t iv;$/;"	m	struct:hash	access:public
hash::mask	list.h	/^    int mask;$/;"	m	struct:hash	access:public
hash::n_buckets	list.h	/^    int n_buckets;$/;"	m	struct:hash	access:public
hash::n_elements	list.h	/^    int n_elements;$/;"	m	struct:hash	access:public
hash_add	list.c	/^hash_add(struct hash *hash, const void *key, void *value, bool replace)$/;"	f	signature:(struct hash *hash, const void *key, void *value, bool replace)
hash_add	list.h	/^bool hash_add(struct hash *hash, const void *key, void *value, bool replace);$/;"	p	signature:(struct hash *hash, const void *key, void *value, bool replace)
hash_add_fast	list.h	/^hash_add_fast(struct hash *hash,$/;"	f	signature:(struct hash *hash, struct hash_bucket *bucket, const void *key, uint32_t hv, void *value)
hash_algo_type	crypto_backend.h	/^} hash_algo_type ;$/;"	t	typeref:enum:__anon15
hash_bucket	list.h	/^hash_bucket(struct hash *hash, uint32_t hv)$/;"	f	signature:(struct hash *hash, uint32_t hv)
hash_bucket	list.h	/^struct hash_bucket$/;"	s
hash_bucket::list	list.h	/^    struct hash_element *list;$/;"	m	struct:hash_bucket	typeref:struct:hash_bucket::hash_element	access:public
hash_element	list.h	/^struct hash_element$/;"	s
hash_element::hash_value	list.h	/^    unsigned int hash_value;$/;"	m	struct:hash_element	access:public
hash_element::key	list.h	/^    const void *key;$/;"	m	struct:hash_element	access:public
hash_element::next	list.h	/^    struct hash_element *next;$/;"	m	struct:hash_element	typeref:struct:hash_element::hash_element	access:public
hash_element::value	list.h	/^    void *value;$/;"	m	struct:hash_element	access:public
hash_free	list.c	/^hash_free(struct hash *hash)$/;"	f	signature:(struct hash *hash)
hash_free	list.h	/^void hash_free(struct hash *hash);$/;"	p	signature:(struct hash *hash)
hash_func	list.c	/^hash_func(const uint8_t *k, uint32_t length, uint32_t initval)$/;"	f	signature:(const uint8_t *k, uint32_t length, uint32_t initval)
hash_func	list.h	/^uint32_t hash_func(const uint8_t *k, uint32_t length, uint32_t initval);$/;"	p	signature:(const uint8_t *k, uint32_t length, uint32_t initval)
hash_function	list.h	/^    uint32_t (*hash_function)(const void *key, uint32_t iv);$/;"	m	struct:hash	access:public
hash_init	list.c	/^hash_init(const int n_buckets,$/;"	f	signature:(const int n_buckets, const uint32_t iv, uint32_t (*hash_function)(const void *key, uint32_t iv), bool (*compare_function)(const void *key1, const void *key2))
hash_init	list.h	/^struct hash *hash_init(const int n_buckets,$/;"	p	signature:(const int n_buckets, const uint32_t iv, uint32_t (*hash_function)(const void *key, uint32_t iv), bool (*compare_function)(const void *key1, const void *key2))
hash_iterator	list.h	/^struct hash_iterator$/;"	s
hash_iterator::bucket	list.h	/^    struct hash_bucket *bucket;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_bucket	access:public
hash_iterator::bucket_index	list.h	/^    int bucket_index;$/;"	m	struct:hash_iterator	access:public
hash_iterator::bucket_index_end	list.h	/^    int bucket_index_end;$/;"	m	struct:hash_iterator	access:public
hash_iterator::bucket_index_start	list.h	/^    int bucket_index_start;$/;"	m	struct:hash_iterator	access:public
hash_iterator::bucket_marked	list.h	/^    bool bucket_marked;$/;"	m	struct:hash_iterator	access:public
hash_iterator::elem	list.h	/^    struct hash_element *elem;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element	access:public
hash_iterator::hash	list.h	/^    struct hash *hash;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash	access:public
hash_iterator::last	list.h	/^    struct hash_element *last;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element	access:public
hash_iterator_advance	list.c	/^hash_iterator_advance(struct hash_iterator *hi)$/;"	f	file:	signature:(struct hash_iterator *hi)
hash_iterator_delete_element	list.c	/^hash_iterator_delete_element(struct hash_iterator *hi)$/;"	f	signature:(struct hash_iterator *hi)
hash_iterator_delete_element	list.h	/^void hash_iterator_delete_element(struct hash_iterator *hi);$/;"	p	signature:(struct hash_iterator *hi)
hash_iterator_free	list.c	/^hash_iterator_free(struct hash_iterator *hi)$/;"	f	signature:(struct hash_iterator *hi)
hash_iterator_free	list.h	/^void hash_iterator_free(struct hash_iterator *hi);$/;"	p	signature:(struct hash_iterator *hi)
hash_iterator_init	list.c	/^hash_iterator_init(struct hash *hash,$/;"	f	signature:(struct hash *hash, struct hash_iterator *hi)
hash_iterator_init	list.h	/^void hash_iterator_init(struct hash *hash, struct hash_iterator *iter);$/;"	p	signature:(struct hash *hash, struct hash_iterator *iter)
hash_iterator_init_range	list.c	/^hash_iterator_init_range(struct hash *hash,$/;"	f	signature:(struct hash *hash, struct hash_iterator *hi, int start_bucket, int end_bucket)
hash_iterator_init_range	list.h	/^void hash_iterator_init_range(struct hash *hash,$/;"	p	signature:(struct hash *hash, struct hash_iterator *hi, int start_bucket, int end_bucket)
hash_iterator_lock	list.c	/^hash_iterator_lock(struct hash_iterator *hi, struct hash_bucket *b)$/;"	f	file:	signature:(struct hash_iterator *hi, struct hash_bucket *b)
hash_iterator_next	list.c	/^hash_iterator_next(struct hash_iterator *hi)$/;"	f	signature:(struct hash_iterator *hi)
hash_iterator_next	list.h	/^struct hash_element *hash_iterator_next(struct hash_iterator *hi);$/;"	p	signature:(struct hash_iterator *hi)
hash_iterator_unlock	list.c	/^hash_iterator_unlock(struct hash_iterator *hi)$/;"	f	file:	signature:(struct hash_iterator *hi)
hash_lookup	list.h	/^hash_lookup(struct hash *hash, const void *key)$/;"	f	signature:(struct hash *hash, const void *key)
hash_lookup_fast	list.c	/^hash_lookup_fast(struct hash *hash,$/;"	f	signature:(struct hash *hash, struct hash_bucket *bucket, const void *key, uint32_t hv)
hash_lookup_fast	list.h	/^struct hash_element *hash_lookup_fast(struct hash *hash,$/;"	p	signature:(struct hash *hash, struct hash_bucket *bucket, const void *key, uint32_t hv)
hash_n_buckets	list.h	/^hash_n_buckets(const struct hash *hash)$/;"	f	signature:(const struct hash *hash)
hash_n_elements	list.h	/^hash_n_elements(const struct hash *hash)$/;"	f	signature:(const struct hash *hash)
hash_remove	list.h	/^hash_remove(struct hash *hash, const void *key)$/;"	f	signature:(struct hash *hash, const void *key)
hash_remove_by_value	list.c	/^hash_remove_by_value(struct hash *hash, void *value)$/;"	f	signature:(struct hash *hash, void *value)
hash_remove_by_value	list.h	/^void hash_remove_by_value(struct hash *hash, void *value);$/;"	p	signature:(struct hash *hash, void *value)
hash_remove_fast	list.c	/^hash_remove_fast(struct hash *hash,$/;"	f	signature:(struct hash *hash, struct hash_bucket *bucket, const void *key, uint32_t hv)
hash_remove_fast	list.h	/^bool hash_remove_fast(struct hash *hash,$/;"	p	signature:(struct hash *hash, struct hash_bucket *bucket, const void *key, uint32_t hv)
hash_remove_marked	list.c	/^hash_remove_marked(struct hash *hash, struct hash_bucket *bucket)$/;"	f	file:	signature:(struct hash *hash, struct hash_bucket *bucket)
hash_table	pf.h	/^    struct hash *hash_table;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::hash	access:public
hash_value	list.h	/^    unsigned int hash_value;$/;"	m	struct:hash_element	access:public
hash_value	list.h	/^hash_value(const struct hash *hash, const void *key)$/;"	f	signature:(const struct hash *hash, const void *key)
hashmask	list.h	45;"	d
hashsize	list.h	44;"	d
head	buffer.h	/^    struct buffer_entry *head; \/* next item to pop\/peek *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry	access:public
head	mbuf.h	/^    unsigned int head;$/;"	m	struct:mbuf_set	access:public
head	options.c	/^    struct pull_filter *head;$/;"	m	struct:pull_filter_list	typeref:struct:pull_filter_list::pull_filter	file:	access:public
head	pushlist.h	/^    struct push_entry *head;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry	access:public
header_modify_read_write_return	tun.c	/^header_modify_read_write_return(int len)$/;"	f	file:	signature:(int len)
helper_add_route	helper.c	/^helper_add_route(const in_addr_t network, const in_addr_t netmask, struct options *o)$/;"	f	file:	signature:(const in_addr_t network, const in_addr_t netmask, struct options *o)
helper_client_server	helper.c	/^helper_client_server(struct options *o)$/;"	f	signature:(struct options *o)
helper_client_server	helper.h	/^void helper_client_server(struct options *o);$/;"	p	signature:(struct options *o)
helper_keepalive	helper.c	/^helper_keepalive(struct options *o)$/;"	f	signature:(struct options *o)
helper_keepalive	helper.h	/^void helper_keepalive(struct options *o);$/;"	p	signature:(struct options *o)
helper_tcp_nodelay	helper.c	/^helper_tcp_nodelay(struct options *o)$/;"	f	signature:(struct options *o)
helper_tcp_nodelay	helper.h	/^void helper_tcp_nodelay(struct options *o);$/;"	p	signature:(struct options *o)
hlen	dhcp.h	/^    uint8_t hlen;      \/* hardware address length (e.g. '6' for 10Mb Ethernet) *\/$/;"	m	struct:dhcp	access:public
hmac	crypto.h	/^    hmac_ctx_t *hmac;           \/**< Generic HMAC %context. *\/$/;"	m	struct:key_ctx	access:public
hmac	crypto.h	/^    uint8_t hmac[MAX_HMAC_KEY_LENGTH];$/;"	m	struct:key	access:public
hmac_ctx_cleanup	crypto_backend.h	/^void hmac_ctx_cleanup(hmac_ctx_t *ctx);$/;"	p	signature:(hmac_ctx_t *ctx)
hmac_ctx_cleanup	crypto_mbedtls.c	/^hmac_ctx_cleanup(mbedtls_md_context_t *ctx)$/;"	f	signature:(mbedtls_md_context_t *ctx)
hmac_ctx_cleanup	crypto_openssl.c	/^hmac_ctx_cleanup(HMAC_CTX *ctx)$/;"	f	signature:(HMAC_CTX *ctx)
hmac_ctx_final	crypto_backend.h	/^void hmac_ctx_final(hmac_ctx_t *ctx, uint8_t *dst);$/;"	p	signature:(hmac_ctx_t *ctx, uint8_t *dst)
hmac_ctx_final	crypto_mbedtls.c	/^hmac_ctx_final(mbedtls_md_context_t *ctx, uint8_t *dst)$/;"	f	signature:(mbedtls_md_context_t *ctx, uint8_t *dst)
hmac_ctx_final	crypto_openssl.c	/^hmac_ctx_final(HMAC_CTX *ctx, uint8_t *dst)$/;"	f	signature:(HMAC_CTX *ctx, uint8_t *dst)
hmac_ctx_free	crypto_backend.h	/^void hmac_ctx_free(hmac_ctx_t *ctx);$/;"	p	signature:(hmac_ctx_t *ctx)
hmac_ctx_free	crypto_mbedtls.c	/^hmac_ctx_free(mbedtls_md_context_t *ctx)$/;"	f	signature:(mbedtls_md_context_t *ctx)
hmac_ctx_free	crypto_openssl.c	/^hmac_ctx_free(HMAC_CTX *ctx)$/;"	f	signature:(HMAC_CTX *ctx)
hmac_ctx_init	crypto_backend.h	/^void hmac_ctx_init(hmac_ctx_t *ctx, const uint8_t *key, int key_length,$/;"	p	signature:(hmac_ctx_t *ctx, const uint8_t *key, int key_length, const md_kt_t *kt)
hmac_ctx_init	crypto_mbedtls.c	/^hmac_ctx_init(mbedtls_md_context_t *ctx, const uint8_t *key, int key_len,$/;"	f	signature:(mbedtls_md_context_t *ctx, const uint8_t *key, int key_len, const mbedtls_md_info_t *kt)
hmac_ctx_init	crypto_openssl.c	/^hmac_ctx_init(HMAC_CTX *ctx, const uint8_t *key, int key_len,$/;"	f	signature:(HMAC_CTX *ctx, const uint8_t *key, int key_len, const EVP_MD *kt)
hmac_ctx_new	crypto_backend.h	/^hmac_ctx_t *hmac_ctx_new(void);$/;"	p	signature:(void)
hmac_ctx_new	crypto_mbedtls.c	/^hmac_ctx_new(void)$/;"	f	signature:(void)
hmac_ctx_new	crypto_openssl.c	/^hmac_ctx_new(void)$/;"	f	signature:(void)
hmac_ctx_reset	crypto_backend.h	/^void hmac_ctx_reset(hmac_ctx_t *ctx);$/;"	p	signature:(hmac_ctx_t *ctx)
hmac_ctx_reset	crypto_mbedtls.c	/^hmac_ctx_reset(mbedtls_md_context_t *ctx)$/;"	f	signature:(mbedtls_md_context_t *ctx)
hmac_ctx_reset	crypto_openssl.c	/^hmac_ctx_reset(HMAC_CTX *ctx)$/;"	f	signature:(HMAC_CTX *ctx)
hmac_ctx_size	crypto_backend.h	/^int hmac_ctx_size(const hmac_ctx_t *ctx);$/;"	p	signature:(const hmac_ctx_t *ctx)
hmac_ctx_size	crypto_mbedtls.c	/^hmac_ctx_size(const mbedtls_md_context_t *ctx)$/;"	f	signature:(const mbedtls_md_context_t *ctx)
hmac_ctx_size	crypto_openssl.c	/^hmac_ctx_size(const HMAC_CTX *ctx)$/;"	f	signature:(const HMAC_CTX *ctx)
hmac_ctx_t	crypto_mbedtls.h	/^typedef mbedtls_md_context_t hmac_ctx_t;$/;"	t
hmac_ctx_t	crypto_openssl.h	/^typedef HMAC_CTX hmac_ctx_t;$/;"	t
hmac_ctx_update	crypto_backend.h	/^void hmac_ctx_update(hmac_ctx_t *ctx, const uint8_t *src, int src_len);$/;"	p	signature:(hmac_ctx_t *ctx, const uint8_t *src, int src_len)
hmac_ctx_update	crypto_mbedtls.c	/^hmac_ctx_update(mbedtls_md_context_t *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(mbedtls_md_context_t *ctx, const uint8_t *src, int src_len)
hmac_ctx_update	crypto_openssl.c	/^hmac_ctx_update(HMAC_CTX *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(HMAC_CTX *ctx, const uint8_t *src, int src_len)
hmac_length	crypto.h	/^    uint8_t hmac_length;        \/**< HMAC length, in bytes *\/$/;"	m	struct:key_type	access:public
hold	reliable.h	/^    bool hold; \/* don't xmit until reliable_schedule_now is called *\/$/;"	m	struct:reliable	access:public
hold_release	manage.h	/^    bool hold_release;$/;"	m	struct:man_persist	access:public
hop_limit	proto.h	/^    uint8_t hop_limit;$/;"	m	struct:openvpn_ipv6hdr	access:public
hops	dhcp.h	/^    uint8_t hops;      \/* client sets to 0, may be used by relay agents *\/$/;"	m	struct:dhcp	access:public
horizon	interval.h	/^    interval_t horizon;$/;"	m	struct:interval	access:public
host	options.h	/^    char host[RH_HOST_LEN];$/;"	m	struct:remote_host_store	access:public
hostname	socket.h	/^    const char *hostname;$/;"	m	struct:cached_dns_entry	access:public
hostname_randomize	misc.c	/^hostname_randomize(const char *hostname, struct gc_arena *gc)$/;"	f	signature:(const char *hostname, struct gc_arena *gc)
hostname_randomize	misc.h	/^const char *hostname_randomize(const char *hostname, struct gc_arena *gc);$/;"	p	signature:(const char *hostname, struct gc_arena *gc)
hton_fragment_header_type	fragment.h	194;"	d
htonpid	packet_id.h	63;"	d
htonpid	packet_id.h	87;"	d
htonps	socket.h	58;"	d
htontime	packet_id.h	69;"	d
htontime	packet_id.h	89;"	d
http_custom_header	proxy.h	/^struct http_custom_header {$/;"	s
http_custom_header::content	proxy.h	/^    const char *content;$/;"	m	struct:http_custom_header	access:public
http_custom_header::name	proxy.h	/^    const char *name;$/;"	m	struct:http_custom_header	access:public
http_proxy	openvpn.h	/^    struct http_proxy_info *http_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::http_proxy_info	access:public
http_proxy	socket.h	/^    struct http_proxy_info *http_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::http_proxy_info	access:public
http_proxy_close	proxy.c	/^http_proxy_close(struct http_proxy_info *hp)$/;"	f	signature:(struct http_proxy_info *hp)
http_proxy_close	proxy.h	/^void http_proxy_close(struct http_proxy_info *hp);$/;"	p	signature:(struct http_proxy_info *hp)
http_proxy_info	proxy.h	/^struct http_proxy_info {$/;"	s
http_proxy_info::auth_method	proxy.h	/^    int auth_method;$/;"	m	struct:http_proxy_info	access:public
http_proxy_info::defined	proxy.h	/^    bool defined;$/;"	m	struct:http_proxy_info	access:public
http_proxy_info::options	proxy.h	/^    struct http_proxy_options options;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::http_proxy_options	access:public
http_proxy_info::proxy_authenticate	proxy.h	/^    char *proxy_authenticate;$/;"	m	struct:http_proxy_info	access:public
http_proxy_info::queried_creds	proxy.h	/^    bool queried_creds;$/;"	m	struct:http_proxy_info	access:public
http_proxy_info::up	proxy.h	/^    struct user_pass up;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::user_pass	access:public
http_proxy_new	proxy.c	/^http_proxy_new(const struct http_proxy_options *o)$/;"	f	signature:(const struct http_proxy_options *o)
http_proxy_new	proxy.h	/^struct http_proxy_info *http_proxy_new(const struct http_proxy_options *o);$/;"	p	signature:(const struct http_proxy_options *o)
http_proxy_options	options.h	/^    struct http_proxy_options *http_proxy_options;$/;"	m	struct:connection_entry	typeref:struct:connection_entry::http_proxy_options	access:public
http_proxy_options	proxy.h	/^struct http_proxy_options {$/;"	s
http_proxy_options::auth_file	proxy.h	/^    const char *auth_file;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::auth_method_string	proxy.h	/^    const char *auth_method_string;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::auth_retry	proxy.h	/^    int auth_retry;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::custom_headers	proxy.h	/^    struct http_custom_header custom_headers[MAX_CUSTOM_HTTP_HEADER];$/;"	m	struct:http_proxy_options	typeref:struct:http_proxy_options::http_custom_header	access:public
http_proxy_options::http_version	proxy.h	/^    const char *http_version;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::inline_creds	proxy.h	/^    bool inline_creds;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::port	proxy.h	/^    const char *port;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::server	proxy.h	/^    const char *server;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options::user_agent	proxy.h	/^    const char *user_agent;$/;"	m	struct:http_proxy_options	access:public
http_proxy_options_simple	proxy.h	/^struct http_proxy_options_simple {$/;"	s
http_proxy_options_simple::auth_retry	proxy.h	/^    int auth_retry;$/;"	m	struct:http_proxy_options_simple	access:public
http_proxy_options_simple::port	proxy.h	/^    const char *port;$/;"	m	struct:http_proxy_options_simple	access:public
http_proxy_options_simple::server	proxy.h	/^    const char *server;$/;"	m	struct:http_proxy_options_simple	access:public
http_proxy_override	options.h	/^    struct http_proxy_options *http_proxy_override;$/;"	m	struct:options	typeref:struct:options::http_proxy_options	access:public
http_proxy_owned	openvpn.h	/^    bool http_proxy_owned;$/;"	m	struct:context_1	access:public
http_version	proxy.h	/^    const char *http_version;$/;"	m	struct:http_proxy_options	access:public
htype	dhcp.h	/^    uint8_t htype;     \/* hardware address type (e.g. '1' = 10Mb Ethernet) *\/$/;"	m	struct:dhcp	access:public
hwaddr	route.h	/^    uint8_t hwaddr[6];$/;"	m	struct:route_gateway_info	access:public
hwaddr	route.h	/^    uint8_t hwaddr[6];$/;"	m	struct:route_ipv6_gateway_info	access:public
iana_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon8	access:public
id	multi.c	/^id(struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_instance *mi)
id	packet_id.h	/^    packet_id_type id;        \/* highest sequence number received *\/$/;"	m	struct:packet_id_rec	access:public
id	packet_id.h	/^    packet_id_type id;     \/* sequence number *\/$/;"	m	struct:packet_id_persist	access:public
id	packet_id.h	/^    packet_id_type id;     \/* sequence number *\/$/;"	m	struct:packet_id_persist_file_image	access:public
id	packet_id.h	/^    packet_id_type id;$/;"	m	struct:packet_id_net	access:public
id	packet_id.h	/^    packet_id_type id;$/;"	m	struct:packet_id_send	access:public
id	proto.h	/^    uint16_t id;$/;"	m	struct:openvpn_iphdr	access:public
id	session_id.h	/^    uint8_t id[8];$/;"	m	struct:session_id	access:public
id_last_written	packet_id.h	/^    packet_id_type id_last_written;$/;"	m	struct:packet_id_persist	access:public
iface	route.h	/^    char *iface;                \/* interface name (null terminated) *\/$/;"	m	struct:route_ipv6	access:public
iface	route.h	/^    char iface[16]; \/* interface name (null terminated), may be empty *\/$/;"	m	struct:route_gateway_info	access:public
iface	route.h	/^    char iface[16]; \/* interface name (null terminated), may be empty *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
ifconfig_ipv6_local	options.h	/^    const char *ifconfig_ipv6_local;$/;"	m	struct:options	access:public
ifconfig_ipv6_netbits	options.h	/^    int ifconfig_ipv6_netbits;$/;"	m	struct:options	access:public
ifconfig_ipv6_pool_base	options.h	/^    struct in6_addr ifconfig_ipv6_pool_base;            \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
ifconfig_ipv6_pool_defined	options.h	/^    bool ifconfig_ipv6_pool_defined;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
ifconfig_ipv6_pool_netbits	options.h	/^    int ifconfig_ipv6_pool_netbits;                     \/* IPv6 *\/$/;"	m	struct:options	access:public
ifconfig_ipv6_remote	options.h	/^    const char *ifconfig_ipv6_remote;$/;"	m	struct:options	access:public
ifconfig_local	options.h	/^    const char *ifconfig_local;$/;"	m	struct:options	access:public
ifconfig_noexec	options.h	/^    bool ifconfig_noexec;$/;"	m	struct:options	access:public
ifconfig_nowarn	options.h	/^    bool ifconfig_nowarn;$/;"	m	struct:options	access:public
ifconfig_options_string	tun.c	/^ifconfig_options_string(const struct tuntap *tt, bool remote, bool disable, struct gc_arena *gc)$/;"	f	signature:(const struct tuntap *tt, bool remote, bool disable, struct gc_arena *gc)
ifconfig_options_string	tun.h	/^const char *ifconfig_options_string(const struct tuntap *tt, bool remote, bool disable, struct gc_arena *gc);$/;"	p	signature:(const struct tuntap *tt, bool remote, bool disable, struct gc_arena *gc)
ifconfig_order	tun.h	/^ifconfig_order(void)$/;"	f	signature:(void)
ifconfig_pool	multi.h	/^    struct ifconfig_pool *ifconfig_pool;$/;"	m	struct:multi_context	typeref:struct:multi_context::ifconfig_pool	access:public
ifconfig_pool	pool.h	/^struct ifconfig_pool$/;"	s
ifconfig_pool::base	pool.h	/^    in_addr_t base;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool::base_ipv6	pool.h	/^    struct in6_addr base_ipv6;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::in6_addr	access:public
ifconfig_pool::duplicate_cn	pool.h	/^    bool duplicate_cn;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool::ipv6	pool.h	/^    bool ipv6;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool::list	pool.h	/^    struct ifconfig_pool_entry *list;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::ifconfig_pool_entry	access:public
ifconfig_pool::size	pool.h	/^    int size;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool::size_ipv6	pool.h	/^    unsigned int size_ipv6;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool::type	pool.h	/^    int type;$/;"	m	struct:ifconfig_pool	access:public
ifconfig_pool_acquire	pool.c	/^ifconfig_pool_acquire(struct ifconfig_pool *pool, in_addr_t *local, in_addr_t *remote, struct in6_addr *remote_ipv6, const char *common_name)$/;"	f	signature:(struct ifconfig_pool *pool, in_addr_t *local, in_addr_t *remote, struct in6_addr *remote_ipv6, const char *common_name)
ifconfig_pool_acquire	pool.h	/^ifconfig_pool_handle ifconfig_pool_acquire(struct ifconfig_pool *pool, in_addr_t *local, in_addr_t *remote, struct in6_addr *remote_ipv6, const char *common_name);$/;"	p	signature:(struct ifconfig_pool *pool, in_addr_t *local, in_addr_t *remote, struct in6_addr *remote_ipv6, const char *common_name)
ifconfig_pool_defined	options.h	/^    bool ifconfig_pool_defined;$/;"	m	struct:options	access:public
ifconfig_pool_end	options.h	/^    in_addr_t ifconfig_pool_end;$/;"	m	struct:options	access:public
ifconfig_pool_entry	pool.h	/^struct ifconfig_pool_entry$/;"	s
ifconfig_pool_entry::common_name	pool.h	/^    char *common_name;$/;"	m	struct:ifconfig_pool_entry	access:public
ifconfig_pool_entry::fixed	pool.h	/^    bool fixed;$/;"	m	struct:ifconfig_pool_entry	access:public
ifconfig_pool_entry::in_use	pool.h	/^    bool in_use;$/;"	m	struct:ifconfig_pool_entry	access:public
ifconfig_pool_entry::last_release	pool.h	/^    time_t last_release;$/;"	m	struct:ifconfig_pool_entry	access:public
ifconfig_pool_entry_free	pool.c	/^ifconfig_pool_entry_free(struct ifconfig_pool_entry *ipe, bool hard)$/;"	f	file:	signature:(struct ifconfig_pool_entry *ipe, bool hard)
ifconfig_pool_find	pool.c	/^ifconfig_pool_find(struct ifconfig_pool *pool, const char *common_name)$/;"	f	file:	signature:(struct ifconfig_pool *pool, const char *common_name)
ifconfig_pool_free	pool.c	/^ifconfig_pool_free(struct ifconfig_pool *pool)$/;"	f	signature:(struct ifconfig_pool *pool)
ifconfig_pool_free	pool.h	/^void ifconfig_pool_free(struct ifconfig_pool *pool);$/;"	p	signature:(struct ifconfig_pool *pool)
ifconfig_pool_handle	pool.h	/^typedef int ifconfig_pool_handle;$/;"	t
ifconfig_pool_handle_to_ip_base	pool.c	/^ifconfig_pool_handle_to_ip_base(const struct ifconfig_pool *pool, ifconfig_pool_handle hand)$/;"	f	file:	signature:(const struct ifconfig_pool *pool, ifconfig_pool_handle hand)
ifconfig_pool_handle_to_ipv6_base	pool.c	/^ifconfig_pool_handle_to_ipv6_base(const struct ifconfig_pool *pool, ifconfig_pool_handle hand)$/;"	f	file:	signature:(const struct ifconfig_pool *pool, ifconfig_pool_handle hand)
ifconfig_pool_init	pool.c	/^ifconfig_pool_init(int type, in_addr_t start, in_addr_t end,$/;"	f	signature:(int type, in_addr_t start, in_addr_t end, const bool duplicate_cn, const bool ipv6_pool, const struct in6_addr ipv6_base, const int ipv6_netbits )
ifconfig_pool_init	pool.h	/^struct ifconfig_pool *ifconfig_pool_init(int type, in_addr_t start, in_addr_t end, const bool duplicate_cn, const bool ipv6_pool, const struct in6_addr ipv6_base, const int ipv6_netbits );$/;"	p	signature:(int type, in_addr_t start, in_addr_t end, const bool duplicate_cn, const bool ipv6_pool, const struct in6_addr ipv6_base, const int ipv6_netbits )
ifconfig_pool_ip_base_to_handle	pool.c	/^ifconfig_pool_ip_base_to_handle(const struct ifconfig_pool *pool, const in_addr_t addr)$/;"	f	file:	signature:(const struct ifconfig_pool *pool, const in_addr_t addr)
ifconfig_pool_list	pool.c	/^ifconfig_pool_list(const struct ifconfig_pool *pool, struct status_output *out)$/;"	f	file:	signature:(const struct ifconfig_pool *pool, struct status_output *out)
ifconfig_pool_msg	pool.c	/^ifconfig_pool_msg(const struct ifconfig_pool *pool, int msglevel)$/;"	f	file:	signature:(const struct ifconfig_pool *pool, int msglevel)
ifconfig_pool_netmask	options.h	/^    in_addr_t ifconfig_pool_netmask;$/;"	m	struct:options	access:public
ifconfig_pool_persist	openvpn.h	/^    struct ifconfig_pool_persist *ifconfig_pool_persist;$/;"	m	struct:context_1	typeref:struct:context_1::ifconfig_pool_persist	access:public
ifconfig_pool_persist	pool.h	/^struct ifconfig_pool_persist$/;"	s
ifconfig_pool_persist::file	pool.h	/^    struct status_output *file;$/;"	m	struct:ifconfig_pool_persist	typeref:struct:ifconfig_pool_persist::status_output	access:public
ifconfig_pool_persist::fixed	pool.h	/^    bool fixed;$/;"	m	struct:ifconfig_pool_persist	access:public
ifconfig_pool_persist_close	pool.c	/^ifconfig_pool_persist_close(struct ifconfig_pool_persist *persist)$/;"	f	signature:(struct ifconfig_pool_persist *persist)
ifconfig_pool_persist_close	pool.h	/^void ifconfig_pool_persist_close(struct ifconfig_pool_persist *persist);$/;"	p	signature:(struct ifconfig_pool_persist *persist)
ifconfig_pool_persist_filename	options.h	/^    const char *ifconfig_pool_persist_filename;$/;"	m	struct:options	access:public
ifconfig_pool_persist_init	pool.c	/^ifconfig_pool_persist_init(const char *filename, int refresh_freq)$/;"	f	signature:(const char *filename, int refresh_freq)
ifconfig_pool_persist_init	pool.h	/^struct ifconfig_pool_persist *ifconfig_pool_persist_init(const char *filename, int refresh_freq);$/;"	p	signature:(const char *filename, int refresh_freq)
ifconfig_pool_persist_owned	openvpn.h	/^    bool ifconfig_pool_persist_owned;$/;"	m	struct:context_1	access:public
ifconfig_pool_persist_refresh_freq	options.h	/^    int ifconfig_pool_persist_refresh_freq;$/;"	m	struct:options	access:public
ifconfig_pool_read	pool.c	/^ifconfig_pool_read(struct ifconfig_pool_persist *persist, struct ifconfig_pool *pool)$/;"	f	signature:(struct ifconfig_pool_persist *persist, struct ifconfig_pool *pool)
ifconfig_pool_read	pool.h	/^void ifconfig_pool_read(struct ifconfig_pool_persist *persist, struct ifconfig_pool *pool);$/;"	p	signature:(struct ifconfig_pool_persist *persist, struct ifconfig_pool *pool)
ifconfig_pool_release	pool.c	/^ifconfig_pool_release(struct ifconfig_pool *pool, ifconfig_pool_handle hand, const bool hard)$/;"	f	signature:(struct ifconfig_pool *pool, ifconfig_pool_handle hand, const bool hard)
ifconfig_pool_release	pool.h	/^bool ifconfig_pool_release(struct ifconfig_pool *pool, ifconfig_pool_handle hand, const bool hard);$/;"	p	signature:(struct ifconfig_pool *pool, ifconfig_pool_handle hand, const bool hard)
ifconfig_pool_set	pool.c	/^ifconfig_pool_set(struct ifconfig_pool *pool, const char *cn, const in_addr_t addr, const bool fixed)$/;"	f	file:	signature:(struct ifconfig_pool *pool, const char *cn, const in_addr_t addr, const bool fixed)
ifconfig_pool_start	options.h	/^    in_addr_t ifconfig_pool_start;$/;"	m	struct:options	access:public
ifconfig_pool_test	pool.c	/^ifconfig_pool_test(in_addr_t start, in_addr_t end)$/;"	f	signature:(in_addr_t start, in_addr_t end)
ifconfig_pool_test	pool.h	/^void ifconfig_pool_test(in_addr_t start, in_addr_t end);$/;"	p	signature:(in_addr_t start, in_addr_t end)
ifconfig_pool_verify_range	pool.c	/^ifconfig_pool_verify_range(const int msglevel, const in_addr_t start, const in_addr_t end)$/;"	f	signature:(const int msglevel, const in_addr_t start, const in_addr_t end)
ifconfig_pool_verify_range	pool.h	/^bool ifconfig_pool_verify_range(const int msglevel, const in_addr_t start, const in_addr_t end);$/;"	p	signature:(const int msglevel, const in_addr_t start, const in_addr_t end)
ifconfig_pool_write	pool.c	/^ifconfig_pool_write(struct ifconfig_pool_persist *persist, const struct ifconfig_pool *pool)$/;"	f	signature:(struct ifconfig_pool_persist *persist, const struct ifconfig_pool *pool)
ifconfig_pool_write	pool.h	/^void ifconfig_pool_write(struct ifconfig_pool_persist *persist, const struct ifconfig_pool *pool);$/;"	p	signature:(struct ifconfig_pool_persist *persist, const struct ifconfig_pool *pool)
ifconfig_pool_write_trigger	pool.c	/^ifconfig_pool_write_trigger(struct ifconfig_pool_persist *persist)$/;"	f	signature:(struct ifconfig_pool_persist *persist)
ifconfig_pool_write_trigger	pool.h	/^bool ifconfig_pool_write_trigger(struct ifconfig_pool_persist *persist);$/;"	p	signature:(struct ifconfig_pool_persist *persist)
ifconfig_push_constraint_satisfied	multi.c	/^ifconfig_push_constraint_satisfied(const struct context *c)$/;"	f	file:	signature:(const struct context *c)
ifconfig_remote_netmask	options.h	/^    const char *ifconfig_remote_netmask;$/;"	m	struct:options	access:public
ifconfig_sanity_check	tun.c	/^ifconfig_sanity_check(bool tun, in_addr_t addr, int topology)$/;"	f	file:	signature:(bool tun, in_addr_t addr, int topology)
ifconfig_warn_how_to_silence	tun.c	/^static const char ifconfig_warn_how_to_silence[] = "(silence this warning with --ifconfig-nowarn)";$/;"	v	file:
iflags	route.h	/^    unsigned int iflags;                \/* RL_ flags, see route_list *\/$/;"	m	struct:route_ipv6_list	access:public
iflags	route.h	/^    unsigned int iflags;$/;"	m	struct:route_list	access:public
ignore_restart_signals	sig.c	/^ignore_restart_signals(struct context *c)$/;"	f	file:	signature:(struct context *c)
ignore_sys_error	error.h	/^ignore_sys_error(const int err)$/;"	f	signature:(const int err)
ignore_unknown_option	options.h	/^    const char **ignore_unknown_option;$/;"	m	struct:options	access:public
implicit_iv	crypto.h	/^    uint8_t implicit_iv[OPENVPN_MAX_IV_LENGTH];$/;"	m	struct:key_ctx	access:public
implicit_iv_len	crypto.h	/^    size_t implicit_iv_len;     \/**< The length of implicit_iv *\/$/;"	m	struct:key_ctx	access:public
in	manage.h	/^    struct command_line *in;$/;"	m	struct:man_connection	typeref:struct:man_connection::command_line	access:public
in	ssl_mbedtls.h	/^    endless_buffer in;$/;"	m	struct:__anon12	access:public
in	win32.h	/^    struct rw_handle in;$/;"	m	struct:win32_signal	typeref:struct:win32_signal::rw_handle	access:public
in4	socket.h	/^        struct in_pktinfo in4;$/;"	m	union:link_socket_actual::__anon14	typeref:struct:link_socket_actual::__anon14::in_pktinfo	access:public
in4	socket.h	/^        struct sockaddr_in in4;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr_in	access:public
in6	socket.h	/^        struct in6_pktinfo in6;$/;"	m	union:link_socket_actual::__anon14	typeref:struct:link_socket_actual::__anon14::in6_pktinfo	access:public
in6	socket.h	/^        struct sockaddr_in6 in6;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr_in6	access:public
in_addr_t_from_mroute_addr	mroute.h	/^in_addr_t_from_mroute_addr(const struct mroute_addr *addr)$/;"	f	signature:(const struct mroute_addr *addr)
in_extra	manage.h	/^    struct buffer_list *in_extra;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
in_extra_cid	manage.h	/^    unsigned long in_extra_cid;$/;"	m	struct:man_connection	access:public
in_extra_cmd	manage.h	/^    int in_extra_cmd;$/;"	m	struct:man_connection	access:public
in_extra_dispatch	manage.c	/^in_extra_dispatch(struct management *man)$/;"	f	file:	signature:(struct management *man)
in_extra_kid	manage.h	/^    unsigned int in_extra_kid;$/;"	m	struct:man_connection	access:public
in_extra_reset	manage.c	/^in_extra_reset(struct man_connection *mc, const int mode)$/;"	f	file:	signature:(struct man_connection *mc, const int mode)
in_key	crypto.h	/^    int in_key;                 \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state	access:public
in_src	options.c	/^struct in_src {$/;"	s	file:
in_src::__anon3::fp	options.c	/^        FILE *fp;$/;"	m	union:in_src::__anon3	file:	access:public
in_src::__anon3::multiline	options.c	/^        struct buffer *multiline;$/;"	m	union:in_src::__anon3	typeref:struct:in_src::__anon3::buffer	file:	access:public
in_src::type	options.c	/^    int type;$/;"	m	struct:in_src	file:	access:public
in_src::u	options.c	/^    } u;$/;"	m	struct:in_src	typeref:union:in_src::__anon3	file:	access:public
in_src_get	options.c	/^in_src_get(const struct in_src *is, char *line, const int size)$/;"	f	file:	signature:(const struct in_src *is, char *line, const int size)
in_use	pool.h	/^    bool in_use;$/;"	m	struct:ifconfig_pool_entry	access:public
inactivity_bytes	openvpn.h	/^    int inactivity_bytes;$/;"	m	struct:context_2	access:public
inactivity_interval	openvpn.h	/^    struct event_timeout inactivity_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
inactivity_minimum_bytes	options.h	/^    int inactivity_minimum_bytes;$/;"	m	struct:options	access:public
inactivity_timeout	options.h	/^    int inactivity_timeout;     \/* --inactive *\/$/;"	m	struct:options	access:public
incoming	fragment.h	/^    struct fragment_list incoming;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::fragment_list	access:public
incoming_push_message	push.c	/^incoming_push_message(struct context *c, const struct buffer *buffer)$/;"	f	signature:(struct context *c, const struct buffer *buffer)
incoming_push_message	push.h	/^void incoming_push_message(struct context *c, const struct buffer *buffer);$/;"	p	signature:(struct context *c, const struct buffer *buffer)
index	fragment.h	/^    int index;                  \/**< Index of the packet being reassembled$/;"	m	struct:fragment_list	access:public
index_verify	integer.h	/^index_verify(int index, int size, const char *file, int line)$/;"	f	signature:(int index, int size, const char *file, int line)
inetd	options.h	/^    int inetd;$/;"	m	struct:options	access:public
inetd	socket.h	/^    int inetd;$/;"	m	struct:link_socket	access:public
inetd_socket_descriptor	misc.c	/^int inetd_socket_descriptor = SOCKET_UNDEFINED; \/* GLOBAL *\/$/;"	v
info	socket.h	/^    struct link_socket_info info;$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_info	access:public
info_callback	ssl_openssl.c	/^info_callback(INFO_CALLBACK_SSL_CONST SSL *s, int where, int ret)$/;"	f	file:	signature:(INFO_CALLBACK_SSL_CONST SSL *s, int where, int ret)
inherit_context_child	init.c	/^inherit_context_child(struct context *dest,$/;"	f	signature:(struct context *dest, const struct context *src)
inherit_context_child	init.h	/^void inherit_context_child(struct context *dest,$/;"	p	signature:(struct context *dest, const struct context *src)
inherit_context_top	init.c	/^inherit_context_top(struct context *dest,$/;"	f	signature:(struct context *dest, const struct context *src)
inherit_context_top	init.h	/^void inherit_context_top(struct context *dest,$/;"	p	signature:(struct context *dest, const struct context *src)
init	cryptoapi.c	/^init(RSA *rsa)$/;"	f	file:	signature:(RSA *rsa)
init_connection_list	init.c	/^init_connection_list(struct context *c)$/;"	f	file:	signature:(struct context *c)
init_context_buffers	init.c	/^init_context_buffers(const struct frame *frame)$/;"	f	signature:(const struct frame *frame)
init_context_buffers	init.h	/^struct context_buffers *init_context_buffers(const struct frame *frame);$/;"	p	signature:(const struct frame *frame)
init_crypto_pre	init.c	/^init_crypto_pre(struct context *c, const unsigned int flags)$/;"	f	file:	signature:(struct context *c, const unsigned int flags)
init_http_proxy_options_once	proxy.c	/^init_http_proxy_options_once(struct http_proxy_options **hpo,$/;"	f	signature:(struct http_proxy_options **hpo, struct gc_arena *gc)
init_http_proxy_options_once	proxy.h	/^struct http_proxy_options *init_http_proxy_options_once(struct http_proxy_options **hpo,$/;"	p	signature:(struct http_proxy_options **hpo, struct gc_arena *gc)
init_instance	init.c	/^init_instance(struct context *c, const struct env_set *env, const unsigned int flags)$/;"	f	signature:(struct context *c, const struct env_set *env, const unsigned int flags)
init_instance	init.h	/^void init_instance(struct context *c, const struct env_set *env, const unsigned int flags);$/;"	p	signature:(struct context *c, const struct env_set *env, const unsigned int flags)
init_instance_handle_signals	init.c	/^init_instance_handle_signals(struct context *c, const struct env_set *env, const unsigned int flags)$/;"	f	signature:(struct context *c, const struct env_set *env, const unsigned int flags)
init_instance_handle_signals	init.h	/^void init_instance_handle_signals(struct context *c, const struct env_set *env, const unsigned int flags);$/;"	p	signature:(struct context *c, const struct env_set *env, const unsigned int flags)
init_ip_addr_string2	tun.c	/^init_ip_addr_string2(IP_ADDR_STRING *dest, const IP_ADDR_STRING *src1, const IP_ADDR_STRING *src2)$/;"	f	file:	signature:(IP_ADDR_STRING *dest, const IP_ADDR_STRING *src1, const IP_ADDR_STRING *src2)
init_key_ctx	crypto.c	/^init_key_ctx(struct key_ctx *ctx, const struct key *key,$/;"	f	signature:(struct key_ctx *ctx, const struct key *key, const struct key_type *kt, int enc, const char *prefix)
init_key_ctx	crypto.h	/^void init_key_ctx(struct key_ctx *ctx, const struct key *key,$/;"	p	signature:(struct key_ctx *ctx, const struct key *key, const struct key_type *kt, int enc, const char *prefix)
init_key_ctx_bi	crypto.c	/^init_key_ctx_bi(struct key_ctx_bi *ctx, const struct key2 *key2,$/;"	f	signature:(struct key_ctx_bi *ctx, const struct key2 *key2, int key_direction, const struct key_type *kt, const char *name)
init_key_ctx_bi	crypto.h	/^void init_key_ctx_bi(struct key_ctx_bi *ctx, const struct key2 *key2,$/;"	p	signature:(struct key_ctx_bi *ctx, const struct key2 *key2, int key_direction, const struct key_type *kt, const char *name)
init_key_type	crypto.c	/^init_key_type(struct key_type *kt, const char *ciphername,$/;"	f	signature:(struct key_type *kt, const char *ciphername, const char *authname, int keysize, bool tls_mode, bool warn)
init_key_type	crypto.h	/^void init_key_type(struct key_type *kt, const char *ciphername,$/;"	p	signature:(struct key_type *kt, const char *ciphername, const char *authname, int keysize, bool tls_mode, bool warn)
init_management	init.c	/^init_management(struct context *c)$/;"	f	signature:(struct context *c)
init_management	init.h	/^void init_management(struct context *c);$/;"	p	signature:(struct context *c)
init_management_callback_multi	multi.c	/^init_management_callback_multi(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
init_management_callback_multi	multi.h	/^void init_management_callback_multi(struct multi_context *m);$/;"	p	signature:(struct multi_context *m)
init_management_callback_p2p	init.c	/^init_management_callback_p2p(struct context *c)$/;"	f	signature:(struct context *c)
init_management_callback_p2p	init.h	/^void init_management_callback_p2p(struct context *c);$/;"	p	signature:(struct context *c)
init_net_event_win32	win32.c	/^init_net_event_win32(struct rw_handle *event, long network_events, socket_descriptor_t sd, unsigned int flags)$/;"	f	signature:(struct rw_handle *event, long network_events, socket_descriptor_t sd, unsigned int flags)
init_net_event_win32	win32.h	/^void init_net_event_win32(struct rw_handle *event, long network_events, socket_descriptor_t sd, unsigned int flags);$/;"	p	signature:(struct rw_handle *event, long network_events, socket_descriptor_t sd, unsigned int flags)
init_options	options.c	/^init_options(struct options *o, const bool init_gc)$/;"	f	signature:(struct options *o, const bool init_gc)
init_options	options.h	/^void init_options(struct options *o, const bool init_gc);$/;"	p	signature:(struct options *o, const bool init_gc)
init_options_dev	init.c	/^init_options_dev(struct options *options)$/;"	f	signature:(struct options *options)
init_options_dev	init.h	/^void init_options_dev(struct options *options);$/;"	p	signature:(struct options *options)
init_plugins	init.c	/^init_plugins(struct context *c)$/;"	f	signature:(struct context *c)
init_plugins	init.h	/^void init_plugins(struct context *c);$/;"	p	signature:(struct context *c)
init_port_share	init.c	/^init_port_share(struct context *c)$/;"	f	file:	signature:(struct context *c)
init_proxy	init.c	/^init_proxy(struct context *c)$/;"	f	file:	signature:(struct context *c)
init_proxy_dowork	init.c	/^init_proxy_dowork(struct context *c)$/;"	f	file:	signature:(struct context *c)
init_query_passwords	init.c	/^init_query_passwords(const struct context *c)$/;"	f	signature:(const struct context *c)
init_query_passwords	init.h	/^void init_query_passwords(const struct context *c);$/;"	p	signature:(const struct context *c)
init_route	route.c	/^init_route(struct route_ipv4 *r,$/;"	f	file:	signature:(struct route_ipv4 *r, struct addrinfo **network_list, const struct route_option *ro, const struct route_list *rl)
init_route_ipv6	route.c	/^init_route_ipv6(struct route_ipv6 *r6,$/;"	f	file:	signature:(struct route_ipv6 *r6, const struct route_ipv6_option *r6o, const struct route_ipv6_list *rl6 )
init_route_ipv6_list	route.c	/^init_route_ipv6_list(struct route_ipv6_list *rl6,$/;"	f	signature:(struct route_ipv6_list *rl6, const struct route_ipv6_option_list *opt6, const char *remote_endpoint, int default_metric, const struct in6_addr *remote_host_ipv6, struct env_set *es)
init_route_ipv6_list	route.h	/^bool init_route_ipv6_list(struct route_ipv6_list *rl6,$/;"	p	signature:(struct route_ipv6_list *rl6, const struct route_ipv6_option_list *opt6, const char *remote_endpoint, int default_metric, const struct in6_addr *remote_host, struct env_set *es)
init_route_list	route.c	/^init_route_list(struct route_list *rl,$/;"	f	signature:(struct route_list *rl, const struct route_option_list *opt, const char *remote_endpoint, int default_metric, in_addr_t remote_host, struct env_set *es)
init_route_list	route.h	/^bool init_route_list(struct route_list *rl,$/;"	p	signature:(struct route_list *rl, const struct route_option_list *opt, const char *remote_endpoint, int default_metric, in_addr_t remote_host, struct env_set *es)
init_security_attributes_allow_all	win32.c	/^init_security_attributes_allow_all(struct security_attributes *obj)$/;"	f	signature:(struct security_attributes *obj)
init_security_attributes_allow_all	win32.h	/^bool init_security_attributes_allow_all(struct security_attributes *obj);$/;"	p	signature:(struct security_attributes *obj)
init_ssl	ssl.c	/^init_ssl(const struct options *options, struct tls_root_ctx *new_ctx)$/;"	f	signature:(const struct options *options, struct tls_root_ctx *new_ctx)
init_ssl	ssl.h	/^void init_ssl(const struct options *options, struct tls_root_ctx *ctx);$/;"	p	signature:(const struct options *options, struct tls_root_ctx *ctx)
init_ssl_lib	ssl.c	/^init_ssl_lib(void)$/;"	f	signature:(void)
init_ssl_lib	ssl.h	/^void init_ssl_lib(void);$/;"	p	signature:(void)
init_static	init.c	/^init_static(void)$/;"	f	signature:(void)
init_static	init.h	/^bool init_static(void);$/;"	p	signature:(void)
init_tun	tun.c	/^init_tun(const char *dev,        \/* --dev option *\/$/;"	f	signature:(const char *dev, const char *dev_type, int topology, const char *ifconfig_local_parm, const char *ifconfig_remote_netmask_parm, const char *ifconfig_ipv6_local_parm, int ifconfig_ipv6_netbits_parm, const char *ifconfig_ipv6_remote_parm, struct addrinfo *local_public, struct addrinfo *remote_public, const bool strict_warn, struct env_set *es)
init_tun	tun.h	/^struct tuntap *init_tun(const char *dev,        \/* --dev option *\/$/;"	p	signature:(const char *dev, const char *dev_type, int topology, const char *ifconfig_local_parm, const char *ifconfig_remote_netmask_parm, const char *ifconfig_ipv6_local_parm, int ifconfig_ipv6_netbits_parm, const char *ifconfig_ipv6_remote_parm, struct addrinfo *local_public, struct addrinfo *remote_public, const bool strict_warn, struct env_set *es)
init_tun_post	tun.c	/^init_tun_post(struct tuntap *tt,$/;"	f	signature:(struct tuntap *tt, const struct frame *frame, const struct tuntap_options *options)
init_tun_post	tun.h	/^void init_tun_post(struct tuntap *tt,$/;"	p	signature:(struct tuntap *tt, const struct frame *frame, const struct tuntap_options *options)
init_verb_mute	init.c	/^init_verb_mute(struct context *c, unsigned int flags)$/;"	f	signature:(struct context *c, unsigned int flags)
init_verb_mute	init.h	/^void init_verb_mute(struct context *c, unsigned int flags);$/;"	p	signature:(struct context *c, unsigned int flags)
init_win32	win32.c	/^init_win32(void)$/;"	f	signature:(void)
init_win32	win32.h	/^void init_win32(void);$/;"	p	signature:(void)
initial_opcode	ssl_common.h	/^    int initial_opcode;         \/* our initial P_ opcode *\/$/;"	m	struct:key_state	access:public
initial_opcode	ssl_common.h	/^    int initial_opcode;         \/* our initial P_ opcode *\/$/;"	m	struct:tls_session	access:public
initial_timeout	reliable.h	/^    interval_t initial_timeout;$/;"	m	struct:reliable	access:public
initialised	ssl_mbedtls.h	/^    bool initialised;           \/**< True if the context has been initialised *\/$/;"	m	struct:tls_root_ctx	access:public
initialization_point	plugin.h	/^    openvpn_plugin_select_initialization_point_v1 initialization_point;$/;"	m	struct:plugin	access:public
initialization_sequence_completed	init.c	/^initialization_sequence_completed(struct context *c, const unsigned int flags)$/;"	f	signature:(struct context *c, const unsigned int flags)
initialization_sequence_completed	init.h	/^void initialization_sequence_completed(struct context *c, const unsigned int flags);$/;"	p	signature:(struct context *c, const unsigned int flags)
initialized	crypto.h	/^    bool initialized;$/;"	m	struct:key_ctx_bi	access:public
initialized	gremlin.c	/^static bool initialized; \/* GLOBAL *\/$/;"	v	file:
initialized	packet_id.h	/^    bool initialized;         \/* true if packet_id_init was called *\/$/;"	m	struct:packet_id_rec	access:public
initialized	plugin.h	/^    bool initialized;$/;"	m	struct:plugin	access:public
inline	syshead.h	395;"	d
inline	syshead.h	396;"	d
inline_creds	proxy.h	/^    bool inline_creds;$/;"	m	struct:http_proxy_options	access:public
inotify_fd	openvpn.h	/^    int inotify_fd; \/* descriptor for monitoring file changes *\/$/;"	m	struct:context_2	access:public
inotify_watch	multi.h	/^    int inotify_watch; \/* watch descriptor for acf *\/$/;"	m	struct:multi_instance	access:public
inotify_watchers	multi.h	/^    struct hash *inotify_watchers;$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
ins	schedule.c	/^    int ins;$/;"	m	struct:status	file:	access:public
instance	mbuf.h	/^    struct multi_instance *instance;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::multi_instance	access:public
instance	multi.h	/^    struct multi_instance *instance;$/;"	m	struct:multi_route	typeref:struct:multi_route::multi_instance	access:public
instances	multi.h	/^    struct multi_instance **instances;  \/**< Array of multi_instances. An instance can be$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
int_compare_function	multi.c	/^int_compare_function(const void *key1, const void *key2)$/;"	f	file:	signature:(const void *key1, const void *key2)
int_hash_function	multi.c	/^int_hash_function(const void *key, uint32_t iv)$/;"	f	file:	signature:(const void *key, uint32_t iv)
interval	interval.h	/^struct interval$/;"	s
interval::future_trigger	interval.h	/^    time_t future_trigger;$/;"	m	struct:interval	access:public
interval::horizon	interval.h	/^    interval_t horizon;$/;"	m	struct:interval	access:public
interval::last_action	interval.h	/^    time_t last_action;$/;"	m	struct:interval	access:public
interval::last_test_true	interval.h	/^    time_t last_test_true;$/;"	m	struct:interval	access:public
interval::refresh	interval.h	/^    interval_t refresh;$/;"	m	struct:interval	access:public
interval_action	interval.h	/^interval_action(struct interval *top)$/;"	f	signature:(struct interval *top)
interval_earliest_wakeup	otime.h	/^interval_earliest_wakeup(interval_t *wakeup, time_t at, time_t current)$/;"	f	signature:(interval_t *wakeup, time_t at, time_t current)
interval_future_trigger	interval.h	/^interval_future_trigger(struct interval *top, interval_t wakeup)$/;"	f	signature:(struct interval *top, interval_t wakeup)
interval_init	interval.c	/^interval_init(struct interval *top, int horizon, int refresh)$/;"	f	signature:(struct interval *top, int horizon, int refresh)
interval_init	interval.h	/^void interval_init(struct interval *top, int horizon, int refresh);$/;"	p	signature:(struct interval *top, int horizon, int refresh)
interval_schedule_wakeup	interval.h	/^interval_schedule_wakeup(struct interval *top, interval_t *wakeup)$/;"	f	signature:(struct interval *top, interval_t *wakeup)
interval_t	common.h	/^typedef int interval_t;$/;"	t
interval_test	interval.h	/^interval_test(struct interval *top)$/;"	f	signature:(struct interval *top)
intval	manage.h	/^    int intval;$/;"	m	union:log_entry_union	access:public
io_wait	forward-inline.h	/^io_wait(struct context *c, const unsigned int flags)$/;"	f	signature:(struct context *c, const unsigned int flags)
io_wait_dowork	forward.c	/^io_wait_dowork(struct context *c, const unsigned int flags)$/;"	f	signature:(struct context *c, const unsigned int flags)
iostate	win32.h	/^    int iostate;$/;"	m	struct:overlapped_io	access:public
ip	dhcp.h	/^    struct openvpn_iphdr ip;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_iphdr	access:public
ip	proto.h	/^    struct openvpn_iphdr ip;$/;"	m	struct:ip_tcp_udp_hdr	typeref:struct:ip_tcp_udp_hdr::openvpn_iphdr	access:public
ip_addr_dotted_quad_safe	socket.c	/^ip_addr_dotted_quad_safe(const char *dotted_quad)$/;"	f	signature:(const char *dotted_quad)
ip_addr_dotted_quad_safe	socket.h	/^bool ip_addr_dotted_quad_safe(const char *dotted_quad);$/;"	p	signature:(const char *dotted_quad)
ip_addr_member_of	tun.c	/^ip_addr_member_of(const in_addr_t addr, const IP_ADDR_STRING *ias)$/;"	f	file:	signature:(const in_addr_t addr, const IP_ADDR_STRING *ias)
ip_addr_one_to_one	tun.c	/^ip_addr_one_to_one(const in_addr_t *a1, const int a1len, const IP_ADDR_STRING *ias)$/;"	f	file:	signature:(const in_addr_t *a1, const int a1len, const IP_ADDR_STRING *ias)
ip_addr_string_to_array	tun.c	/^ip_addr_string_to_array(in_addr_t *dest, int *dest_len, const IP_ADDR_STRING *src)$/;"	f	signature:(in_addr_t *dest, int *dest_len, const IP_ADDR_STRING *src)
ip_dest	proto.h	/^    in_addr_t ip_dest;$/;"	m	struct:openvpn_arp	access:public
ip_fd	tun.h	/^    int ip_fd;$/;"	m	struct:tuntap	access:public
ip_or_dns_addr_safe	socket.c	/^ip_or_dns_addr_safe(const char *addr, const bool allow_fqdn)$/;"	f	signature:(const char *addr, const bool allow_fqdn)
ip_or_dns_addr_safe	socket.h	/^bool ip_or_dns_addr_safe(const char *addr, const bool allow_fqdn);$/;"	p	signature:(const char *addr, const bool allow_fqdn)
ip_remote_hint	options.h	/^    const char *ip_remote_hint;$/;"	m	struct:options	access:public
ip_src	proto.h	/^    in_addr_t ip_src;$/;"	m	struct:openvpn_arp	access:public
ip_tcp_udp_hdr	proto.h	/^struct ip_tcp_udp_hdr {$/;"	s
ip_tcp_udp_hdr::__anon1::tcp	proto.h	/^        struct openvpn_tcphdr tcp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_tcphdr	access:public
ip_tcp_udp_hdr::__anon1::udp	proto.h	/^        struct openvpn_udphdr udp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_udphdr	access:public
ip_tcp_udp_hdr::ip	proto.h	/^    struct openvpn_iphdr ip;$/;"	m	struct:ip_tcp_udp_hdr	typeref:struct:ip_tcp_udp_hdr::openvpn_iphdr	access:public
ip_tcp_udp_hdr::u	proto.h	/^    } u;$/;"	m	struct:ip_tcp_udp_hdr	typeref:union:ip_tcp_udp_hdr::__anon1	access:public
ip_win32_defined	tun.h	/^    bool ip_win32_defined;$/;"	m	struct:tuntap_options	access:public
ip_win32_type	tun.h	/^    int ip_win32_type;$/;"	m	struct:tuntap_options	access:public
ipapi_context	tun.h	/^    ULONG ipapi_context;$/;"	m	struct:tuntap	access:public
ipapi_context_defined	tun.h	/^    bool ipapi_context_defined;$/;"	m	struct:tuntap	access:public
ipapi_instance	tun.h	/^    ULONG ipapi_instance;$/;"	m	struct:tuntap	access:public
ipchange	options.h	/^    const char *ipchange;$/;"	m	struct:options	access:public
ipchange_command	socket.h	/^    const char *ipchange_command;$/;"	m	struct:link_socket_info	access:public
ipchange_fmt	socket.c	/^ipchange_fmt(const bool include_cmd, struct argv *argv, const struct link_socket_info *info, struct gc_arena *gc)$/;"	f	file:	signature:(const bool include_cmd, struct argv *argv, const struct link_socket_info *info, struct gc_arena *gc)
ipconfig_register_dns	tun.c	/^ipconfig_register_dns(const struct env_set *es)$/;"	f	signature:(const struct env_set *es)
ipconfig_register_dns	tun.h	/^void ipconfig_register_dns(const struct env_set *es);$/;"	p	signature:(const struct env_set *es)
iproute_path	misc.c	/^const char *iproute_path = IPROUTE_PATH; \/* GLOBAL *\/$/;"	v
ipset2ascii	tun.c	/^ipset2ascii(int index)$/;"	f	signature:(int index)
ipset2ascii	tun.h	/^const char *ipset2ascii(int index);$/;"	p	signature:(int index)
ipset2ascii_all	tun.c	/^ipset2ascii_all(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
ipset2ascii_all	tun.h	/^const char *ipset2ascii_all(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
ipset_names	tun.c	/^static const struct ipset_names ipset_names[] = {$/;"	v	typeref:struct:ipset_names	file:
ipset_names	tun.c	/^struct ipset_names {$/;"	s	file:
ipset_names::short_form	tun.c	/^    const char *short_form;$/;"	m	struct:ipset_names	file:	access:public
ipv4_packet_size_verify	proto.c	/^ipv4_packet_size_verify(const uint8_t *data,$/;"	f	signature:(const uint8_t *data, const int size, const int tunnel_type, const char *prefix, counter_type *errors)
ipv4_packet_size_verify	proto.h	/^void ipv4_packet_size_verify(const uint8_t *data,$/;"	p	signature:(const uint8_t *data, const int size, const int tunnel_type, const char *prefix, counter_type *errors)
ipv4_subnet	pf.h	/^struct ipv4_subnet {$/;"	s
ipv4_subnet::exclude	pf.h	/^    bool exclude;$/;"	m	struct:ipv4_subnet	access:public
ipv4_subnet::netmask	pf.h	/^    in_addr_t netmask;$/;"	m	struct:ipv4_subnet	access:public
ipv4_subnet::network	pf.h	/^    in_addr_t network;$/;"	m	struct:ipv4_subnet	access:public
ipv6	pool.h	/^    bool ipv6;$/;"	m	struct:ifconfig_pool	access:public
ipv6_addr_safe	socket.c	/^ipv6_addr_safe(const char *ipv6_text_addr)$/;"	f	signature:(const char *ipv6_text_addr)
ipv6_addr_safe	socket.h	/^bool ipv6_addr_safe(const char *ipv6_text_addr);$/;"	p	signature:(const char *ipv6_text_addr)
ipv6_addr_safe_hexplusbits	options.c	/^ipv6_addr_safe_hexplusbits( const char *ipv6_prefix_spec )$/;"	f	file:	signature:( const char *ipv6_prefix_spec )
iroute	route.h	/^struct iroute {$/;"	s
iroute::netbits	route.h	/^    int netbits;$/;"	m	struct:iroute	access:public
iroute::network	route.h	/^    in_addr_t network;$/;"	m	struct:iroute	access:public
iroute::next	route.h	/^    struct iroute *next;$/;"	m	struct:iroute	typeref:struct:iroute::iroute	access:public
iroute_ipv6	route.h	/^struct iroute_ipv6 {$/;"	s
iroute_ipv6::netbits	route.h	/^    unsigned int netbits;$/;"	m	struct:iroute_ipv6	access:public
iroute_ipv6::network	route.h	/^    struct in6_addr network;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::in6_addr	access:public
iroute_ipv6::next	route.h	/^    struct iroute_ipv6 *next;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::iroute_ipv6	access:public
iroutes	options.h	/^    struct iroute *iroutes;$/;"	m	struct:options	typeref:struct:options::iroute	access:public
iroutes_ipv6	options.h	/^    struct iroute_ipv6 *iroutes_ipv6;                   \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::iroute_ipv6	access:public
is_adapter_up	tun.c	/^is_adapter_up(const struct tuntap *tt, const IP_ADAPTER_INFO *list)$/;"	f	signature:(const struct tuntap *tt, const IP_ADAPTER_INFO *list)
is_adapter_up	tun.h	/^bool is_adapter_up(const struct tuntap *tt, const IP_ADAPTER_INFO *list);$/;"	p	signature:(const struct tuntap *tt, const IP_ADAPTER_INFO *list)
is_dev_type	tun.c	/^is_dev_type(const char *dev, const char *dev_type, const char *match_type)$/;"	f	signature:(const char *dev, const char *dev_type, const char *match_type)
is_dev_type	tun.h	/^bool is_dev_type(const char *dev, const char *dev_type, const char *match_type);$/;"	p	signature:(const char *dev, const char *dev_type, const char *match_type)
is_exit_restart	multi.c	/^is_exit_restart(int sig)$/;"	f	file:	signature:(int sig)
is_hard_reset	ssl.c	/^is_hard_reset(int op, int key_method)$/;"	f	signature:(int op, int key_method)
is_hard_reset	ssl.h	/^bool is_hard_reset(int op, int key_method);$/;"	p	signature:(int op, int key_method)
is_ip_in_adapter_subnet	tun.c	/^is_ip_in_adapter_subnet(const IP_ADAPTER_INFO *ai, const in_addr_t ip, in_addr_t *highest_netmask)$/;"	f	signature:(const IP_ADAPTER_INFO *ai, const in_addr_t ip, in_addr_t *highest_netmask)
is_ip_in_adapter_subnet	tun.h	/^bool is_ip_in_adapter_subnet(const IP_ADAPTER_INFO *ai, const in_addr_t ip, in_addr_t *highest_netmask);$/;"	p	signature:(const IP_ADAPTER_INFO *ai, const in_addr_t ip, in_addr_t *highest_netmask)
is_ipv4	proto.c	/^is_ipv4(int tunnel_type, struct buffer *buf)$/;"	f	signature:(int tunnel_type, struct buffer *buf)
is_ipv4	proto.h	/^bool is_ipv4(int tunnel_type, struct buffer *buf);$/;"	p	signature:(int tunnel_type, struct buffer *buf)
is_ipv6	proto.c	/^is_ipv6(int tunnel_type, struct buffer *buf)$/;"	f	signature:(int tunnel_type, struct buffer *buf)
is_ipv6	proto.h	/^bool is_ipv6(int tunnel_type, struct buffer *buf);$/;"	p	signature:(int tunnel_type, struct buffer *buf)
is_ipv_X	proto.c	/^is_ipv_X( int tunnel_type, struct buffer *buf, int ip_ver )$/;"	f	file:	signature:( int tunnel_type, struct buffer *buf, int ip_ver )
is_mac_mcast_addr	mroute.c	/^is_mac_mcast_addr(const uint8_t *mac)$/;"	f	file:	signature:(const uint8_t *mac)
is_mac_mcast_maddr	mroute.c	/^is_mac_mcast_maddr(const struct mroute_addr *addr)$/;"	f	file:	signature:(const struct mroute_addr *addr)
is_occ_msg	occ.h	/^is_occ_msg(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
is_on_link	route.c	/^is_on_link(const int is_local_route, const unsigned int flags, const struct route_gateway_info *rgi)$/;"	f	file:	signature:(const int is_local_route, const unsigned int flags, const struct route_gateway_info *rgi)
is_openvpn_protocol	ps.c	/^is_openvpn_protocol(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
is_openvpn_protocol	ps.h	/^bool is_openvpn_protocol(const struct buffer *buf);$/;"	p	signature:(const struct buffer *buf)
is_password_env_var	misc.c	/^is_password_env_var(const char *str)$/;"	f	file:	signature:(const char *str)
is_ping_msg	ping.h	/^is_ping_msg(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
is_route_parm_defined	route.c	/^is_route_parm_defined(const char *parm)$/;"	f	file:	signature:(const char *parm)
is_special_addr	route.c	/^is_special_addr(const char *addr_str)$/;"	f	signature:(const char *addr_str)
is_special_addr	route.h	/^bool is_special_addr(const char *addr_str);$/;"	p	signature:(const char *addr_str)
is_tap_win	tun.c	/^is_tap_win(const char *guid, const struct tap_reg *tap_reg)$/;"	f	file:	signature:(const char *guid, const struct tap_reg *tap_reg)
is_tun_p2p	tun.c	/^is_tun_p2p(const struct tuntap *tt)$/;"	f	signature:(const struct tuntap *tt)
is_tun_p2p	tun.h	/^bool is_tun_p2p(const struct tuntap *tt);$/;"	p	signature:(const struct tuntap *tt)
is_utun	tun.h	/^    bool is_utun;$/;"	m	struct:tuntap	access:public
iter	multi.h	/^    struct hash *iter;          \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
iv	list.h	/^    uint32_t iv;$/;"	m	struct:hash	access:public
jfn	ps.c	/^    char *jfn;$/;"	m	struct:proxy_connection	file:	access:public
journal_add	ps.c	/^journal_add(const char *journal_dir, struct proxy_connection *pc, struct proxy_connection *cp)$/;"	f	file:	signature:(const char *journal_dir, struct proxy_connection *pc, struct proxy_connection *cp)
keepalive_ping	options.h	/^    int keepalive_ping;         \/* a proxy for ping\/ping-restart *\/$/;"	m	struct:options	access:public
keepalive_timeout	options.h	/^    int keepalive_timeout;$/;"	m	struct:options	access:public
key	crypto.h	/^struct key$/;"	s
key	list.h	/^    const void *key;$/;"	m	struct:hash_element	access:public
key	ssl_common.h	/^    struct key_state key[KS_SIZE];$/;"	m	struct:tls_session	typeref:struct:tls_session::key_state	access:public
key2	crypto.h	/^struct key2$/;"	s
key2::keys	crypto.h	/^    struct key keys[2];         \/**< Two unidirectional sets of %key$/;"	m	struct:key2	typeref:struct:key2::key	access:public
key2::n	crypto.h	/^    int n;                      \/**< The number of \\c key objects stored$/;"	m	struct:key2	access:public
key2_print	crypto.c	/^key2_print(const struct key2 *k,$/;"	f	signature:(const struct key2 *k, const struct key_type *kt, const char *prefix0, const char *prefix1)
key2_print	crypto.h	/^void key2_print(const struct key2 *k,$/;"	p	signature:(const struct key2 *k, const struct key_type *kt, const char *prefix0, const char *prefix1)
key::cipher	crypto.h	/^    uint8_t cipher[MAX_CIPHER_KEY_LENGTH];$/;"	m	struct:key	access:public
key::hmac	crypto.h	/^    uint8_t hmac[MAX_HMAC_KEY_LENGTH];$/;"	m	struct:key	access:public
key_ctx	crypto.h	/^struct key_ctx$/;"	s
key_ctx::cipher	crypto.h	/^    cipher_ctx_t *cipher;       \/**< Generic cipher %context. *\/$/;"	m	struct:key_ctx	access:public
key_ctx::hmac	crypto.h	/^    hmac_ctx_t *hmac;           \/**< Generic HMAC %context. *\/$/;"	m	struct:key_ctx	access:public
key_ctx::implicit_iv	crypto.h	/^    uint8_t implicit_iv[OPENVPN_MAX_IV_LENGTH];$/;"	m	struct:key_ctx	access:public
key_ctx::implicit_iv_len	crypto.h	/^    size_t implicit_iv_len;     \/**< The length of implicit_iv *\/$/;"	m	struct:key_ctx	access:public
key_ctx_bi	crypto.h	/^    struct key_ctx_bi key_ctx_bi;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::key_ctx_bi	access:public
key_ctx_bi	crypto.h	/^struct key_ctx_bi$/;"	s
key_ctx_bi::decrypt	crypto.h	/^    struct key_ctx decrypt;     \/**< cipher and\/or HMAC contexts for$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx	access:public
key_ctx_bi::encrypt	crypto.h	/^    struct key_ctx encrypt;     \/**< Cipher and\/or HMAC contexts for sending$/;"	m	struct:key_ctx_bi	typeref:struct:key_ctx_bi::key_ctx	access:public
key_ctx_bi::initialized	crypto.h	/^    bool initialized;$/;"	m	struct:key_ctx_bi	access:public
key_ctx_bi_defined	crypto.h	/^key_ctx_bi_defined(const struct key_ctx_bi *key)$/;"	f	signature:(const struct key_ctx_bi *key)
key_ctx_update_implicit_iv	ssl.c	/^key_ctx_update_implicit_iv(struct key_ctx *ctx, uint8_t *key, size_t key_len)$/;"	f	file:	signature:(struct key_ctx *ctx, uint8_t *key, size_t key_len)
key_ctx_update_implicit_iv	ssl.c	/^key_ctx_update_implicit_iv(struct key_ctx *ctx, uint8_t *key, size_t key_len);$/;"	p	file:	signature:(struct key_ctx *ctx, uint8_t *key, size_t key_len)
key_des_check	crypto_backend.h	/^bool key_des_check(uint8_t *key, int key_len, int ndc);$/;"	p	signature:(uint8_t *key, int key_len, int ndc)
key_des_check	crypto_mbedtls.c	/^key_des_check(uint8_t *key, int key_len, int ndc)$/;"	f	signature:(uint8_t *key, int key_len, int ndc)
key_des_check	crypto_openssl.c	/^key_des_check(uint8_t *key, int key_len, int ndc)$/;"	f	signature:(uint8_t *key, int key_len, int ndc)
key_des_fixup	crypto_backend.h	/^void key_des_fixup(uint8_t *key, int key_len, int ndc);$/;"	p	signature:(uint8_t *key, int key_len, int ndc)
key_des_fixup	crypto_mbedtls.c	/^key_des_fixup(uint8_t *key, int key_len, int ndc)$/;"	f	signature:(uint8_t *key, int key_len, int ndc)
key_des_fixup	crypto_openssl.c	/^key_des_fixup(uint8_t *key, int key_len, int ndc)$/;"	f	signature:(uint8_t *key, int key_len, int ndc)
key_des_num_cblocks	crypto_backend.h	/^int key_des_num_cblocks(const cipher_kt_t *kt);$/;"	p	signature:(const cipher_kt_t *kt)
key_des_num_cblocks	crypto_mbedtls.c	/^key_des_num_cblocks(const mbedtls_cipher_info_t *kt)$/;"	f	signature:(const mbedtls_cipher_info_t *kt)
key_des_num_cblocks	crypto_openssl.c	/^key_des_num_cblocks(const EVP_CIPHER *kt)$/;"	f	signature:(const EVP_CIPHER *kt)
key_direction	options.h	/^    int key_direction;$/;"	m	struct:options	access:public
key_direction_state	crypto.h	/^struct key_direction_state$/;"	s
key_direction_state::in_key	crypto.h	/^    int in_key;                 \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state	access:public
key_direction_state::need_keys	crypto.h	/^    int need_keys;              \/**< The number of key objects necessary$/;"	m	struct:key_direction_state	access:public
key_direction_state::out_key	crypto.h	/^    int out_key;                \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state	access:public
key_direction_state_init	crypto.c	/^key_direction_state_init(struct key_direction_state *kds, int key_direction)$/;"	f	signature:(struct key_direction_state *kds, int key_direction)
key_direction_state_init	crypto.h	/^void key_direction_state_init(struct key_direction_state *kds, int key_direction);$/;"	p	signature:(struct key_direction_state *kds, int key_direction)
key_id	ssl_common.h	/^    int key_id;$/;"	m	struct:key_state	access:public
key_id	ssl_common.h	/^    int key_id;$/;"	m	struct:tls_session	access:public
key_is_zero	crypto.c	/^key_is_zero(struct key *key, const struct key_type *kt)$/;"	f	file:	signature:(struct key *key, const struct key_type *kt)
key_method	options.h	/^    int key_method;$/;"	m	struct:options	access:public
key_method	ssl_common.h	/^    int key_method;$/;"	m	struct:tls_options	access:public
key_method_1_read	ssl.c	/^key_method_1_read(struct buffer *buf, struct tls_session *session)$/;"	f	file:	signature:(struct buffer *buf, struct tls_session *session)
key_method_1_write	ssl.c	/^key_method_1_write(struct buffer *buf, struct tls_session *session)$/;"	f	file:	signature:(struct buffer *buf, struct tls_session *session)
key_method_2_read	ssl.c	/^key_method_2_read(struct buffer *buf, struct tls_multi *multi, struct tls_session *session)$/;"	f	file:	signature:(struct buffer *buf, struct tls_multi *multi, struct tls_session *session)
key_method_2_write	ssl.c	/^key_method_2_write(struct buffer *buf, struct tls_session *session)$/;"	f	file:	signature:(struct buffer *buf, struct tls_session *session)
key_pass_file	options.h	/^    const char *key_pass_file;$/;"	m	struct:options	access:public
key_scan	ssl_common.h	/^    struct key_state *key_scan[KEY_SCAN_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state	access:public
key_schedule	openvpn.h	/^struct key_schedule$/;"	s
key_schedule::key_type	openvpn.h	/^    struct key_type key_type;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_type	access:public
key_schedule::ssl_ctx	openvpn.h	/^    struct tls_root_ctx ssl_ctx;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::tls_root_ctx	access:public
key_schedule::static_key	openvpn.h	/^    struct key_ctx_bi static_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi	access:public
key_schedule::tls_auth_key_type	openvpn.h	/^    struct key_type tls_auth_key_type;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_type	access:public
key_schedule::tls_wrap_key	openvpn.h	/^    struct key_ctx_bi tls_wrap_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi	access:public
key_schedule_free	init.c	/^key_schedule_free(struct key_schedule *ks, bool free_ssl_ctx)$/;"	f	file:	signature:(struct key_schedule *ks, bool free_ssl_ctx)
key_source	ssl_common.h	/^struct key_source {$/;"	s
key_source2	ssl_common.h	/^struct key_source2 {$/;"	s
key_source2::client	ssl_common.h	/^    struct key_source client;   \/**< Random provided by client. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source	access:public
key_source2::server	ssl_common.h	/^    struct key_source server;   \/**< Random provided by server. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source	access:public
key_source2_print	ssl.c	/^key_source2_print(const struct key_source2 *k)$/;"	f	file:	signature:(const struct key_source2 *k)
key_source2_randomize_write	ssl.c	/^key_source2_randomize_write(struct key_source2 *k2,$/;"	f	file:	signature:(struct key_source2 *k2, struct buffer *buf, bool server)
key_source2_read	ssl.c	/^key_source2_read(struct key_source2 *k2,$/;"	f	file:	signature:(struct key_source2 *k2, struct buffer *buf, bool server)
key_source::pre_master	ssl_common.h	/^    uint8_t pre_master[48];     \/**< Random used for master secret$/;"	m	struct:key_source	access:public
key_source::random1	ssl_common.h	/^    uint8_t random1[32];        \/**< Seed used for master secret$/;"	m	struct:key_source	access:public
key_source::random2	ssl_common.h	/^    uint8_t random2[32];        \/**< Seed used for key expansion, provided$/;"	m	struct:key_source	access:public
key_source_print	ssl.c	/^key_source_print(const struct key_source *k,$/;"	f	file:	signature:(const struct key_source *k, const char *prefix)
key_spec	cryptoapi.c	/^    DWORD key_spec;$/;"	m	struct:_CAPI_DATA	file:	access:public
key_src	ssl_common.h	/^    struct key_source2 *key_src;       \/* source entropy for key expansion *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_source2	access:public
key_state	ssl_common.h	/^struct key_state$/;"	s
key_state::acf_last_mod	ssl_common.h	/^    time_t acf_last_mod;$/;"	m	struct:key_state	access:public
key_state::ack_write_buf	ssl_common.h	/^    struct buffer ack_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
key_state::auth_control_file	ssl_common.h	/^    char *auth_control_file;$/;"	m	struct:key_state	access:public
key_state::auth_control_status	ssl_common.h	/^    unsigned int auth_control_status;$/;"	m	struct:key_state	access:public
key_state::auth_deferred	ssl_common.h	/^    bool auth_deferred;$/;"	m	struct:key_state	access:public
key_state::auth_deferred_expire	ssl_common.h	/^    time_t auth_deferred_expire;$/;"	m	struct:key_state	access:public
key_state::authenticated	ssl_common.h	/^    bool authenticated;$/;"	m	struct:key_state	access:public
key_state::crypto_options	ssl_common.h	/^    struct crypto_options crypto_options;\/* data channel crypto options *\/$/;"	m	struct:key_state	typeref:struct:key_state::crypto_options	access:public
key_state::established	ssl_common.h	/^    time_t established;         \/* when our state went S_ACTIVE *\/$/;"	m	struct:key_state	access:public
key_state::initial_opcode	ssl_common.h	/^    int initial_opcode;         \/* our initial P_ opcode *\/$/;"	m	struct:key_state	access:public
key_state::key_id	ssl_common.h	/^    int key_id;$/;"	m	struct:key_state	access:public
key_state::key_src	ssl_common.h	/^    struct key_source2 *key_src;       \/* source entropy for key expansion *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_source2	access:public
key_state::ks_ssl	ssl_common.h	/^    struct key_state_ssl ks_ssl; \/* contains SSL object and BIOs for the control channel *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_state_ssl	access:public
key_state::mda_key_id	ssl_common.h	/^    unsigned int mda_key_id;$/;"	m	struct:key_state	access:public
key_state::mda_status	ssl_common.h	/^    unsigned int mda_status;$/;"	m	struct:key_state	access:public
key_state::must_die	ssl_common.h	/^    time_t must_die;            \/* this object is destroyed at this time *\/$/;"	m	struct:key_state	access:public
key_state::must_negotiate	ssl_common.h	/^    time_t must_negotiate;      \/* key negotiation times out if not finished before this time *\/$/;"	m	struct:key_state	access:public
key_state::n_bytes	ssl_common.h	/^    counter_type n_bytes;                \/* how many bytes sent\/recvd since last key exchange *\/$/;"	m	struct:key_state	access:public
key_state::n_packets	ssl_common.h	/^    counter_type n_packets;              \/* how many packets sent\/recvd since last key exchange *\/$/;"	m	struct:key_state	access:public
key_state::paybuf	ssl_common.h	/^    struct buffer_list *paybuf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer_list	access:public
key_state::plaintext_read_buf	ssl_common.h	/^    struct buffer plaintext_read_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
key_state::plaintext_write_buf	ssl_common.h	/^    struct buffer plaintext_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
key_state::rec_ack	ssl_common.h	/^    struct reliable_ack *rec_ack; \/* buffers all packet IDs we want to ACK back to sender *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable_ack	access:public
key_state::rec_reliable	ssl_common.h	/^    struct reliable *rec_reliable; \/* order incoming ciphertext packets before we pass to TLS *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable	access:public
key_state::remote_addr	ssl_common.h	/^    struct link_socket_actual remote_addr; \/* peer's IP addr *\/$/;"	m	struct:key_state	typeref:struct:key_state::link_socket_actual	access:public
key_state::send_reliable	ssl_common.h	/^    struct reliable *send_reliable; \/* holds a copy of outgoing packets until ACK received *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable	access:public
key_state::session_id_remote	ssl_common.h	/^    struct session_id session_id_remote; \/* peer's random session ID *\/$/;"	m	struct:key_state	typeref:struct:key_state::session_id	access:public
key_state::state	ssl_common.h	/^    int state;$/;"	m	struct:key_state	access:public
key_state_export_keying_material	ssl_backend.h	/^key_state_export_keying_material(struct key_state_ssl *ks_ssl,$/;"	p	signature:(struct key_state_ssl *ks_ssl, struct tls_session *session)
key_state_export_keying_material	ssl_mbedtls.c	/^key_state_export_keying_material(struct key_state_ssl *ssl,$/;"	f	signature:(struct key_state_ssl *ssl, struct tls_session *session)
key_state_export_keying_material	ssl_openssl.c	/^key_state_export_keying_material(struct key_state_ssl *ssl,$/;"	f	signature:(struct key_state_ssl *ssl, struct tls_session *session)
key_state_free	ssl.c	/^key_state_free(struct key_state *ks, bool clear)$/;"	f	file:	signature:(struct key_state *ks, bool clear)
key_state_gen_auth_control_file	ssl_verify.c	/^key_state_gen_auth_control_file(struct key_state *ks, const struct tls_options *opt)$/;"	f	file:	signature:(struct key_state *ks, const struct tls_options *opt)
key_state_init	ssl.c	/^key_state_init(struct tls_session *session, struct key_state *ks)$/;"	f	file:	signature:(struct tls_session *session, struct key_state *ks)
key_state_read_ciphertext	ssl_backend.h	/^int key_state_read_ciphertext(struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	p	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf, int maxlen)
key_state_read_ciphertext	ssl_mbedtls.c	/^key_state_read_ciphertext(struct key_state_ssl *ks, struct buffer *buf,$/;"	f	signature:(struct key_state_ssl *ks, struct buffer *buf, int maxlen)
key_state_read_ciphertext	ssl_openssl.c	/^key_state_read_ciphertext(struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	f	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf, int maxlen)
key_state_read_plaintext	ssl_backend.h	/^int key_state_read_plaintext(struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	p	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf, int maxlen)
key_state_read_plaintext	ssl_mbedtls.c	/^key_state_read_plaintext(struct key_state_ssl *ks, struct buffer *buf,$/;"	f	signature:(struct key_state_ssl *ks, struct buffer *buf, int maxlen)
key_state_read_plaintext	ssl_openssl.c	/^key_state_read_plaintext(struct key_state_ssl *ks_ssl, struct buffer *buf,$/;"	f	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf, int maxlen)
key_state_rm_auth_control_file	ssl_verify.c	/^key_state_rm_auth_control_file(struct key_state *ks)$/;"	f	signature:(struct key_state *ks)
key_state_rm_auth_control_file	ssl_verify.h	/^void key_state_rm_auth_control_file(struct key_state *ks);$/;"	p	signature:(struct key_state *ks)
key_state_soft_reset	ssl.c	/^key_state_soft_reset(struct tls_session *session)$/;"	f	file:	signature:(struct tls_session *session)
key_state_ssl	ssl_mbedtls.h	/^struct key_state_ssl {$/;"	s
key_state_ssl	ssl_openssl.h	/^struct key_state_ssl {$/;"	s
key_state_ssl::bio_ctx	ssl_mbedtls.h	/^    bio_ctx bio_ctx;$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ct_in	ssl_openssl.h	/^    BIO *ct_in;                 \/* write ciphertext to here *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ct_out	ssl_openssl.h	/^    BIO *ct_out;                        \/* read ciphertext from here *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ctx	ssl_mbedtls.h	/^    mbedtls_ssl_context *ctx;           \/**< mbedTLS connection context *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ssl	ssl_openssl.h	/^    SSL *ssl;                   \/* SSL object -- new obj created for each new key *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ssl_bio	ssl_openssl.h	/^    BIO *ssl_bio;                       \/* read\/write plaintext from here *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl::ssl_config	ssl_mbedtls.h	/^    mbedtls_ssl_config ssl_config;      \/**< mbedTLS global ssl config *\/$/;"	m	struct:key_state_ssl	access:public
key_state_ssl_free	ssl_backend.h	/^void key_state_ssl_free(struct key_state_ssl *ks_ssl);$/;"	p	signature:(struct key_state_ssl *ks_ssl)
key_state_ssl_free	ssl_mbedtls.c	/^key_state_ssl_free(struct key_state_ssl *ks_ssl)$/;"	f	signature:(struct key_state_ssl *ks_ssl)
key_state_ssl_free	ssl_openssl.c	/^key_state_ssl_free(struct key_state_ssl *ks_ssl)$/;"	f	signature:(struct key_state_ssl *ks_ssl)
key_state_ssl_init	ssl_backend.h	/^void key_state_ssl_init(struct key_state_ssl *ks_ssl,$/;"	p	signature:(struct key_state_ssl *ks_ssl, const struct tls_root_ctx *ssl_ctx, bool is_server, struct tls_session *session)
key_state_ssl_init	ssl_mbedtls.c	/^key_state_ssl_init(struct key_state_ssl *ks_ssl,$/;"	f	signature:(struct key_state_ssl *ks_ssl, const struct tls_root_ctx *ssl_ctx, bool is_server, struct tls_session *session)
key_state_ssl_init	ssl_openssl.c	/^key_state_ssl_init(struct key_state_ssl *ks_ssl, const struct tls_root_ctx *ssl_ctx, bool is_server, struct tls_session *session)$/;"	f	signature:(struct key_state_ssl *ks_ssl, const struct tls_root_ctx *ssl_ctx, bool is_server, struct tls_session *session)
key_state_test_auth_control_file	ssl_verify.c	/^key_state_test_auth_control_file(struct key_state *ks)$/;"	f	file:	signature:(struct key_state *ks)
key_state_write_ciphertext	ssl_backend.h	/^int key_state_write_ciphertext(struct key_state_ssl *ks_ssl,$/;"	p	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf)
key_state_write_ciphertext	ssl_mbedtls.c	/^key_state_write_ciphertext(struct key_state_ssl *ks, struct buffer *buf)$/;"	f	signature:(struct key_state_ssl *ks, struct buffer *buf)
key_state_write_ciphertext	ssl_openssl.c	/^key_state_write_ciphertext(struct key_state_ssl *ks_ssl, struct buffer *buf)$/;"	f	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf)
key_state_write_plaintext	ssl_backend.h	/^int key_state_write_plaintext(struct key_state_ssl *ks_ssl, struct buffer *buf);$/;"	p	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf)
key_state_write_plaintext	ssl_mbedtls.c	/^key_state_write_plaintext(struct key_state_ssl *ks, struct buffer *buf)$/;"	f	signature:(struct key_state_ssl *ks, struct buffer *buf)
key_state_write_plaintext	ssl_openssl.c	/^key_state_write_plaintext(struct key_state_ssl *ks_ssl, struct buffer *buf)$/;"	f	signature:(struct key_state_ssl *ks_ssl, struct buffer *buf)
key_state_write_plaintext_const	ssl_backend.h	/^int key_state_write_plaintext_const(struct key_state_ssl *ks_ssl,$/;"	p	signature:(struct key_state_ssl *ks_ssl, const uint8_t *data, int len)
key_state_write_plaintext_const	ssl_mbedtls.c	/^key_state_write_plaintext_const(struct key_state_ssl *ks, const uint8_t *data, int len)$/;"	f	signature:(struct key_state_ssl *ks, const uint8_t *data, int len)
key_state_write_plaintext_const	ssl_openssl.c	/^key_state_write_plaintext_const(struct key_state_ssl *ks_ssl, const uint8_t *data, int len)$/;"	f	signature:(struct key_state_ssl *ks_ssl, const uint8_t *data, int len)
key_type	crypto.h	/^struct key_type$/;"	s
key_type	openvpn.h	/^    struct key_type key_type;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_type	access:public
key_type	ssl_common.h	/^    struct key_type key_type;$/;"	m	struct:tls_options	typeref:struct:tls_options::key_type	access:public
key_type::cipher	crypto.h	/^    const cipher_kt_t *cipher;  \/**< Cipher static parameters *\/$/;"	m	struct:key_type	access:public
key_type::cipher_length	crypto.h	/^    uint8_t cipher_length;      \/**< Cipher length, in bytes *\/$/;"	m	struct:key_type	access:public
key_type::digest	crypto.h	/^    const md_kt_t *digest;      \/**< Message digest static parameters *\/$/;"	m	struct:key_type	access:public
key_type::hmac_length	crypto.h	/^    uint8_t hmac_length;        \/**< HMAC length, in bytes *\/$/;"	m	struct:key_type	access:public
keyboard_input_available	win32.c	/^keyboard_input_available(struct win32_signal *ws)$/;"	f	file:	signature:(struct win32_signal *ws)
keyboard_ir_to_key	win32.c	/^keyboard_ir_to_key(INPUT_RECORD *ir)$/;"	f	file:	signature:(INPUT_RECORD *ir)
keydirection2ascii	crypto.c	/^keydirection2ascii(int kd, bool remote, bool humanreadable)$/;"	f	signature:(int kd, bool remote, bool humanreadable)
keydirection2ascii	crypto.h	/^const char *keydirection2ascii(int kd, bool remote, bool humanreadable);$/;"	p	signature:(int kd, bool remote, bool humanreadable)
keying_material_exporter_label	options.h	/^    const char *keying_material_exporter_label;$/;"	m	struct:options	access:public
keying_material_exporter_length	options.h	/^    int keying_material_exporter_length;$/;"	m	struct:options	access:public
keys	crypto.h	/^    struct key keys[2];         \/**< Two unidirectional sets of %key$/;"	m	struct:key2	typeref:struct:key2::key	access:public
keysize	openvpn.h	/^    int keysize;                \/**< Data channel keysize from config file *\/$/;"	m	struct:context_1	access:public
keysize	options.h	/^    int keysize;$/;"	m	struct:options	access:public
kill	pf.h	/^    bool kill;$/;"	m	struct:pf_set	access:public
kill_by_addr	manage.h	/^    int (*kill_by_addr) (void *arg, const in_addr_t addr, const int port);$/;"	m	struct:management_callback	access:public
kill_by_cid	manage.h	/^    bool (*kill_by_cid)(void *arg, const unsigned long cid, const char *kill_msg);$/;"	m	struct:management_callback	access:public
kill_by_cn	manage.h	/^    int (*kill_by_cn) (void *arg, const char *common_name);$/;"	m	struct:management_callback	access:public
ks	openvpn.h	/^    struct key_schedule ks;$/;"	m	struct:context_1	typeref:struct:context_1::key_schedule	access:public
ks_ssl	ssl_common.h	/^    struct key_state_ssl ks_ssl; \/* contains SSL object and BIOs for the control channel *\/$/;"	m	struct:key_state	typeref:struct:key_state::key_state_ssl	access:public
lame_duck_must_die	ssl.c	/^lame_duck_must_die(const struct tls_session *session, interval_t *wakeup)$/;"	f	file:	signature:(const struct tls_session *session, interval_t *wakeup)
last	interval.h	/^    time_t last; \/* time of last event *\/$/;"	m	struct:event_timeout	access:public
last	list.h	/^    struct hash_element *last;$/;"	m	struct:hash_iterator	typeref:struct:hash_iterator::hash_element	access:public
last_action	interval.h	/^    time_t last_action;$/;"	m	struct:interval	access:public
last_block	ssl_mbedtls.h	/^    buffer_entry *last_block;$/;"	m	struct:__anon11	access:public
last_call	multi.h	/^    time_t last_call;$/;"	m	struct:multi_reap	access:public
last_reap	packet_id.h	/^    time_t last_reap;         \/* last call of packet_id_reap *\/$/;"	m	struct:packet_id_rec	access:public
last_reference	multi.h	/^    time_t last_reference;$/;"	m	struct:multi_route	access:public
last_release	pool.h	/^    time_t last_release;$/;"	m	struct:ifconfig_pool_entry	access:public
last_test_true	interval.h	/^    time_t last_test_true;$/;"	m	struct:interval	access:public
lastfdreceived	manage.h	/^    int lastfdreceived;$/;"	m	struct:man_connection	access:public
learn_address_script	multi.c	/^learn_address_script(const struct multi_context *m,$/;"	f	file:	signature:(const struct multi_context *m, const struct multi_instance *mi, const char *op, const struct mroute_addr *addr)
learn_address_script	options.h	/^    const char *learn_address_script;$/;"	m	struct:options	access:public
len	buffer.h	/^    int len;                    \/**< Length in bytes of the actual content$/;"	m	struct:buffer	access:public
len	mbuf.h	/^    unsigned int len;$/;"	m	struct:mbuf_set	access:public
len	mroute.h	/^    uint8_t len;    \/* length of address *\/$/;"	m	struct:mroute_addr	access:public
len	options.h	/^    int len;$/;"	m	struct:connection_list	access:public
len	options.h	/^    int len;$/;"	m	struct:remote_list	access:public
len	proto.h	/^    uint16_t len;$/;"	m	struct:openvpn_udphdr	access:public
len	reliable.h	/^    int len;$/;"	m	struct:reliable_ack	access:public
len	socket.h	/^    int len;   \/* -1 if not yet known *\/$/;"	m	struct:stream_buf	access:public
length	ssl_mbedtls.h	/^    size_t length;$/;"	m	struct:_buffer_entry	access:public
lib_name	crypto_backend.h	/^    const char *lib_name;       \/**< Cipher name used by crypto library *\/$/;"	m	struct:__anon16	access:public
libdl_resolve_symbol	plugin.c	/^libdl_resolve_symbol(void *handle, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)$/;"	f	file:	signature:(void *handle, void **dest, const char *symbol, const char *plugin_name, const unsigned int flags)
likely	syshead.h	32;"	d
likely	syshead.h	35;"	d
limit_next	ssl_common.h	/^    int limit_next;             \/* used for traffic shaping on the control channel *\/$/;"	m	struct:tls_session	access:public
link_mtu	mtu.h	/^    int link_mtu;               \/**< Maximum packet size to be sent over$/;"	m	struct:frame	access:public
link_mtu	options.h	/^    int link_mtu;        \/* MTU of device over which tunnel packets pass via TCP\/UDP *\/$/;"	m	struct:connection_entry	access:public
link_mtu_defined	options.h	/^    bool link_mtu_defined; \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry	access:public
link_mtu_dynamic	mtu.h	/^    int link_mtu_dynamic;       \/**< Dynamic MTU value for the external$/;"	m	struct:frame	access:public
link_read_bytes	mstats.h	/^    counter_type link_read_bytes; \/* counter_type can be assumed to be a uint64_t *\/$/;"	m	struct:mmap_stats	access:public
link_read_bytes	openvpn.h	/^    counter_type link_read_bytes;$/;"	m	struct:context_2	access:public
link_read_bytes_auth	openvpn.h	/^    counter_type link_read_bytes_auth;$/;"	m	struct:context_2	access:public
link_read_bytes_global	forward.c	/^counter_type link_read_bytes_global;  \/* GLOBAL *\/$/;"	v
link_socket	openvpn.h	/^    struct link_socket *link_socket;     \/* socket used for TCP\/UDP connection to remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket	access:public
link_socket	socket.h	/^struct link_socket$/;"	s
link_socket::bind_local	socket.h	/^    bool bind_local;$/;"	m	struct:link_socket	access:public
link_socket::ctrl_sd	socket.h	/^    socket_descriptor_t ctrl_sd; \/* only used for UDP over Socks *\/$/;"	m	struct:link_socket	access:public
link_socket::dns_cache	socket.h	/^    struct cached_dns_entry *dns_cache;$/;"	m	struct:link_socket	typeref:struct:link_socket::cached_dns_entry	access:public
link_socket::gremlin	socket.h	/^    int gremlin; \/* --gremlin bits *\/$/;"	m	struct:link_socket	access:public
link_socket::http_proxy	socket.h	/^    struct http_proxy_info *http_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::http_proxy_info	access:public
link_socket::inetd	socket.h	/^    int inetd;$/;"	m	struct:link_socket	access:public
link_socket::info	socket.h	/^    struct link_socket_info info;$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_info	access:public
link_socket::listen_handle	socket.h	/^    struct rw_handle listen_handle; \/* For listening on TCP socket in server mode *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle	access:public
link_socket::listen_persistent_queued	socket.h	/^    bool listen_persistent_queued;$/;"	m	struct:link_socket	access:public
link_socket::local_host	socket.h	/^    const char *local_host;$/;"	m	struct:link_socket	access:public
link_socket::local_port	socket.h	/^    const char *local_port;$/;"	m	struct:link_socket	access:public
link_socket::mark	socket.h	/^    int mark;$/;"	m	struct:link_socket	access:public
link_socket::mode	socket.h	/^    int mode;$/;"	m	struct:link_socket	access:public
link_socket::mtu	socket.h	/^    int mtu;                    \/* OS discovered MTU, or 0 if unknown *\/$/;"	m	struct:link_socket	access:public
link_socket::mtu_discover_type	socket.h	/^    int mtu_discover_type;$/;"	m	struct:link_socket	access:public
link_socket::proxy_dest_host	socket.h	/^    const char *proxy_dest_host;$/;"	m	struct:link_socket	access:public
link_socket::proxy_dest_port	socket.h	/^    const char *proxy_dest_port;$/;"	m	struct:link_socket	access:public
link_socket::ptos	socket.h	/^    int ptos;$/;"	m	struct:link_socket	access:public
link_socket::ptos	socket.h	/^    uint8_t ptos;$/;"	m	struct:link_socket	access:public
link_socket::ptos_defined	socket.h	/^    bool ptos_defined;$/;"	m	struct:link_socket	access:public
link_socket::reads	socket.h	/^    struct overlapped_io reads;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io	access:public
link_socket::remote_host	socket.h	/^    const char *remote_host;$/;"	m	struct:link_socket	access:public
link_socket::remote_port	socket.h	/^    const char *remote_port;$/;"	m	struct:link_socket	access:public
link_socket::resolve_retry_seconds	socket.h	/^    int resolve_retry_seconds;$/;"	m	struct:link_socket	access:public
link_socket::rw_handle	socket.h	/^    struct rw_handle rw_handle;$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle	access:public
link_socket::rwflags_debug	socket.h	/^    unsigned int rwflags_debug;$/;"	m	struct:link_socket	access:public
link_socket::sd	socket.h	/^    socket_descriptor_t sd;$/;"	m	struct:link_socket	access:public
link_socket::server_poll_timeout	socket.h	/^    struct event_timeout *server_poll_timeout;$/;"	m	struct:link_socket	typeref:struct:link_socket::event_timeout	access:public
link_socket::socket_buffer_sizes	socket.h	/^    struct socket_buffer_size socket_buffer_sizes;$/;"	m	struct:link_socket	typeref:struct:link_socket::socket_buffer_size	access:public
link_socket::sockflags	socket.h	/^    unsigned int sockflags;$/;"	m	struct:link_socket	access:public
link_socket::socks_proxy	socket.h	/^    struct socks_proxy_info *socks_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::socks_proxy_info	access:public
link_socket::socks_relay	socket.h	/^    struct link_socket_actual socks_relay; \/* Socks UDP relay address *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_actual	access:public
link_socket::stream_buf	socket.h	/^    struct stream_buf stream_buf;$/;"	m	struct:link_socket	typeref:struct:link_socket::stream_buf	access:public
link_socket::stream_buf_data	socket.h	/^    struct buffer stream_buf_data;$/;"	m	struct:link_socket	typeref:struct:link_socket::buffer	access:public
link_socket::stream_reset	socket.h	/^    bool stream_reset;$/;"	m	struct:link_socket	access:public
link_socket::writes	socket.h	/^    struct overlapped_io writes;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io	access:public
link_socket_actual	socket.h	/^struct link_socket_actual$/;"	s
link_socket_actual::__anon14::in4	socket.h	/^        struct in_pktinfo in4;$/;"	m	union:link_socket_actual::__anon14	typeref:struct:link_socket_actual::__anon14::in_pktinfo	access:public
link_socket_actual::__anon14::in6	socket.h	/^        struct in6_pktinfo in6;$/;"	m	union:link_socket_actual::__anon14	typeref:struct:link_socket_actual::__anon14::in6_pktinfo	access:public
link_socket_actual::dest	socket.h	/^    struct openvpn_sockaddr dest;$/;"	m	struct:link_socket_actual	typeref:struct:link_socket_actual::openvpn_sockaddr	access:public
link_socket_actual::pi	socket.h	/^    } pi;$/;"	m	struct:link_socket_actual	typeref:union:link_socket_actual::__anon14	access:public
link_socket_actual_defined	socket.h	/^link_socket_actual_defined(const struct link_socket_actual *act)$/;"	f	signature:(const struct link_socket_actual *act)
link_socket_actual_match	socket.h	/^link_socket_actual_match(const struct link_socket_actual *a1, const struct link_socket_actual *a2)$/;"	f	signature:(const struct link_socket_actual *a1, const struct link_socket_actual *a2)
link_socket_addr	openvpn.h	/^    struct link_socket_addr link_socket_addr;$/;"	m	struct:context_1	typeref:struct:context_1::link_socket_addr	access:public
link_socket_addr	socket.h	/^struct link_socket_addr$/;"	s
link_socket_addr::actual	socket.h	/^    struct link_socket_actual actual; \/* reply to this address *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::link_socket_actual	access:public
link_socket_addr::bind_local	socket.h	/^    struct addrinfo *bind_local;$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
link_socket_addr::current_remote	socket.h	/^    struct addrinfo *current_remote; \/* remote used in the$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
link_socket_addr::remote_list	socket.h	/^    struct addrinfo *remote_list; \/* complete remote list *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
link_socket_bad_incoming_addr	socket.c	/^link_socket_bad_incoming_addr(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, const struct link_socket_info *info, const struct link_socket_actual *from_addr)
link_socket_bad_incoming_addr	socket.h	/^void link_socket_bad_incoming_addr(struct buffer *buf,$/;"	p	signature:(struct buffer *buf, const struct link_socket_info *info, const struct link_socket_actual *from_addr)
link_socket_bad_outgoing_addr	socket.c	/^link_socket_bad_outgoing_addr(void)$/;"	f	signature:(void)
link_socket_bad_outgoing_addr	socket.h	/^void link_socket_bad_outgoing_addr(void);$/;"	p	signature:(void)
link_socket_close	socket.c	/^link_socket_close(struct link_socket *sock)$/;"	f	signature:(struct link_socket *sock)
link_socket_close	socket.h	/^void link_socket_close(struct link_socket *sock);$/;"	p	signature:(struct link_socket *sock)
link_socket_connection_initiated	socket.c	/^link_socket_connection_initiated(const struct buffer *buf,$/;"	f	signature:(const struct buffer *buf, struct link_socket_info *info, const struct link_socket_actual *act, const char *common_name, struct env_set *es)
link_socket_connection_initiated	socket.h	/^void link_socket_connection_initiated(const struct buffer *buf,$/;"	p	signature:(const struct buffer *buf, struct link_socket_info *info, const struct link_socket_actual *addr, const char *common_name, struct env_set *es)
link_socket_connection_oriented	socket.h	/^link_socket_connection_oriented(const struct link_socket *sock)$/;"	f	signature:(const struct link_socket *sock)
link_socket_current_remote	socket.c	/^link_socket_current_remote(const struct link_socket_info *info)$/;"	f	signature:(const struct link_socket_info *info)
link_socket_current_remote	socket.h	/^in_addr_t link_socket_current_remote(const struct link_socket_info *info);$/;"	p	signature:(const struct link_socket_info *info)
link_socket_current_remote_ipv6	socket.c	/^link_socket_current_remote_ipv6(const struct link_socket_info *info)$/;"	f	signature:(const struct link_socket_info *info)
link_socket_current_remote_ipv6	socket.h	/^const struct in6_addr *link_socket_current_remote_ipv6$/;"	p	signature:(const struct link_socket_info *info)
link_socket_extract_tos	socket.h	/^link_socket_extract_tos(struct link_socket *ls, const struct buffer *ipbuf)$/;"	f	signature:(struct link_socket *ls, const struct buffer *ipbuf)
link_socket_get_outgoing_addr	socket.h	/^link_socket_get_outgoing_addr(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, const struct link_socket_info *info, struct link_socket_actual **act)
link_socket_info	openvpn.h	/^    struct link_socket_info *link_socket_info;$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_info	access:public
link_socket_info	socket.h	/^struct link_socket_info$/;"	s
link_socket_info::af	socket.h	/^    sa_family_t af;                     \/* Address family like AF_INET, AF_INET6 or AF_UNSPEC*\/$/;"	m	struct:link_socket_info	access:public
link_socket_info::bind_ipv6_only	socket.h	/^    bool bind_ipv6_only;$/;"	m	struct:link_socket_info	access:public
link_socket_info::connection_established	socket.h	/^    bool connection_established;$/;"	m	struct:link_socket_info	access:public
link_socket_info::ipchange_command	socket.h	/^    const char *ipchange_command;$/;"	m	struct:link_socket_info	access:public
link_socket_info::lsa	socket.h	/^    struct link_socket_addr *lsa;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::link_socket_addr	access:public
link_socket_info::mtu_changed	socket.h	/^    int mtu_changed;            \/* Set to true when mtu value is changed *\/$/;"	m	struct:link_socket_info	access:public
link_socket_info::plugins	socket.h	/^    const struct plugin_list *plugins;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::plugin_list	access:public
link_socket_info::proto	socket.h	/^    int proto;                  \/* Protocol (PROTO_x defined below) *\/$/;"	m	struct:link_socket_info	access:public
link_socket_info::remote_float	socket.h	/^    bool remote_float;$/;"	m	struct:link_socket_info	access:public
link_socket_init_phase1	socket.c	/^link_socket_init_phase1(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, const char *local_host, const char *local_port, const char *remote_host, const char *remote_port, struct cached_dns_entry *dns_cache, int proto, sa_family_t af, bool bind_ipv6_only, int mode, const struct link_socket *accept_from, struct http_proxy_info *http_proxy, struct socks_proxy_info *socks_proxy, int gremlin, bool bind_local, bool remote_float, int inetd, struct link_socket_addr *lsa, const char *ipchange_command, const struct plugin_list *plugins, int resolve_retry_seconds, int mtu_discover_type, int rcvbuf, int sndbuf, int mark, struct event_timeout *server_poll_timeout, unsigned int sockflags)
link_socket_init_phase1	socket.h	/^link_socket_init_phase1(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, const char *local_host, const char *local_port, const char *remote_host, const char *remote_port, struct cached_dns_entry *dns_cache, int proto, sa_family_t af, bool bind_ipv6_only, int mode, const struct link_socket *accept_from, struct http_proxy_info *http_proxy, struct socks_proxy_info *socks_proxy, int gremlin, bool bind_local, bool remote_float, int inetd, struct link_socket_addr *lsa, const char *ipchange_command, const struct plugin_list *plugins, int resolve_retry_seconds, int mtu_discover_type, int rcvbuf, int sndbuf, int mark, struct event_timeout *server_poll_timeout, unsigned int sockflags)
link_socket_init_phase2	socket.c	/^link_socket_init_phase2(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, const struct frame *frame, struct signal_info *sig_info)
link_socket_init_phase2	socket.h	/^void link_socket_init_phase2(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, const struct frame *frame, struct signal_info *sig_info)
link_socket_new	socket.c	/^link_socket_new(void)$/;"	f	signature:(void)
link_socket_new	socket.h	/^struct link_socket *link_socket_new(void);$/;"	p	signature:(void)
link_socket_owned	openvpn.h	/^    bool link_socket_owned;$/;"	m	struct:context_2	access:public
link_socket_proto_connection_oriented	socket.h	/^link_socket_proto_connection_oriented(int proto)$/;"	f	signature:(int proto)
link_socket_read	socket.h	/^link_socket_read(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from)
link_socket_read_tcp	socket.c	/^link_socket_read_tcp(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf)
link_socket_read_tcp	socket.h	/^int link_socket_read_tcp(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, struct buffer *buf)
link_socket_read_udp_posix	socket.c	/^link_socket_read_udp_posix(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from)
link_socket_read_udp_posix	socket.h	/^int link_socket_read_udp_posix(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from)
link_socket_read_udp_posix_recvmsg	socket.c	/^link_socket_read_udp_posix_recvmsg(struct link_socket *sock,$/;"	f	file:	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from)
link_socket_read_udp_win32	socket.h	/^link_socket_read_udp_win32(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *from)
link_socket_set_outgoing_addr	socket.h	/^link_socket_set_outgoing_addr(const struct buffer *buf,$/;"	f	signature:(const struct buffer *buf, struct link_socket_info *info, const struct link_socket_actual *act, const char *common_name, struct env_set *es)
link_socket_set_tos	socket.h	/^link_socket_set_tos(struct link_socket *ls)$/;"	f	signature:(struct link_socket *ls)
link_socket_update_buffer_sizes	socket.c	/^link_socket_update_buffer_sizes(struct link_socket *ls, int rcvbuf, int sndbuf)$/;"	f	signature:(struct link_socket *ls, int rcvbuf, int sndbuf)
link_socket_update_buffer_sizes	socket.h	/^void link_socket_update_buffer_sizes(struct link_socket *ls, int rcvbuf, int sndbuf);$/;"	p	signature:(struct link_socket *ls, int rcvbuf, int sndbuf)
link_socket_update_flags	socket.c	/^link_socket_update_flags(struct link_socket *ls, unsigned int sockflags)$/;"	f	signature:(struct link_socket *ls, unsigned int sockflags)
link_socket_update_flags	socket.h	/^bool link_socket_update_flags(struct link_socket *ls, unsigned int sockflags);$/;"	p	signature:(struct link_socket *ls, unsigned int sockflags)
link_socket_verify_incoming_addr	socket.h	/^link_socket_verify_incoming_addr(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, const struct link_socket_info *info, const struct link_socket_actual *from_addr)
link_socket_write	socket.h	/^link_socket_write(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_post_size_adjust	forward.c	/^link_socket_write_post_size_adjust(int *size,$/;"	f	file:	signature:(int *size, int size_delta, struct buffer *buf)
link_socket_write_tcp	socket.c	/^link_socket_write_tcp(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_tcp	socket.h	/^int link_socket_write_tcp(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_tcp_posix	socket.h	/^link_socket_write_tcp_posix(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_udp	socket.h	/^link_socket_write_udp(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_udp_posix	socket.h	/^link_socket_write_udp_posix(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_udp_posix_sendmsg	socket.c	/^link_socket_write_udp_posix_sendmsg(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_socket_write_win32	socket.h	/^link_socket_write_win32(struct link_socket *sock,$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to)
link_write_bytes	mstats.h	/^    counter_type link_write_bytes;$/;"	m	struct:mmap_stats	access:public
link_write_bytes	openvpn.h	/^    counter_type link_write_bytes;$/;"	m	struct:context_2	access:public
link_write_bytes_global	forward.c	/^counter_type link_write_bytes_global; \/* GLOBAL *\/$/;"	v
linksock_print_addr	socket.c	/^linksock_print_addr(struct link_socket *sock)$/;"	f	file:	signature:(struct link_socket *sock)
list	buffer.h	/^    struct gc_entry *list;      \/**< First element of the linked list of$/;"	m	struct:gc_arena	typeref:struct:gc_arena::gc_entry	access:public
list	list.h	/^    struct hash_element *list;$/;"	m	struct:hash_bucket	typeref:struct:hash_bucket::hash_element	access:public
list	misc.h	/^    struct env_item *list;$/;"	m	struct:env_set	typeref:struct:env_set::env_item	access:public
list	pf.h	/^    struct pf_cn_elem *list;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::pf_cn_elem	access:public
list	pf.h	/^    struct pf_subnet *list;$/;"	m	struct:pf_subnet_set	typeref:struct:pf_subnet_set::pf_subnet	access:public
list	plugin.h	/^    struct openvpn_plugin_string_list *list[MAX_PLUGINS];$/;"	m	struct:plugin_return	typeref:struct:plugin_return::openvpn_plugin_string_list	access:public
list	pool.h	/^    struct ifconfig_pool_entry *list;$/;"	m	struct:ifconfig_pool	typeref:struct:ifconfig_pool::ifconfig_pool_entry	access:public
list_special	buffer.h	/^    struct gc_entry_special *list_special;$/;"	m	struct:gc_arena	typeref:struct:gc_arena::gc_entry_special	access:public
list_test	list.c	/^list_test(void)$/;"	f	signature:(void)
list_test	list.h	/^void list_test(void);$/;"	p	signature:(void)
listen_handle	socket.h	/^    struct rw_handle listen_handle; \/* For listening on TCP socket in server mode *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle	access:public
listen_persistent_queued	socket.h	/^    bool listen_persistent_queued;$/;"	m	struct:link_socket	access:public
lladdr	options.h	/^    const char *lladdr;$/;"	m	struct:options	access:public
local	manage.h	/^    struct addrinfo *local;$/;"	m	struct:man_settings	typeref:struct:man_settings::addrinfo	access:public
local	multi.h	/^    struct mroute_addr local;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_addr	access:public
local	options.h	/^    const char *local;$/;"	m	struct:connection_entry	access:public
local	tun.h	/^    in_addr_t local;$/;"	m	struct:tuntap	access:public
local_host	socket.h	/^    const char *local_host;$/;"	m	struct:link_socket	access:public
local_ip	manage.h	/^    in_addr_t local_ip;$/;"	m	struct:log_entry	access:public
local_ip6	manage.h	/^    struct in6_addr local_ip6;$/;"	m	struct:log_entry	typeref:struct:log_entry::in6_addr	access:public
local_ipv6	tun.h	/^    struct in6_addr local_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr	access:public
local_options	ssl_common.h	/^    const char *local_options;$/;"	m	struct:tls_options	access:public
local_options_string	ssl.c	/^local_options_string(const struct tls_session *session)$/;"	f	file:	signature:(const struct tls_session *session)
local_port	options.h	/^    const char *local_port;$/;"	m	struct:connection_entry	access:public
local_port	socket.h	/^    const char *local_port;$/;"	m	struct:link_socket	access:public
local_port_defined	options.h	/^    bool local_port_defined;$/;"	m	struct:connection_entry	access:public
local_route	route.c	/^local_route(in_addr_t network,$/;"	f	file:	signature:(in_addr_t network, in_addr_t netmask, in_addr_t gateway, const struct route_gateway_info *rgi)
local_sock	manage.h	/^    struct openvpn_sockaddr local_sock;$/;"	m	struct:log_entry	typeref:struct:log_entry::openvpn_sockaddr	access:public
local_unix	manage.h	/^    struct sockaddr_un local_unix;$/;"	m	struct:man_settings	typeref:struct:man_settings::sockaddr_un	access:public
locked	win32.h	/^    bool locked;$/;"	m	struct:semaphore	access:public
locked_cert_hash_set	ssl_common.h	/^    struct cert_hash_set *locked_cert_hash_set;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::cert_hash_set	access:public
locked_cn	ssl_common.h	/^    char *locked_cn;$/;"	m	struct:tls_multi	access:public
locked_username	ssl_common.h	/^    char *locked_username;$/;"	m	struct:tls_multi	access:public
log	manage.h	/^    struct log_history *log;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
log	options.h	/^    bool log;$/;"	m	struct:options	access:public
log_entry	manage.h	/^struct log_entry$/;"	s
log_entry::local_ip	manage.h	/^    in_addr_t local_ip;$/;"	m	struct:log_entry	access:public
log_entry::local_ip6	manage.h	/^    struct in6_addr local_ip6;$/;"	m	struct:log_entry	typeref:struct:log_entry::in6_addr	access:public
log_entry::local_sock	manage.h	/^    struct openvpn_sockaddr local_sock;$/;"	m	struct:log_entry	typeref:struct:log_entry::openvpn_sockaddr	access:public
log_entry::remote_sock	manage.h	/^    struct openvpn_sockaddr remote_sock;$/;"	m	struct:log_entry	typeref:struct:log_entry::openvpn_sockaddr	access:public
log_entry::string	manage.h	/^    const char *string;$/;"	m	struct:log_entry	access:public
log_entry::timestamp	manage.h	/^    time_t timestamp;$/;"	m	struct:log_entry	access:public
log_entry::u	manage.h	/^    union log_entry_union u;$/;"	m	struct:log_entry	typeref:union:log_entry::log_entry_union	access:public
log_entry_free_contents	manage.c	/^log_entry_free_contents(struct log_entry *e)$/;"	f	file:	signature:(struct log_entry *e)
log_entry_print	manage.c	/^log_entry_print(const struct log_entry *e, unsigned int flags, struct gc_arena *gc)$/;"	f	signature:(const struct log_entry *e, unsigned int flags, struct gc_arena *gc)
log_entry_print	manage.h	/^const char *log_entry_print(const struct log_entry *e, unsigned int flags, struct gc_arena *gc);$/;"	p	signature:(const struct log_entry *e, unsigned int flags, struct gc_arena *gc)
log_entry_union	manage.h	/^union log_entry_union {$/;"	u
log_entry_union::intval	manage.h	/^    int intval;$/;"	m	union:log_entry_union	access:public
log_entry_union::msg_flags	manage.h	/^    unsigned int msg_flags;$/;"	m	union:log_entry_union	access:public
log_entry_union::state	manage.h	/^    int state;$/;"	m	union:log_entry_union	access:public
log_history	manage.h	/^struct log_history$/;"	s
log_history::array	manage.h	/^    struct log_entry *array;$/;"	m	struct:log_history	typeref:struct:log_history::log_entry	access:public
log_history::base	manage.h	/^    int base;$/;"	m	struct:log_history	access:public
log_history::capacity	manage.h	/^    int capacity;$/;"	m	struct:log_history	access:public
log_history::size	manage.h	/^    int size;$/;"	m	struct:log_history	access:public
log_history_add	manage.c	/^log_history_add(struct log_history *h, const struct log_entry *le)$/;"	f	signature:(struct log_history *h, const struct log_entry *le)
log_history_add	manage.h	/^void log_history_add(struct log_history *h, const struct log_entry *le);$/;"	p	signature:(struct log_history *h, const struct log_entry *le)
log_history_cache	manage.h	/^    int log_history_cache;$/;"	m	struct:man_settings	access:public
log_history_capacity	manage.h	/^log_history_capacity(const struct log_history *h)$/;"	f	signature:(const struct log_history *h)
log_history_close	manage.c	/^log_history_close(struct log_history *h)$/;"	f	signature:(struct log_history *h)
log_history_close	manage.h	/^void log_history_close(struct log_history *h);$/;"	p	signature:(struct log_history *h)
log_history_free_contents	manage.c	/^log_history_free_contents(struct log_history *h)$/;"	f	file:	signature:(struct log_history *h)
log_history_init	manage.c	/^log_history_init(const int capacity)$/;"	f	signature:(const int capacity)
log_history_init	manage.h	/^struct log_history *log_history_init(const int capacity);$/;"	p	signature:(const int capacity)
log_history_obj_init	manage.c	/^log_history_obj_init(struct log_history *h, int capacity)$/;"	f	file:	signature:(struct log_history *h, int capacity)
log_history_ref	manage.c	/^log_history_ref(const struct log_history *h, const int index)$/;"	f	signature:(const struct log_history *h, const int index)
log_history_ref	manage.h	/^const struct log_entry *log_history_ref(const struct log_history *h, const int index);$/;"	p	signature:(const struct log_history *h, const int index)
log_history_resize	manage.c	/^log_history_resize(struct log_history *h, const int capacity)$/;"	f	signature:(struct log_history *h, const int capacity)
log_history_resize	manage.h	/^void log_history_resize(struct log_history *h, const int capacity);$/;"	p	signature:(struct log_history *h, const int capacity)
log_history_size	manage.h	/^log_history_size(const struct log_history *h)$/;"	f	signature:(const struct log_history *h)
log_index	manage.c	/^log_index(const struct log_history *h, int i)$/;"	f	file:	signature:(const struct log_history *h, int i)
log_realtime	manage.h	/^    bool log_realtime;$/;"	m	struct:man_connection	access:public
log_rw	openvpn.h	/^    bool log_rw;$/;"	m	struct:context_2	access:public
lookup_by_cid	multi.c	/^lookup_by_cid(struct multi_context *m, const unsigned long cid)$/;"	f	file:	signature:(struct multi_context *m, const unsigned long cid)
lookup_cn_rule	pf.c	/^lookup_cn_rule(struct hash *h, const char *cn, const uint32_t cn_hash)$/;"	f	file:	signature:(struct hash *h, const char *cn, const uint32_t cn_hash)
lower	sig.c	/^    const char *lower;$/;"	m	struct:signame	file:	access:public
lsa	socket.h	/^    struct link_socket_addr *lsa;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::link_socket_addr	access:public
lsteps	schedule.c	/^    int lsteps;$/;"	m	struct:status	file:	access:public
lt	schedule.h	/^    struct schedule_entry *lt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
lz4	comp.h	/^    struct lz4_workspace lz4;$/;"	m	union:compress_workspace_union	typeref:struct:compress_workspace_union::lz4_workspace	access:public
lz4_alg	comp-lz4.c	/^const struct compress_alg lz4_alg = {$/;"	v	typeref:struct:compress_alg
lz4_compress	comp-lz4.c	/^lz4_compress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
lz4_compress_init	comp-lz4.c	/^lz4_compress_init(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lz4_compress_uninit	comp-lz4.c	/^lz4_compress_uninit(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lz4_decompress	comp-lz4.c	/^lz4_decompress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
lz4_workspace	comp-lz4.h	/^struct lz4_workspace$/;"	s
lz4_workspace::dummy	comp-lz4.h	/^    int dummy;$/;"	m	struct:lz4_workspace	access:public
lz4v2_alg	comp-lz4.c	/^const struct compress_alg lz4v2_alg = {$/;"	v	typeref:struct:compress_alg
lz4v2_compress	comp-lz4.c	/^lz4v2_compress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
lz4v2_compress_init	comp-lz4.c	/^lz4v2_compress_init(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lz4v2_decompress	comp-lz4.c	/^lz4v2_decompress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
lzo	comp.h	/^    struct lzo_compress_workspace lzo;$/;"	m	union:compress_workspace_union	typeref:struct:compress_workspace_union::lzo_compress_workspace	access:public
lzo_adaptive_compress	lzo.h	/^struct lzo_adaptive_compress {$/;"	s
lzo_adaptive_compress::compress_state	lzo.h	/^    bool compress_state;$/;"	m	struct:lzo_adaptive_compress	access:public
lzo_adaptive_compress::n_comp	lzo.h	/^    int n_comp;$/;"	m	struct:lzo_adaptive_compress	access:public
lzo_adaptive_compress::n_total	lzo.h	/^    int n_total;$/;"	m	struct:lzo_adaptive_compress	access:public
lzo_adaptive_compress::next	lzo.h	/^    time_t next;$/;"	m	struct:lzo_adaptive_compress	access:public
lzo_adaptive_compress_data	lzo.c	/^lzo_adaptive_compress_data(struct lzo_adaptive_compress *ac, int n_total, int n_comp)$/;"	f	file:	signature:(struct lzo_adaptive_compress *ac, int n_total, int n_comp)
lzo_adaptive_compress_test	lzo.c	/^lzo_adaptive_compress_test(struct lzo_adaptive_compress *ac)$/;"	f	file:	signature:(struct lzo_adaptive_compress *ac)
lzo_alg	lzo.c	/^const struct compress_alg lzo_alg = {$/;"	v	typeref:struct:compress_alg
lzo_compress	lzo.c	/^lzo_compress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
lzo_compress_init	lzo.c	/^lzo_compress_init(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lzo_compress_uninit	lzo.c	/^lzo_compress_uninit(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lzo_compress_workspace	lzo.h	/^struct lzo_compress_workspace$/;"	s
lzo_compress_workspace::ac	lzo.h	/^    struct lzo_adaptive_compress ac;$/;"	m	struct:lzo_compress_workspace	typeref:struct:lzo_compress_workspace::lzo_adaptive_compress	access:public
lzo_compress_workspace::wmem	lzo.h	/^    lzo_voidp wmem;$/;"	m	struct:lzo_compress_workspace	access:public
lzo_compress_workspace::wmem_size	lzo.h	/^    int wmem_size;$/;"	m	struct:lzo_compress_workspace	access:public
lzo_compression_enabled	lzo.c	/^lzo_compression_enabled(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
lzo_decompress	lzo.c	/^lzo_decompress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
m_hEngineHandle	win32.c	/^static HANDLE m_hEngineHandle = NULL; \/* GLOBAL *\/$/;"	v	file:
m_rtm	route.c	/^    struct rt_msghdr m_rtm;$/;"	m	struct:rtmsg	typeref:struct:rtmsg::rt_msghdr	file:	access:public
m_space	route.c	/^    char m_space[512];$/;"	m	struct:rtmsg	file:	access:public
mac_addr_safe	socket.c	/^mac_addr_safe(const char *mac_addr)$/;"	f	signature:(const char *mac_addr)
mac_addr_safe	socket.h	/^bool mac_addr_safe(const char *mac_addr);$/;"	p	signature:(const char *mac_addr)
mac_addr_size	proto.h	/^    uint8_t mac_addr_size;      \/* 0x06 *\/$/;"	m	struct:openvpn_arp	access:public
mac_addr_type	proto.h	/^    uint16_t mac_addr_type;     \/* 0x0001 *\/$/;"	m	struct:openvpn_arp	access:public
mac_dest	proto.h	/^    uint8_t mac_dest[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp	access:public
mac_src	proto.h	/^    uint8_t mac_src[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp	access:public
machine_readable_output	error.c	/^static bool machine_readable_output;   \/* GLOBAL *\/$/;"	v	file:
machine_readable_output	options.h	/^    bool machine_readable_output;$/;"	m	struct:options	access:public
magic	dhcp.h	/^    uint32_t magic;    \/* must be 0x63825363 (network order) *\/$/;"	m	struct:dhcp	access:public
main	openvpn.c	/^main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
make_arg_array	misc.c	/^make_arg_array(const char *first, const char *parms, struct gc_arena *gc)$/;"	f	signature:(const char *first, const char *parms, struct gc_arena *gc)
make_arg_array	misc.h	/^const char **make_arg_array(const char *first, const char *parms, struct gc_arena *gc);$/;"	p	signature:(const char *first, const char *parms, struct gc_arena *gc)
make_arg_copy	misc.c	/^make_arg_copy(char **p, struct gc_arena *gc)$/;"	f	file:	signature:(char **p, struct gc_arena *gc)
make_base64_string	proxy.c	/^make_base64_string(const uint8_t *str, struct gc_arena *gc)$/;"	f	signature:(const uint8_t *str, struct gc_arena *gc)
make_base64_string	proxy.h	/^uint8_t *make_base64_string(const uint8_t *str, struct gc_arena *gc);$/;"	p	signature:(const uint8_t *str, struct gc_arena *gc)
make_base64_string2	proxy.c	/^make_base64_string2(const uint8_t *str, int src_len, struct gc_arena *gc)$/;"	f	signature:(const uint8_t *str, int src_len, struct gc_arena *gc)
make_base64_string2	proxy.h	/^uint8_t *make_base64_string2(const uint8_t *str, int str_len, struct gc_arena *gc);$/;"	p	signature:(const uint8_t *str, int str_len, struct gc_arena *gc)
make_env_array	misc.c	/^make_env_array(const struct env_set *es,$/;"	f	signature:(const struct env_set *es, const bool check_allowed, struct gc_arena *gc)
make_env_array	misc.h	/^const char **make_env_array(const struct env_set *es,$/;"	p	signature:(const struct env_set *es, const bool check_allowed, struct gc_arena *gc)
make_extended_arg_array	misc.c	/^make_extended_arg_array(char **p, struct gc_arena *gc)$/;"	f	signature:(char **p, struct gc_arena *gc)
make_extended_arg_array	misc.h	/^const char **make_extended_arg_array(char **p, struct gc_arena *gc);$/;"	p	signature:(char **p, struct gc_arena *gc)
make_inline_array	misc.c	/^make_inline_array(const char *str, struct gc_arena *gc)$/;"	f	file:	signature:(const char *str, struct gc_arena *gc)
man_accept	manage.c	/^man_accept(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_block	manage.c	/^man_block(struct management *man, volatile int *signal_received, const time_t expire)$/;"	f	file:	signature:(struct management *man, volatile int *signal_received, const time_t expire)
man_bytecount	manage.c	/^man_bytecount(struct management *man, const int update_seconds)$/;"	f	file:	signature:(struct management *man, const int update_seconds)
man_bytecount_output_client	manage.c	/^man_bytecount_output_client(struct management *man)$/;"	f	signature:(struct management *man)
man_bytecount_output_client	manage.h	/^void man_bytecount_output_client(struct management *man);$/;"	p	signature:(struct management *man)
man_bytecount_output_server	manage.c	/^man_bytecount_output_server(struct management *man,$/;"	f	signature:(struct management *man, const counter_type *bytes_in_total, const counter_type *bytes_out_total, struct man_def_auth_context *mdac)
man_bytecount_possible_output_client	manage.h	/^man_bytecount_possible_output_client(struct management *man)$/;"	f	signature:(struct management *man)
man_certificate	manage.c	/^man_certificate(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_check_for_signals	manage.c	/^man_check_for_signals(volatile int *signal_received)$/;"	f	file:	signature:(volatile int *signal_received)
man_check_password	manage.c	/^man_check_password(struct management *man, const char *line)$/;"	f	file:	signature:(struct management *man, const char *line)
man_client_auth	manage.c	/^man_client_auth(struct management *man, const char *cid_str, const char *kid_str, const bool extra)$/;"	f	file:	signature:(struct management *man, const char *cid_str, const char *kid_str, const bool extra)
man_client_deny	manage.c	/^man_client_deny(struct management *man, const char *cid_str, const char *kid_str, const char *reason, const char *client_reason)$/;"	f	file:	signature:(struct management *man, const char *cid_str, const char *kid_str, const char *reason, const char *client_reason)
man_client_kill	manage.c	/^man_client_kill(struct management *man, const char *cid_str, const char *kill_msg)$/;"	f	file:	signature:(struct management *man, const char *cid_str, const char *kill_msg)
man_client_n_clients	manage.c	/^man_client_n_clients(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_client_pf	manage.c	/^man_client_pf(struct management *man, const char *cid_str)$/;"	f	file:	signature:(struct management *man, const char *cid_str)
man_close_socket	manage.c	/^man_close_socket(struct management *man, const socket_descriptor_t sd)$/;"	f	file:	signature:(struct management *man, const socket_descriptor_t sd)
man_connect	manage.c	/^man_connect(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_connection	manage.h	/^struct man_connection {$/;"	s
man_connection::bytecount_last_update	manage.h	/^    time_t bytecount_last_update;$/;"	m	struct:man_connection	access:public
man_connection::bytecount_update_seconds	manage.h	/^    int bytecount_update_seconds;$/;"	m	struct:man_connection	access:public
man_connection::echo_realtime	manage.h	/^    bool echo_realtime;$/;"	m	struct:man_connection	access:public
man_connection::env_filter_level	manage.h	/^    int env_filter_level;$/;"	m	struct:man_connection	access:public
man_connection::es	manage.h	/^    struct event_set *es;$/;"	m	struct:man_connection	typeref:struct:man_connection::event_set	access:public
man_connection::ext_cert_input	manage.h	/^    struct buffer_list *ext_cert_input;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
man_connection::ext_cert_state	manage.h	/^    int ext_cert_state;$/;"	m	struct:man_connection	access:public
man_connection::ext_key_input	manage.h	/^    struct buffer_list *ext_key_input;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
man_connection::ext_key_state	manage.h	/^    int ext_key_state;$/;"	m	struct:man_connection	access:public
man_connection::fdtosend	manage.h	/^    int fdtosend;$/;"	m	struct:man_connection	access:public
man_connection::halt	manage.h	/^    bool halt;$/;"	m	struct:man_connection	access:public
man_connection::in	manage.h	/^    struct command_line *in;$/;"	m	struct:man_connection	typeref:struct:man_connection::command_line	access:public
man_connection::in_extra	manage.h	/^    struct buffer_list *in_extra;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
man_connection::in_extra_cid	manage.h	/^    unsigned long in_extra_cid;$/;"	m	struct:man_connection	access:public
man_connection::in_extra_cmd	manage.h	/^    int in_extra_cmd;$/;"	m	struct:man_connection	access:public
man_connection::in_extra_kid	manage.h	/^    unsigned int in_extra_kid;$/;"	m	struct:man_connection	access:public
man_connection::lastfdreceived	manage.h	/^    int lastfdreceived;$/;"	m	struct:man_connection	access:public
man_connection::log_realtime	manage.h	/^    bool log_realtime;$/;"	m	struct:man_connection	access:public
man_connection::ne32	manage.h	/^    struct net_event_win32 ne32;$/;"	m	struct:man_connection	typeref:struct:man_connection::net_event_win32	access:public
man_connection::out	manage.h	/^    struct buffer_list *out;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
man_connection::password_tries	manage.h	/^    int password_tries;$/;"	m	struct:man_connection	access:public
man_connection::password_verified	manage.h	/^    bool password_verified;$/;"	m	struct:man_connection	access:public
man_connection::remote	manage.h	/^    struct openvpn_sockaddr remote;$/;"	m	struct:man_connection	typeref:struct:man_connection::openvpn_sockaddr	access:public
man_connection::rsa_sig	manage.h	/^    struct buffer_list *rsa_sig;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
man_connection::sd_cli	manage.h	/^    socket_descriptor_t sd_cli;$/;"	m	struct:man_connection	access:public
man_connection::sd_top	manage.h	/^    socket_descriptor_t sd_top;$/;"	m	struct:man_connection	access:public
man_connection::state	manage.h	/^    int state;$/;"	m	struct:man_connection	access:public
man_connection::state_realtime	manage.h	/^    bool state_realtime;$/;"	m	struct:man_connection	access:public
man_connection::up_query	manage.h	/^    struct user_pass up_query;$/;"	m	struct:man_connection	typeref:struct:man_connection::user_pass	access:public
man_connection::up_query_mode	manage.h	/^    int up_query_mode;$/;"	m	struct:man_connection	access:public
man_connection::up_query_type	manage.h	/^    const char *up_query_type;$/;"	m	struct:man_connection	access:public
man_connection_clear	manage.c	/^man_connection_clear(struct man_connection *mc)$/;"	f	file:	signature:(struct man_connection *mc)
man_connection_close	manage.c	/^man_connection_close(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_connection_init	manage.c	/^man_connection_init(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_connection_settings_reset	manage.c	/^man_connection_settings_reset(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_def_auth_context	manage.h	/^struct man_def_auth_context {$/;"	s
man_def_auth_context::bytecount_last_update	manage.h	/^    time_t bytecount_last_update;$/;"	m	struct:man_def_auth_context	access:public
man_def_auth_context::cid	manage.h	/^    unsigned long cid;$/;"	m	struct:man_def_auth_context	access:public
man_def_auth_context::flags	manage.h	/^    unsigned int flags;$/;"	m	struct:man_def_auth_context	access:public
man_def_auth_context::mda_key_id_counter	manage.h	/^    unsigned int mda_key_id_counter;$/;"	m	struct:man_def_auth_context	access:public
man_def_auth_set_client_reason	ssl_verify.c	/^man_def_auth_set_client_reason(struct tls_multi *multi, const char *client_reason)$/;"	f	signature:(struct tls_multi *multi, const char *client_reason)
man_def_auth_set_client_reason	ssl_verify.h	/^void man_def_auth_set_client_reason(struct tls_multi *multi, const char *client_reason);$/;"	p	signature:(struct tls_multi *multi, const char *client_reason)
man_def_auth_test	ssl_verify.c	/^man_def_auth_test(const struct key_state *ks)$/;"	f	file:	signature:(const struct key_state *ks)
man_delete_unix_socket	manage.c	/^man_delete_unix_socket(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_dispatch_command	manage.c	/^man_dispatch_command(struct management *man, struct status_output *so, const char **p, const int nparms)$/;"	f	file:	signature:(struct management *man, struct status_output *so, const char **p, const int nparms)
man_echo	manage.c	/^man_echo(struct management *man, const char *parm)$/;"	f	file:	signature:(struct management *man, const char *parm)
man_env_filter	manage.c	/^man_env_filter(struct management *man, const int level)$/;"	f	file:	signature:(struct management *man, const int level)
man_forget_passwords	manage.c	/^man_forget_passwords(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_help	manage.c	/^man_help(void)$/;"	f	file:	signature:(void)
man_history	manage.c	/^man_history(struct management *man,$/;"	f	file:	signature:(struct management *man, const char *parm, const char *type, struct log_history *log, bool *realtime, const unsigned int lep_flags)
man_hold	manage.c	/^man_hold(struct management *man, const char *cmd)$/;"	f	file:	signature:(struct management *man, const char *cmd)
man_io_error	manage.c	/^man_io_error(struct management *man, const char *prefix)$/;"	f	file:	signature:(struct management *man, const char *prefix)
man_kill	manage.c	/^man_kill(struct management *man, const char *victim)$/;"	f	file:	signature:(struct management *man, const char *victim)
man_listen	manage.c	/^man_listen(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_load_stats	manage.c	/^man_load_stats(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_log	manage.c	/^man_log(struct management *man, const char *parm)$/;"	f	file:	signature:(struct management *man, const char *parm)
man_mod_signal	manage.c	/^man_mod_signal(const struct management *man, const int signum)$/;"	f	file:	signature:(const struct management *man, const int signum)
man_need	manage.c	/^man_need(struct management *man, const char **p, const int n, unsigned int flags)$/;"	f	file:	signature:(struct management *man, const char **p, const int n, unsigned int flags)
man_net	manage.c	/^man_net(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_network_change	manage.c	/^man_network_change(struct management *man, bool samenetwork)$/;"	f	file:	signature:(struct management *man, bool samenetwork)
man_new_connection_post	manage.c	/^man_new_connection_post(struct management *man, const char *description)$/;"	f	file:	signature:(struct management *man, const char *description)
man_output_env	manage.c	/^man_output_env(const struct env_set *es, const bool tail, const int env_filter_level, const char *prefix)$/;"	f	file:	signature:(const struct env_set *es, const bool tail, const int env_filter_level, const char *prefix)
man_output_extra_env	manage.c	/^man_output_extra_env(struct management *man, const char *prefix)$/;"	f	file:	signature:(struct management *man, const char *prefix)
man_output_list_push	manage.c	/^man_output_list_push(struct management *man, const char *str)$/;"	f	file:	signature:(struct management *man, const char *str)
man_output_list_push_finalize	manage.c	/^man_output_list_push_finalize(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_output_list_push_str	manage.c	/^man_output_list_push_str(struct management *man, const char *str)$/;"	f	file:	signature:(struct management *man, const char *str)
man_output_peer_info_env	manage.c	/^man_output_peer_info_env(struct management *man, struct man_def_auth_context *mdac)$/;"	f	file:	signature:(struct management *man, struct man_def_auth_context *mdac)
man_output_standalone	manage.c	/^man_output_standalone(struct management *man, volatile int *signal_received)$/;"	f	file:	signature:(struct management *man, volatile int *signal_received)
man_output_standalone	manage.c	/^static void man_output_standalone(struct management *man, volatile int *signal_received);$/;"	p	file:	signature:(struct management *man, volatile int *signal_received)
man_password_needed	manage.c	/^man_password_needed(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_persist	manage.h	/^struct man_persist {$/;"	s
man_persist::bytes_in	manage.h	/^    counter_type bytes_in;$/;"	m	struct:man_persist	access:public
man_persist::bytes_out	manage.h	/^    counter_type bytes_out;$/;"	m	struct:man_persist	access:public
man_persist::callback	manage.h	/^    struct management_callback callback;$/;"	m	struct:man_persist	typeref:struct:man_persist::management_callback	access:public
man_persist::defined	manage.h	/^    bool defined;$/;"	m	struct:man_persist	access:public
man_persist::echo	manage.h	/^    struct log_history *echo; \/* saved --echo strings *\/$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
man_persist::hold_release	manage.h	/^    bool hold_release;$/;"	m	struct:man_persist	access:public
man_persist::log	manage.h	/^    struct log_history *log;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
man_persist::special_state_msg	manage.h	/^    const char *special_state_msg;$/;"	m	struct:man_persist	access:public
man_persist::standalone_disabled	manage.h	/^    bool standalone_disabled;$/;"	m	struct:man_persist	access:public
man_persist::state	manage.h	/^    struct log_history *state;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
man_persist::vout	manage.h	/^    struct virtual_output vout;$/;"	m	struct:man_persist	typeref:struct:man_persist::virtual_output	access:public
man_persist_close	manage.c	/^man_persist_close(struct man_persist *mp)$/;"	f	file:	signature:(struct man_persist *mp)
man_persist_init	manage.c	/^man_persist_init(struct management *man,$/;"	f	file:	signature:(struct management *man, const int log_history_cache, const int echo_buffer_size, const int state_buffer_size)
man_persist_state	manage.c	/^man_persist_state(unsigned int *persistent, const int n)$/;"	f	file:	signature:(unsigned int *persistent, const int n)
man_pkcs11_id_count	manage.c	/^man_pkcs11_id_count(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_pkcs11_id_get	manage.c	/^man_pkcs11_id_get(struct management *man, const int index)$/;"	f	file:	signature:(struct management *man, const int index)
man_process_command	manage.c	/^man_process_command(struct management *man, const char *line)$/;"	f	file:	signature:(struct management *man, const char *line)
man_prompt	manage.c	/^man_prompt(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_proxy	manage.c	/^man_proxy(struct management *man, const char **p)$/;"	f	file:	signature:(struct management *man, const char **p)
man_query_need_ok	manage.c	/^man_query_need_ok(struct management *man, const char *type, const char *action)$/;"	f	file:	signature:(struct management *man, const char *type, const char *action)
man_query_need_str	manage.c	/^man_query_need_str(struct management *man, const char *type, const char *action)$/;"	f	file:	signature:(struct management *man, const char *type, const char *action)
man_query_password	manage.c	/^man_query_password(struct management *man, const char *type, const char *string)$/;"	f	file:	signature:(struct management *man, const char *type, const char *string)
man_query_user_pass	manage.c	/^man_query_user_pass(struct management *man,$/;"	f	file:	signature:(struct management *man, const char *type, const char *string, const bool needed, const char *prompt, char *dest, int len)
man_query_username	manage.c	/^man_query_username(struct management *man, const char *type, const char *string)$/;"	f	file:	signature:(struct management *man, const char *type, const char *string)
man_read	manage.c	/^man_read(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_record_peer_info	manage.c	/^man_record_peer_info(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_recv_with_fd	manage.c	/^man_recv_with_fd(int fd, void *ptr, size_t nbytes, int flags, int *recvfd)$/;"	f	file:	signature:(int fd, void *ptr, size_t nbytes, int flags, int *recvfd)
man_remote	manage.c	/^man_remote(struct management *man, const char **p)$/;"	f	file:	signature:(struct management *man, const char **p)
man_reset_client_socket	manage.c	/^man_reset_client_socket(struct management *man, const bool exiting)$/;"	f	file:	signature:(struct management *man, const bool exiting)
man_reset_client_socket	manage.c	/^static void man_reset_client_socket(struct management *man, const bool exiting);$/;"	p	file:	signature:(struct management *man, const bool exiting)
man_rsa_sig	manage.c	/^man_rsa_sig(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_send_with_fd	manage.c	/^man_send_with_fd(int fd, void *ptr, size_t nbytes, int flags, int sendfd)$/;"	f	file:	signature:(int fd, void *ptr, size_t nbytes, int flags, int sendfd)
man_settings	manage.h	/^struct man_settings {$/;"	s
man_settings::client_gid	manage.h	/^    int client_gid;$/;"	m	struct:man_settings	access:public
man_settings::client_uid	manage.h	/^    int client_uid;$/;"	m	struct:man_settings	access:public
man_settings::defined	manage.h	/^    bool defined;$/;"	m	struct:man_settings	access:public
man_settings::echo_buffer_size	manage.h	/^    int echo_buffer_size;$/;"	m	struct:man_settings	access:public
man_settings::flags	manage.h	/^    unsigned int flags; \/* MF_x flags *\/$/;"	m	struct:man_settings	access:public
man_settings::local	manage.h	/^    struct addrinfo *local;$/;"	m	struct:man_settings	typeref:struct:man_settings::addrinfo	access:public
man_settings::local_unix	manage.h	/^    struct sockaddr_un local_unix;$/;"	m	struct:man_settings	typeref:struct:man_settings::sockaddr_un	access:public
man_settings::log_history_cache	manage.h	/^    int log_history_cache;$/;"	m	struct:man_settings	access:public
man_settings::management_over_tunnel	manage.h	/^    bool management_over_tunnel;$/;"	m	struct:man_settings	access:public
man_settings::mansig	manage.h	/^    unsigned int mansig;$/;"	m	struct:man_settings	access:public
man_settings::state_buffer_size	manage.h	/^    int state_buffer_size;$/;"	m	struct:man_settings	access:public
man_settings::up	manage.h	/^    struct user_pass up;$/;"	m	struct:man_settings	typeref:struct:man_settings::user_pass	access:public
man_settings::write_peer_info_file	manage.h	/^    char *write_peer_info_file;$/;"	m	struct:man_settings	access:public
man_settings_close	manage.c	/^man_settings_close(struct man_settings *ms)$/;"	f	file:	signature:(struct man_settings *ms)
man_settings_init	manage.c	/^man_settings_init(struct man_settings *ms,$/;"	f	file:	signature:(struct man_settings *ms, const char *addr, const char *port, const char *pass_file, const char *client_user, const char *client_group, const int log_history_cache, const int echo_buffer_size, const int state_buffer_size, const char *write_peer_info_file, const int remap_sigusr1, const unsigned int flags)
man_signal	manage.c	/^man_signal(struct management *man, const char *name)$/;"	f	file:	signature:(struct management *man, const char *name)
man_standalone_event_loop	manage.c	/^man_standalone_event_loop(struct management *man, volatile int *signal_received, const time_t expire)$/;"	f	file:	signature:(struct management *man, volatile int *signal_received, const time_t expire)
man_standalone_ok	manage.c	/^man_standalone_ok(const struct management *man)$/;"	f	file:	signature:(const struct management *man)
man_start_ne32	manage.c	/^man_start_ne32(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_state	manage.c	/^man_state(struct management *man, const char *parm)$/;"	f	file:	signature:(struct management *man, const char *parm)
man_state_name	manage.c	/^man_state_name(const int state)$/;"	f	file:	signature:(const int state)
man_status	manage.c	/^man_status(struct management *man, const int version, struct status_output *so)$/;"	f	file:	signature:(struct management *man, const int version, struct status_output *so)
man_stop_ne32	manage.c	/^man_stop_ne32(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_up_finalize	manage.c	/^man_up_finalize(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_update_io_state	manage.c	/^man_update_io_state(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_verify_unix_peer_uid_gid	manage.c	/^man_verify_unix_peer_uid_gid(struct management *man, const socket_descriptor_t sd)$/;"	f	file:	signature:(struct management *man, const socket_descriptor_t sd)
man_wait_for_client_connection	manage.c	/^man_wait_for_client_connection(struct management *man,$/;"	f	file:	signature:(struct management *man, volatile int *signal_received, const time_t expire, unsigned int flags)
man_welcome	manage.c	/^man_welcome(struct management *man)$/;"	f	file:	signature:(struct management *man)
man_write	manage.c	/^man_write(struct management *man)$/;"	f	file:	signature:(struct management *man)
management	manage.c	/^struct management *management; \/* GLOBAL *\/$/;"	v	typeref:struct:management
management	manage.h	/^struct management$/;"	s
management::connection	manage.h	/^    struct man_connection connection;$/;"	m	struct:management	typeref:struct:management::man_connection	access:public
management::persist	manage.h	/^    struct man_persist persist;$/;"	m	struct:management	typeref:struct:management::man_persist	access:public
management::settings	manage.h	/^    struct man_settings settings;$/;"	m	struct:management	typeref:struct:management::man_settings	access:public
management_addr	options.h	/^    const char *management_addr;$/;"	m	struct:options	access:public
management_android_control	manage.c	/^management_android_control(struct management *man, const char *command, const char *msg)$/;"	f	signature:(struct management *man, const char *command, const char *msg)
management_android_control	manage.h	/^bool management_android_control(struct management *man, const char *command, const char *msg);$/;"	p	signature:(struct management *man, const char *command, const char *msg)
management_auth_failure	manage.c	/^management_auth_failure(struct management *man, const char *type, const char *reason)$/;"	f	signature:(struct management *man, const char *type, const char *reason)
management_auth_failure	manage.h	/^void management_auth_failure(struct management *man, const char *type, const char *reason);$/;"	p	signature:(struct management *man, const char *type, const char *reason)
management_auth_token	manage.c	/^management_auth_token(struct management *man, const char *token)$/;"	f	signature:(struct management *man, const char *token)
management_auth_token	manage.h	/^void management_auth_token(struct management *man, const char *token);$/;"	p	signature:(struct management *man, const char *token)
management_bytes_in	manage.h	/^management_bytes_in(struct management *man, const int size)$/;"	f	signature:(struct management *man, const int size)
management_bytes_in_client	manage.h	/^management_bytes_in_client(struct management *man, const int size)$/;"	f	signature:(struct management *man, const int size)
management_bytes_out	manage.h	/^management_bytes_out(struct management *man, const int size)$/;"	f	signature:(struct management *man, const int size)
management_bytes_out_client	manage.h	/^management_bytes_out_client(struct management *man, const int size)$/;"	f	signature:(struct management *man, const int size)
management_bytes_server	manage.h	/^management_bytes_server(struct management *man,$/;"	f	signature:(struct management *man, const counter_type *bytes_in_total, const counter_type *bytes_out_total, struct man_def_auth_context *mdac)
management_callback	manage.h	/^struct management_callback$/;"	s
management_callback::arg	manage.h	/^    void *arg;$/;"	m	struct:management_callback	access:public
management_callback::client_auth	manage.h	/^    bool (*client_auth) (void *arg,$/;"	m	struct:management_callback	access:public
management_callback::client_pf	manage.h	/^    bool (*client_pf)(void *arg,$/;"	m	struct:management_callback	access:public
management_callback::delete_event	manage.h	/^    void (*delete_event) (void *arg, event_t event);$/;"	m	struct:management_callback	access:public
management_callback::flags	manage.h	/^    unsigned int flags;$/;"	m	struct:management_callback	access:public
management_callback::get_peer_info	manage.h	/^    char *(*get_peer_info) (void *arg, const unsigned long cid);$/;"	m	struct:management_callback	access:public
management_callback::kill_by_addr	manage.h	/^    int (*kill_by_addr) (void *arg, const in_addr_t addr, const int port);$/;"	m	struct:management_callback	access:public
management_callback::kill_by_cid	manage.h	/^    bool (*kill_by_cid)(void *arg, const unsigned long cid, const char *kill_msg);$/;"	m	struct:management_callback	access:public
management_callback::kill_by_cn	manage.h	/^    int (*kill_by_cn) (void *arg, const char *common_name);$/;"	m	struct:management_callback	access:public
management_callback::n_clients	manage.h	/^    int (*n_clients) (void *arg);$/;"	m	struct:management_callback	access:public
management_callback::network_change	manage.h	/^    int (*network_change)(void *arg, bool samenetwork);$/;"	m	struct:management_callback	access:public
management_callback::proxy_cmd	manage.h	/^    bool (*proxy_cmd)(void *arg, const char **p);$/;"	m	struct:management_callback	access:public
management_callback::remote_cmd	manage.h	/^    bool (*remote_cmd) (void *arg, const char **p);$/;"	m	struct:management_callback	access:public
management_callback::show_net	manage.h	/^    void (*show_net) (void *arg, const int msglevel);$/;"	m	struct:management_callback	access:public
management_callback::status	manage.h	/^    void (*status) (void *arg, const int version, struct status_output *so);$/;"	m	struct:management_callback	access:public
management_callback_kill_by_addr	multi.c	/^management_callback_kill_by_addr(void *arg, const in_addr_t addr, const int port)$/;"	f	file:	signature:(void *arg, const in_addr_t addr, const int port)
management_callback_kill_by_cn	multi.c	/^management_callback_kill_by_cn(void *arg, const char *del_cn)$/;"	f	file:	signature:(void *arg, const char *del_cn)
management_callback_n_clients	multi.c	/^management_callback_n_clients(void *arg)$/;"	f	file:	signature:(void *arg)
management_callback_network_change	init.c	/^management_callback_network_change(void *arg, bool samenetwork)$/;"	f	signature:(void *arg, bool samenetwork)
management_callback_proxy_cmd	init.c	/^management_callback_proxy_cmd(void *arg, const char **p)$/;"	f	file:	signature:(void *arg, const char **p)
management_callback_remote_cmd	init.c	/^management_callback_remote_cmd(void *arg, const char **p)$/;"	f	file:	signature:(void *arg, const char **p)
management_callback_status	multi.c	/^management_callback_status(void *arg, const int version, struct status_output *so)$/;"	f	file:	signature:(void *arg, const int version, struct status_output *so)
management_callback_status_p2p	init.c	/^management_callback_status_p2p(void *arg, const int version, struct status_output *so)$/;"	f	file:	signature:(void *arg, const int version, struct status_output *so)
management_certificate	options.h	/^    const char *management_certificate;$/;"	m	struct:options	access:public
management_clear_callback	manage.c	/^management_clear_callback(struct management *man)$/;"	f	signature:(struct management *man)
management_clear_callback	manage.h	/^void management_clear_callback(struct management *man);$/;"	p	signature:(struct management *man)
management_client_auth	multi.c	/^management_client_auth(void *arg,$/;"	f	file:	signature:(void *arg, const unsigned long cid, const unsigned int mda_key_id, const bool auth, const char *reason, const char *client_reason, struct buffer_list *cc_config)
management_client_group	options.h	/^    const char *management_client_group;$/;"	m	struct:options	access:public
management_client_pf	multi.c	/^management_client_pf(void *arg,$/;"	f	file:	signature:(void *arg, const unsigned long cid, struct buffer_list *pf_config)
management_client_user	options.h	/^    const char *management_client_user;$/;"	m	struct:options	access:public
management_close	manage.c	/^management_close(struct management *man)$/;"	f	signature:(struct management *man)
management_close	manage.h	/^void management_close(struct management *man);$/;"	p	signature:(struct management *man)
management_connected	manage.h	/^management_connected(const struct management *man)$/;"	f	signature:(const struct management *man)
management_connection_established	manage.c	/^management_connection_established(struct management *management,$/;"	f	signature:(struct management *management, struct man_def_auth_context *mdac, const struct env_set *es)
management_connection_established	manage.h	/^void management_connection_established(struct management *management,$/;"	p	signature:(struct management *management, struct man_def_auth_context *mdac, const struct env_set *es)
management_delete_event	multi.c	/^management_delete_event(void *arg, event_t event)$/;"	f	file:	signature:(void *arg, event_t event)
management_echo	manage.c	/^management_echo(struct management *man, const char *string, const bool pull)$/;"	f	signature:(struct management *man, const char *string, const bool pull)
management_echo	manage.h	/^void management_echo(struct management *man, const char *string, const bool pull);$/;"	p	signature:(struct management *man, const char *string, const bool pull)
management_echo_buffer_size	options.h	/^    int management_echo_buffer_size;$/;"	m	struct:options	access:public
management_enable_def_auth	manage.h	/^management_enable_def_auth(const struct management *man)$/;"	f	signature:(const struct management *man)
management_enable_pf	manage.h	/^management_enable_pf(const struct management *man)$/;"	f	signature:(const struct management *man)
management_event_loop_n_seconds	manage.c	/^management_event_loop_n_seconds(struct management *man, int sec)$/;"	f	signature:(struct management *man, int sec)
management_event_loop_n_seconds	manage.h	/^void management_event_loop_n_seconds(struct management *man, int sec);$/;"	p	signature:(struct management *man, int sec)
management_flags	options.h	/^    unsigned int management_flags;$/;"	m	struct:options	access:public
management_get_peer_info	multi.c	/^management_get_peer_info(void *arg, const unsigned long cid)$/;"	f	file:	signature:(void *arg, const unsigned long cid)
management_hold	manage.c	/^management_hold(struct management *man, int holdtime)$/;"	f	signature:(struct management *man, int holdtime)
management_hold	manage.h	/^bool management_hold(struct management *man, int holdtime);$/;"	p	signature:(struct management *man, int holdtime)
management_init	manage.c	/^management_init(void)$/;"	f	signature:(void)
management_init	manage.h	/^struct management *management_init(void);$/;"	p	signature:(void)
management_io	manage.c	/^management_io(struct management *man)$/;"	f	signature:(struct management *man)
management_io	manage.h	/^void management_io(struct management *man);$/;"	p	signature:(struct management *man)
management_kill_by_cid	multi.c	/^management_kill_by_cid(void *arg, const unsigned long cid, const char *kill_msg)$/;"	f	file:	signature:(void *arg, const unsigned long cid, const char *kill_msg)
management_learn_addr	manage.c	/^management_learn_addr(struct management *management,$/;"	f	signature:(struct management *management, struct man_def_auth_context *mdac, const struct mroute_addr *addr, const bool primary)
management_learn_addr	manage.h	/^void management_learn_addr(struct management *management,$/;"	p	signature:(struct management *management, struct man_def_auth_context *mdac, const struct mroute_addr *addr, const bool primary)
management_log_history_cache	options.h	/^    int management_log_history_cache;$/;"	m	struct:options	access:public
management_notify	manage.c	/^management_notify(struct management *man, const char *severity, const char *type, const char *text)$/;"	f	signature:(struct management *man, const char *severity, const char *type, const char *text)
management_notify	manage.h	/^void management_notify(struct management *man, const char *severity, const char *type, const char *text);$/;"	p	signature:(struct management *man, const char *severity, const char *type, const char *text)
management_notify_client_close	manage.c	/^management_notify_client_close(struct management *management,$/;"	f	signature:(struct management *management, struct man_def_auth_context *mdac, const struct env_set *es)
management_notify_client_close	manage.h	/^void management_notify_client_close(struct management *management,$/;"	p	signature:(struct management *management, struct man_def_auth_context *mdac, const struct env_set *es)
management_notify_client_needing_auth	manage.c	/^management_notify_client_needing_auth(struct management *management,$/;"	f	signature:(struct management *management, const unsigned int mda_key_id, struct man_def_auth_context *mdac, const struct env_set *es)
management_notify_client_needing_auth	manage.h	/^void management_notify_client_needing_auth(struct management *management,$/;"	p	signature:(struct management *management, const unsigned int auth_id, struct man_def_auth_context *mdac, const struct env_set *es)
management_notify_generic	manage.c	/^management_notify_generic(struct management *man, const char *str)$/;"	f	signature:(struct management *man, const char *str)
management_notify_generic	manage.h	/^void management_notify_generic(struct management *man, const char *str);$/;"	p	signature:(struct management *man, const char *str)
management_open	manage.c	/^management_open(struct management *man,$/;"	f	signature:(struct management *man, const char *addr, const char *port, const char *pass_file, const char *client_user, const char *client_group, const int log_history_cache, const int echo_buffer_size, const int state_buffer_size, const char *write_peer_info_file, const int remap_sigusr1, const unsigned int flags)
management_open	manage.h	/^bool management_open(struct management *man,$/;"	p	signature:(struct management *man, const char *addr, const char *port, const char *pass_file, const char *client_user, const char *client_group, const int log_history_cache, const int echo_buffer_size, const int state_buffer_size, const char *write_peer_info_file, const int remap_sigusr1, const unsigned int flags)
management_over_tunnel	manage.h	/^    bool management_over_tunnel;$/;"	m	struct:man_settings	access:public
management_persist_flags	mtcp.h	/^    unsigned int management_persist_flags;$/;"	m	struct:multi_tcp	access:public
management_port	options.h	/^    const char *management_port;$/;"	m	struct:options	access:public
management_post_tunnel_open	manage.c	/^management_post_tunnel_open(struct management *man, const in_addr_t tun_local_ip)$/;"	f	signature:(struct management *man, const in_addr_t tun_local_ip)
management_post_tunnel_open	manage.h	/^void management_post_tunnel_open(struct management *man, const in_addr_t tun_local_ip);$/;"	p	signature:(struct management *man, const in_addr_t tun_local_ip)
management_pre_tunnel_close	manage.c	/^management_pre_tunnel_close(struct management *man)$/;"	f	signature:(struct management *man)
management_pre_tunnel_close	manage.h	/^void management_pre_tunnel_close(struct management *man);$/;"	p	signature:(struct management *man)
management_query_cert	manage.c	/^management_query_cert(struct management *man, const char *cert_name)$/;"	f	signature:(struct management *man, const char *cert_name)
management_query_cert	manage.h	/^char *management_query_cert(struct management *man, const char *cert_name);$/;"	p	signature:(struct management *man, const char *cert_name)
management_query_multiline	manage.c	/^management_query_multiline(struct management *man,$/;"	f	file:	signature:(struct management *man, const char *b64_data, const char *prompt, const char *cmd, int *state, struct buffer_list **input)
management_query_multiline_flatten	manage.c	/^management_query_multiline_flatten(struct management *man,$/;"	f	file:	signature:(struct management *man, const char *b64_data, const char *prompt, const char *cmd, int *state, struct buffer_list **input)
management_query_multiline_flatten_newline	manage.c	/^management_query_multiline_flatten_newline(struct management *man,$/;"	f	file:	signature:(struct management *man, const char *b64_data, const char *prompt, const char *cmd, int *state, struct buffer_list **input)
management_query_proxy_enabled	manage.h	/^management_query_proxy_enabled(const struct management *man)$/;"	f	signature:(const struct management *man)
management_query_remote_enabled	manage.h	/^management_query_remote_enabled(const struct management *man)$/;"	f	signature:(const struct management *man)
management_query_rsa_sig	manage.c	/^management_query_rsa_sig(struct management *man,$/;"	f	signature:(struct management *man, const char *b64_data)
management_query_rsa_sig	manage.h	/^char *management_query_rsa_sig(struct management *man, const char *b64_data);$/;"	p	signature:(struct management *man, const char *b64_data)
management_query_user_pass	manage.c	/^management_query_user_pass(struct management *man,$/;"	f	signature:(struct management *man, struct user_pass *up, const char *type, const unsigned int flags, const char *static_challenge)
management_query_user_pass	manage.h	/^bool management_query_user_pass(struct management *man,$/;"	p	signature:(struct management *man, struct user_pass *up, const char *type, const unsigned int flags, const char *static_challenge)
management_query_user_pass_enabled	manage.h	/^management_query_user_pass_enabled(const struct management *man)$/;"	f	signature:(const struct management *man)
management_set_callback	manage.c	/^management_set_callback(struct management *man,$/;"	f	signature:(struct management *man, const struct management_callback *cb)
management_set_callback	manage.h	/^void management_set_callback(struct management *man,$/;"	p	signature:(struct management *man, const struct management_callback *cb)
management_set_state	manage.c	/^management_set_state(struct management *man,$/;"	f	signature:(struct management *man, const int state, const char *detail, const in_addr_t *tun_local_ip, const struct in6_addr *tun_local_ip6, const struct openvpn_sockaddr *local, const struct openvpn_sockaddr *remote)
management_set_state	manage.h	/^void management_set_state(struct management *man,$/;"	p	signature:(struct management *man, const int state, const char *detail, const in_addr_t *tun_local_ip, const struct in6_addr *tun_local_ip6, const struct openvpn_sockaddr *local_addr, const struct openvpn_sockaddr *remote_addr)
management_should_daemonize	manage.c	/^management_should_daemonize(struct management *man)$/;"	f	signature:(struct management *man)
management_should_daemonize	manage.h	/^bool management_should_daemonize(struct management *man);$/;"	p	signature:(struct management *man)
management_show_net_callback	init.c	/^management_show_net_callback(void *arg, const int msglevel)$/;"	f	signature:(void *arg, const int msglevel)
management_show_net_callback	init.h	/^void management_show_net_callback(void *arg, const int msglevel);$/;"	p	signature:(void *arg, const int msglevel)
management_sleep	manage.c	/^management_sleep(const int n)$/;"	f	signature:(const int n)
management_sleep	manage.h	/^void management_sleep(const int n);$/;"	p	signature:(const int n)
management_socket_set	manage.c	/^management_socket_set(struct management *man,$/;"	f	signature:(struct management *man, struct event_set *es, void *arg, unsigned int *persistent)
management_socket_set	manage.h	/^void management_socket_set(struct management *man,$/;"	p	signature:(struct management *man, struct event_set *es, void *arg, unsigned int *persistent)
management_state_buffer_size	options.h	/^    int management_state_buffer_size;$/;"	m	struct:options	access:public
management_up_down	manage.c	/^management_up_down(struct management *man, const char *updown, const struct env_set *es)$/;"	f	signature:(struct management *man, const char *updown, const struct env_set *es)
management_up_down	manage.h	/^void management_up_down(struct management *man, const char *updown, const struct env_set *es);$/;"	p	signature:(struct management *man, const char *updown, const struct env_set *es)
management_user_pass	options.h	/^    const char *management_user_pass;$/;"	m	struct:options	access:public
management_would_hold	manage.c	/^management_would_hold(struct management *man)$/;"	f	signature:(struct management *man)
management_would_hold	manage.h	/^bool management_would_hold(struct management *man);$/;"	p	signature:(struct management *man)
management_write_peer_info_file	options.h	/^    const char *management_write_peer_info_file;$/;"	m	struct:options	access:public
managment_android_persisttun_action	manage.c	/^managment_android_persisttun_action(struct management *man)$/;"	f	signature:(struct management *man)
managment_android_persisttun_action	manage.h	/^int managment_android_persisttun_action(struct management *man);$/;"	p	signature:(struct management *man)
mansig	manage.h	/^    unsigned int mansig;$/;"	m	struct:man_settings	access:public
map	fragment.h	/^    unsigned int map;$/;"	m	struct:fragment	access:public
mark	options.h	/^    int mark;$/;"	m	struct:options	access:public
mark	socket.h	/^    int mark;$/;"	m	struct:link_socket	access:public
mask	list.h	/^    int mask;$/;"	m	struct:hash	access:public
max	otime.h	/^    int max;$/;"	m	struct:frequency_limit	access:public
max	perf.c	/^    double max;$/;"	m	struct:perf	file:	access:public
max	route.c	3584;"	d	file:
max	route.c	3958;"	d	file:
max_backtrack_stat	packet_id.h	/^    int max_backtrack_stat;   \/* maximum backtrack seen so far *\/$/;"	m	struct:packet_id_rec	access:public
max_clients	multi.h	/^    int max_clients;$/;"	m	struct:multi_context	access:public
max_clients	options.h	/^    int max_clients;$/;"	m	struct:options	access:public
max_frag_size	fragment.h	/^    int max_frag_size;          \/**< Maximum size of each %fragment. *\/$/;"	m	struct:fragment	access:public
max_int	integer.h	/^max_int(int x, int y)$/;"	f	signature:(int x, int y)
max_queued	mbuf.h	/^    unsigned int max_queued;$/;"	m	struct:mbuf_set	access:public
max_recv_size_local	openvpn.h	/^    int max_recv_size_local;    \/* max packet size received *\/$/;"	m	struct:context_2	access:public
max_recv_size_remote	openvpn.h	/^    int max_recv_size_remote;   \/* max packet size received by remote *\/$/;"	m	struct:context_2	access:public
max_routes_per_client	options.h	/^    int max_routes_per_client;$/;"	m	struct:options	access:public
max_send_size_local	openvpn.h	/^    int max_send_size_local;    \/* max packet size sent *\/$/;"	m	struct:context_2	access:public
max_send_size_remote	openvpn.h	/^    int max_send_size_remote;   \/* max packet size sent by remote *\/$/;"	m	struct:context_2	access:public
max_size	buffer.h	/^    int max_size;            \/* maximum size list should grow to *\/$/;"	m	struct:buffer_list	access:public
maxevents	event.c	/^    int maxevents;$/;"	m	struct:ep_set	file:	access:public
maxevents	mtcp.h	/^    int maxevents;$/;"	m	struct:multi_tcp	access:public
maxfd	event.c	/^    int maxfd;  \/* largest fd seen so far, always < capacity *\/$/;"	m	struct:se_set	file:	access:public
maxlen	socket.h	/^    int maxlen;$/;"	m	struct:stream_buf	access:public
mbed_log_err	crypto_mbedtls.c	/^mbed_log_err(unsigned int flags, int errval, const char *prefix)$/;"	f	signature:(unsigned int flags, int errval, const char *prefix)
mbed_log_err	crypto_mbedtls.h	/^bool mbed_log_err(unsigned int flags, int errval, const char *prefix);$/;"	p	signature:(unsigned int flags, int errval, const char *prefix)
mbed_log_func_line	crypto_mbedtls.c	/^mbed_log_func_line(unsigned int flags, int errval, const char *func,$/;"	f	signature:(unsigned int flags, int errval, const char *func, int line)
mbed_log_func_line	crypto_mbedtls.h	/^bool mbed_log_func_line(unsigned int flags, int errval, const char *func,$/;"	p	signature:(unsigned int flags, int errval, const char *func, int line)
mbed_log_func_line_lite	crypto_mbedtls.h	/^mbed_log_func_line_lite(unsigned int flags, int errval,$/;"	f	signature:(unsigned int flags, int errval, const char *func, int line)
mbed_ok	crypto_mbedtls.h	146;"	d
mbuf	multi.h	/^    struct mbuf_set *mbuf;      \/**< Set of buffers for passing data$/;"	m	struct:multi_context	typeref:struct:multi_context::mbuf_set	access:public
mbuf_add_item	mbuf.c	/^mbuf_add_item(struct mbuf_set *ms, const struct mbuf_item *item)$/;"	f	signature:(struct mbuf_set *ms, const struct mbuf_item *item)
mbuf_add_item	mbuf.h	/^void mbuf_add_item(struct mbuf_set *ms, const struct mbuf_item *item);$/;"	p	signature:(struct mbuf_set *ms, const struct mbuf_item *item)
mbuf_alloc_buf	mbuf.c	/^mbuf_alloc_buf(const struct buffer *buf)$/;"	f	signature:(const struct buffer *buf)
mbuf_alloc_buf	mbuf.h	/^struct mbuf_buffer *mbuf_alloc_buf(const struct buffer *buf);$/;"	p	signature:(const struct buffer *buf)
mbuf_buffer	mbuf.h	/^struct mbuf_buffer$/;"	s
mbuf_buffer::buf	mbuf.h	/^    struct buffer buf;$/;"	m	struct:mbuf_buffer	typeref:struct:mbuf_buffer::buffer	access:public
mbuf_buffer::flags	mbuf.h	/^    unsigned int flags;$/;"	m	struct:mbuf_buffer	access:public
mbuf_buffer::refcount	mbuf.h	/^    int refcount;$/;"	m	struct:mbuf_buffer	access:public
mbuf_defined	mbuf.h	/^mbuf_defined(const struct mbuf_set *ms)$/;"	f	signature:(const struct mbuf_set *ms)
mbuf_dereference_instance	mbuf.c	/^mbuf_dereference_instance(struct mbuf_set *ms, struct multi_instance *mi)$/;"	f	signature:(struct mbuf_set *ms, struct multi_instance *mi)
mbuf_dereference_instance	mbuf.h	/^void mbuf_dereference_instance(struct mbuf_set *ms, struct multi_instance *mi);$/;"	p	signature:(struct mbuf_set *ms, struct multi_instance *mi)
mbuf_extract_item	mbuf.c	/^mbuf_extract_item(struct mbuf_set *ms, struct mbuf_item *item)$/;"	f	signature:(struct mbuf_set *ms, struct mbuf_item *item)
mbuf_extract_item	mbuf.h	/^bool mbuf_extract_item(struct mbuf_set *ms, struct mbuf_item *item);$/;"	p	signature:(struct mbuf_set *ms, struct mbuf_item *item)
mbuf_free	mbuf.c	/^mbuf_free(struct mbuf_set *ms)$/;"	f	signature:(struct mbuf_set *ms)
mbuf_free	mbuf.h	/^void mbuf_free(struct mbuf_set *ms);$/;"	p	signature:(struct mbuf_set *ms)
mbuf_free_buf	mbuf.c	/^mbuf_free_buf(struct mbuf_buffer *mb)$/;"	f	signature:(struct mbuf_buffer *mb)
mbuf_free_buf	mbuf.h	/^void mbuf_free_buf(struct mbuf_buffer *mb);$/;"	p	signature:(struct mbuf_buffer *mb)
mbuf_init	mbuf.c	/^mbuf_init(unsigned int size)$/;"	f	signature:(unsigned int size)
mbuf_init	mbuf.h	/^struct mbuf_set *mbuf_init(unsigned int size);$/;"	p	signature:(unsigned int size)
mbuf_item	mbuf.h	/^struct mbuf_item$/;"	s
mbuf_item::buffer	mbuf.h	/^    struct mbuf_buffer *buffer;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::mbuf_buffer	access:public
mbuf_item::instance	mbuf.h	/^    struct multi_instance *instance;$/;"	m	struct:mbuf_item	typeref:struct:mbuf_item::multi_instance	access:public
mbuf_len	mbuf.h	/^mbuf_len(const struct mbuf_set *ms)$/;"	f	signature:(const struct mbuf_set *ms)
mbuf_maximum_queued	mbuf.h	/^mbuf_maximum_queued(const struct mbuf_set *ms)$/;"	f	signature:(const struct mbuf_set *ms)
mbuf_peek	mbuf.h	/^mbuf_peek(struct mbuf_set *ms)$/;"	f	signature:(struct mbuf_set *ms)
mbuf_peek_dowork	mbuf.c	/^mbuf_peek_dowork(struct mbuf_set *ms)$/;"	f	signature:(struct mbuf_set *ms)
mbuf_set	mbuf.h	/^struct mbuf_set$/;"	s
mbuf_set::array	mbuf.h	/^    struct mbuf_item *array;$/;"	m	struct:mbuf_set	typeref:struct:mbuf_set::mbuf_item	access:public
mbuf_set::capacity	mbuf.h	/^    unsigned int capacity;$/;"	m	struct:mbuf_set	access:public
mbuf_set::head	mbuf.h	/^    unsigned int head;$/;"	m	struct:mbuf_set	access:public
mbuf_set::len	mbuf.h	/^    unsigned int len;$/;"	m	struct:mbuf_set	access:public
mbuf_set::max_queued	mbuf.h	/^    unsigned int max_queued;$/;"	m	struct:mbuf_set	access:public
md_ctx_cleanup	crypto_backend.h	/^void md_ctx_cleanup(md_ctx_t *ctx);$/;"	p	signature:(md_ctx_t *ctx)
md_ctx_cleanup	crypto_mbedtls.c	/^md_ctx_cleanup(mbedtls_md_context_t *ctx)$/;"	f	signature:(mbedtls_md_context_t *ctx)
md_ctx_cleanup	crypto_openssl.c	/^md_ctx_cleanup(EVP_MD_CTX *ctx)$/;"	f	signature:(EVP_MD_CTX *ctx)
md_ctx_final	crypto_backend.h	/^void md_ctx_final(md_ctx_t *ctx, uint8_t *dst);$/;"	p	signature:(md_ctx_t *ctx, uint8_t *dst)
md_ctx_final	crypto_mbedtls.c	/^md_ctx_final(mbedtls_md_context_t *ctx, uint8_t *dst)$/;"	f	signature:(mbedtls_md_context_t *ctx, uint8_t *dst)
md_ctx_final	crypto_openssl.c	/^md_ctx_final(EVP_MD_CTX *ctx, uint8_t *dst)$/;"	f	signature:(EVP_MD_CTX *ctx, uint8_t *dst)
md_ctx_free	crypto_backend.h	/^void md_ctx_free(md_ctx_t *ctx);$/;"	p	signature:(md_ctx_t *ctx)
md_ctx_free	crypto_mbedtls.c	/^void md_ctx_free(mbedtls_md_context_t *ctx)$/;"	f	signature:(mbedtls_md_context_t *ctx)
md_ctx_free	crypto_openssl.c	/^void md_ctx_free(EVP_MD_CTX *ctx)$/;"	f	signature:(EVP_MD_CTX *ctx)
md_ctx_init	crypto_backend.h	/^void md_ctx_init(md_ctx_t *ctx, const md_kt_t *kt);$/;"	p	signature:(md_ctx_t *ctx, const md_kt_t *kt)
md_ctx_init	crypto_mbedtls.c	/^md_ctx_init(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *kt)$/;"	f	signature:(mbedtls_md_context_t *ctx, const mbedtls_md_info_t *kt)
md_ctx_init	crypto_openssl.c	/^md_ctx_init(EVP_MD_CTX *ctx, const EVP_MD *kt)$/;"	f	signature:(EVP_MD_CTX *ctx, const EVP_MD *kt)
md_ctx_new	crypto_backend.h	/^md_ctx_t *md_ctx_new(void);$/;"	p	signature:(void)
md_ctx_new	crypto_mbedtls.c	/^md_ctx_new(void)$/;"	f	signature:(void)
md_ctx_new	crypto_openssl.c	/^md_ctx_new(void)$/;"	f	signature:(void)
md_ctx_size	crypto_backend.h	/^int md_ctx_size(const md_ctx_t *ctx);$/;"	p	signature:(const md_ctx_t *ctx)
md_ctx_size	crypto_mbedtls.c	/^md_ctx_size(const mbedtls_md_context_t *ctx)$/;"	f	signature:(const mbedtls_md_context_t *ctx)
md_ctx_size	crypto_openssl.c	/^md_ctx_size(const EVP_MD_CTX *ctx)$/;"	f	signature:(const EVP_MD_CTX *ctx)
md_ctx_t	crypto_mbedtls.h	/^typedef mbedtls_md_context_t md_ctx_t;$/;"	t
md_ctx_t	crypto_openssl.h	/^typedef EVP_MD_CTX md_ctx_t;$/;"	t
md_ctx_update	crypto_backend.h	/^void md_ctx_update(md_ctx_t *ctx, const uint8_t *src, int src_len);$/;"	p	signature:(md_ctx_t *ctx, const uint8_t *src, int src_len)
md_ctx_update	crypto_mbedtls.c	/^md_ctx_update(mbedtls_md_context_t *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(mbedtls_md_context_t *ctx, const uint8_t *src, int src_len)
md_ctx_update	crypto_openssl.c	/^md_ctx_update(EVP_MD_CTX *ctx, const uint8_t *src, int src_len)$/;"	f	signature:(EVP_MD_CTX *ctx, const uint8_t *src, int src_len)
md_full	crypto_backend.h	/^int md_full(const md_kt_t *kt, const uint8_t *src, int src_len, uint8_t *dst);$/;"	p	signature:(const md_kt_t *kt, const uint8_t *src, int src_len, uint8_t *dst)
md_full	crypto_mbedtls.c	/^md_full(const md_kt_t *kt, const uint8_t *src, int src_len, uint8_t *dst)$/;"	f	signature:(const md_kt_t *kt, const uint8_t *src, int src_len, uint8_t *dst)
md_full	crypto_openssl.c	/^md_full(const EVP_MD *kt, const uint8_t *src, int src_len, uint8_t *dst)$/;"	f	signature:(const EVP_MD *kt, const uint8_t *src, int src_len, uint8_t *dst)
md_kt_get	crypto_backend.h	/^const md_kt_t *md_kt_get(const char *digest);$/;"	p	signature:(const char *digest)
md_kt_get	crypto_mbedtls.c	/^md_kt_get(const char *digest)$/;"	f	signature:(const char *digest)
md_kt_get	crypto_openssl.c	/^md_kt_get(const char *digest)$/;"	f	signature:(const char *digest)
md_kt_name	crypto_backend.h	/^const char *md_kt_name(const md_kt_t *kt);$/;"	p	signature:(const md_kt_t *kt)
md_kt_name	crypto_mbedtls.c	/^md_kt_name(const mbedtls_md_info_t *kt)$/;"	f	signature:(const mbedtls_md_info_t *kt)
md_kt_name	crypto_openssl.c	/^md_kt_name(const EVP_MD *kt)$/;"	f	signature:(const EVP_MD *kt)
md_kt_size	crypto_backend.h	/^int md_kt_size(const md_kt_t *kt);$/;"	p	signature:(const md_kt_t *kt)
md_kt_size	crypto_mbedtls.c	/^md_kt_size(const mbedtls_md_info_t *kt)$/;"	f	signature:(const mbedtls_md_info_t *kt)
md_kt_size	crypto_openssl.c	/^md_kt_size(const EVP_MD *kt)$/;"	f	signature:(const EVP_MD *kt)
md_kt_t	crypto_mbedtls.h	/^typedef mbedtls_md_info_t md_kt_t;$/;"	t
md_kt_t	crypto_openssl.h	/^typedef EVP_MD md_kt_t;$/;"	t
mda_context	openvpn.h	/^    struct man_def_auth_context mda_context;$/;"	m	struct:context_2	typeref:struct:context_2::man_def_auth_context	access:public
mda_context	ssl_common.h	/^    struct man_def_auth_context *mda_context;$/;"	m	struct:tls_options	typeref:struct:tls_options::man_def_auth_context	access:public
mda_key_id	ssl_common.h	/^    unsigned int mda_key_id;$/;"	m	struct:key_state	access:public
mda_key_id_counter	manage.h	/^    unsigned int mda_key_id_counter;$/;"	m	struct:man_def_auth_context	access:public
mda_status	ssl_common.h	/^    unsigned int mda_status;$/;"	m	struct:key_state	access:public
memcmp_constant_time	crypto.h	/^memcmp_constant_time(const void *a, const void *b, size_t size)$/;"	f	signature:(const void *a, const void *b, size_t size)
memstats_fn	options.h	/^    char *memstats_fn;$/;"	m	struct:options	access:public
metric	route.h	/^    const char *metric;         \/* e.g. "5" *\/$/;"	m	struct:route_ipv6_option	access:public
metric	route.h	/^    const char *metric;$/;"	m	struct:route_option	access:public
metric	route.h	/^    int metric;$/;"	m	struct:route_ipv4	access:public
metric	route.h	/^    int metric;$/;"	m	struct:route_ipv6	access:public
metric_names	perf.c	/^static const char *metric_names[] = {$/;"	v	file:
mi_prefix	multi.c	/^mi_prefix(const struct multi_instance *mi)$/;"	f	file:	signature:(const struct multi_instance *mi)
min_int	integer.h	/^min_int(int x, int y)$/;"	f	signature:(int x, int y)
min_version_required	plugin.h	/^    openvpn_plugin_min_version_required_v1 min_version_required;$/;"	m	struct:plugin	access:public
mix	list.c	588;"	d	file:
mlock	options.h	/^    bool mlock;$/;"	m	struct:options	access:public
mmap_fn	mstats.c	/^static char mmap_fn[128];$/;"	v	file:
mmap_stats	mstats.c	/^volatile struct mmap_stats *mmap_stats = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:mmap_stats
mmap_stats	mstats.h	/^struct mmap_stats {$/;"	s
mmap_stats::link_read_bytes	mstats.h	/^    counter_type link_read_bytes; \/* counter_type can be assumed to be a uint64_t *\/$/;"	m	struct:mmap_stats	access:public
mmap_stats::link_write_bytes	mstats.h	/^    counter_type link_write_bytes;$/;"	m	struct:mmap_stats	access:public
mmap_stats::n_clients	mstats.h	/^    int n_clients;$/;"	m	struct:mmap_stats	access:public
mmap_stats::state	mstats.h	/^    int state;$/;"	m	struct:mmap_stats	access:public
mode	openvpn.h	/^    int mode;                   \/**< Role of this context within the$/;"	m	struct:context	access:public
mode	options.h	/^    int mode;$/;"	m	struct:options	access:public
mode	socket.h	/^    int mode;$/;"	m	struct:link_socket	access:public
mode	ssl_common.h	/^    int mode;$/;"	m	struct:tls_options	access:public
mode	ssl_common.h	/^    } mode;                     \/**< Control channel wrapping mode *\/$/;"	m	struct:tls_wrap_ctx	typeref:enum:tls_wrap_ctx::__anon2	access:public
mode	win32.h	/^    int mode;$/;"	m	struct:win32_signal	access:public
module	plugin.h	/^    HMODULE module;$/;"	m	struct:plugin	access:public
modulo_add	integer.h	/^modulo_add(int x, int y, int mod)$/;"	f	signature:(int x, int y, int mod)
modulo_subtract	integer.h	/^modulo_subtract(int x, int y, int mod)$/;"	f	signature:(int x, int y, int mod)
move_session	ssl.c	/^move_session(struct tls_multi *multi, int dest, int src, bool reinit_src)$/;"	f	file:	signature:(struct tls_multi *multi, int dest, int src, bool reinit_src)
mpp_touched	multi.h	/^    struct multi_instance **mpp_touched;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
mroute_addr	mroute.h	/^struct mroute_addr {$/;"	s
mroute_addr::__anon4::__anon5::addr	mroute.h	/^            in_addr_t addr;     \/* _network order_ IPv4 address *\/$/;"	m	struct:mroute_addr::__anon4::__anon5	access:public
mroute_addr::__anon4::__anon5::port	mroute.h	/^            in_port_t port;     \/* _network order_ TCP\/UDP port *\/$/;"	m	struct:mroute_addr::__anon4::__anon5	access:public
mroute_addr::__anon4::__anon6::addr	mroute.h	/^            struct in6_addr addr;$/;"	m	struct:mroute_addr::__anon4::__anon6	typeref:struct:mroute_addr::__anon4::__anon6::in6_addr	access:public
mroute_addr::__anon4::__anon6::port	mroute.h	/^            in_port_t port;     \/* _network order_ TCP\/UDP port *\/$/;"	m	struct:mroute_addr::__anon4::__anon6	access:public
mroute_addr::__anon4::__anon7::addr	mroute.h	/^            in_addr_t addr;     \/* _network order_ IPv4 address *\/$/;"	m	struct:mroute_addr::__anon4::__anon7	access:public
mroute_addr::__anon4::__anon7::prefix	mroute.h	/^            uint8_t prefix[12];$/;"	m	struct:mroute_addr::__anon4::__anon7	access:public
mroute_addr::__anon4::eth_addr	mroute.h	/^        uint8_t eth_addr[OPENVPN_ETH_ALEN];$/;"	m	union:mroute_addr::__anon4	access:public
mroute_addr::__anon4::raw_addr	mroute.h	/^        uint8_t raw_addr[MR_MAX_ADDR_LEN]; \/* actual address *\/$/;"	m	union:mroute_addr::__anon4	access:public
mroute_addr::__anon4::v4	mroute.h	/^        } v4;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon5	access:public
mroute_addr::__anon4::v4mappedv6	mroute.h	/^        } v4mappedv6;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon7	access:public
mroute_addr::__anon4::v6	mroute.h	/^        } v6;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon6	access:public
mroute_addr::len	mroute.h	/^    uint8_t len;    \/* length of address *\/$/;"	m	struct:mroute_addr	access:public
mroute_addr::mroute_union	mroute.h	/^        mroute_union$/;"	m	struct:mroute_addr	typeref:union:mroute_addr::__anon4	access:public
mroute_addr::netbits	mroute.h	/^    uint8_t netbits; \/* number of bits in network part of address,$/;"	m	struct:mroute_addr	access:public
mroute_addr::type	mroute.h	/^    uint8_t type;   \/* MR_ADDR\/MR_WITH flags *\/$/;"	m	struct:mroute_addr	access:public
mroute_addr::unused	mroute.h	/^    uint8_t unused;$/;"	m	struct:mroute_addr	access:public
mroute_addr_compare_function	mroute.c	/^mroute_addr_compare_function(const void *key1, const void *key2)$/;"	f	signature:(const void *key1, const void *key2)
mroute_addr_compare_function	mroute.h	/^bool mroute_addr_compare_function(const void *key1, const void *key2);$/;"	p	signature:(const void *key1, const void *key2)
mroute_addr_equal	mroute.h	/^mroute_addr_equal(const struct mroute_addr *a1, const struct mroute_addr *a2)$/;"	f	signature:(const struct mroute_addr *a1, const struct mroute_addr *a2)
mroute_addr_hash_function	mroute.c	/^mroute_addr_hash_function(const void *key, uint32_t iv)$/;"	f	signature:(const void *key, uint32_t iv)
mroute_addr_hash_function	mroute.h	/^uint32_t mroute_addr_hash_function(const void *key, uint32_t iv);$/;"	p	signature:(const void *key, uint32_t iv)
mroute_addr_hash_len	mroute.h	/^mroute_addr_hash_len(const struct mroute_addr *a)$/;"	f	signature:(const struct mroute_addr *a)
mroute_addr_hash_ptr	mroute.h	/^mroute_addr_hash_ptr(const struct mroute_addr *a)$/;"	f	signature:(const struct mroute_addr *a)
mroute_addr_init	mroute.c	/^mroute_addr_init(struct mroute_addr *addr)$/;"	f	signature:(struct mroute_addr *addr)
mroute_addr_init	mroute.h	/^void mroute_addr_init(struct mroute_addr *addr);$/;"	p	signature:(struct mroute_addr *addr)
mroute_addr_mask_host_bits	mroute.c	/^mroute_addr_mask_host_bits(struct mroute_addr *ma)$/;"	f	signature:(struct mroute_addr *ma)
mroute_addr_mask_host_bits	mroute.h	/^void mroute_addr_mask_host_bits(struct mroute_addr *ma);$/;"	p	signature:(struct mroute_addr *ma)
mroute_addr_print	mroute.c	/^mroute_addr_print(const struct mroute_addr *ma,$/;"	f	signature:(const struct mroute_addr *ma, struct gc_arena *gc)
mroute_addr_print	mroute.h	/^const char *mroute_addr_print(const struct mroute_addr *ma,$/;"	p	signature:(const struct mroute_addr *ma, struct gc_arena *gc)
mroute_addr_print_ex	mroute.c	/^mroute_addr_print_ex(const struct mroute_addr *ma,$/;"	f	signature:(const struct mroute_addr *ma, const unsigned int flags, struct gc_arena *gc)
mroute_addr_print_ex	mroute.h	/^const char *mroute_addr_print_ex(const struct mroute_addr *ma,$/;"	p	signature:(const struct mroute_addr *ma, const unsigned int flags, struct gc_arena *gc)
mroute_addr_reset	mroute.h	/^mroute_addr_reset(struct mroute_addr *ma)$/;"	f	signature:(struct mroute_addr *ma)
mroute_extract_addr_arp	mroute.c	/^mroute_extract_addr_arp(struct mroute_addr *src,$/;"	f	file:	signature:(struct mroute_addr *src, struct mroute_addr *dest, const struct buffer *buf)
mroute_extract_addr_ether	mroute.c	/^mroute_extract_addr_ether(struct mroute_addr *src,$/;"	f	signature:(struct mroute_addr *src, struct mroute_addr *dest, struct mroute_addr *esrc, struct mroute_addr *edest, const struct buffer *buf)
mroute_extract_addr_from_packet	mroute.h	/^mroute_extract_addr_from_packet(struct mroute_addr *src,$/;"	f	signature:(struct mroute_addr *src, struct mroute_addr *dest, struct mroute_addr *esrc, struct mroute_addr *edest, const struct buffer *buf, int tunnel_type)
mroute_extract_addr_ip	mroute.c	/^mroute_extract_addr_ip(struct mroute_addr *src, struct mroute_addr *dest,$/;"	f	signature:(struct mroute_addr *src, struct mroute_addr *dest, const struct buffer *buf)
mroute_extract_in_addr_t	mroute.h	/^mroute_extract_in_addr_t(struct mroute_addr *dest, const in_addr_t src)$/;"	f	signature:(struct mroute_addr *dest, const in_addr_t src)
mroute_extract_openvpn_sockaddr	mroute.c	/^mroute_extract_openvpn_sockaddr(struct mroute_addr *addr,$/;"	f	signature:(struct mroute_addr *addr, const struct openvpn_sockaddr *osaddr, bool use_port)
mroute_extract_openvpn_sockaddr	mroute.h	/^bool mroute_extract_openvpn_sockaddr(struct mroute_addr *addr,$/;"	p	signature:(struct mroute_addr *addr, const struct openvpn_sockaddr *osaddr, bool use_port)
mroute_get_in6_addr	mroute.c	/^mroute_get_in6_addr(struct mroute_addr *ma, const struct in6_addr src, unsigned int mask)$/;"	f	file:	signature:(struct mroute_addr *ma, const struct in6_addr src, unsigned int mask)
mroute_get_in_addr_t	mroute.c	/^mroute_get_in_addr_t(struct mroute_addr *ma, const in_addr_t src, unsigned int mask)$/;"	f	file:	signature:(struct mroute_addr *ma, const in_addr_t src, unsigned int mask)
mroute_helper	mroute.h	/^struct mroute_helper {$/;"	s
mroute_helper::ageable_ttl_secs	mroute.h	/^    int ageable_ttl_secs;        \/* host route cache entry time-to-live*\/$/;"	m	struct:mroute_helper	access:public
mroute_helper::cache_generation	mroute.h	/^    unsigned int cache_generation; \/* incremented when route added *\/$/;"	m	struct:mroute_helper	access:public
mroute_helper::n_net_len	mroute.h	/^    int n_net_len;               \/* length of net_len array *\/$/;"	m	struct:mroute_helper	access:public
mroute_helper::net_len	mroute.h	/^    uint8_t net_len[MR_HELPER_NET_LEN];    \/* CIDR netlengths in descending order *\/$/;"	m	struct:mroute_helper	access:public
mroute_helper::net_len_refcount	mroute.h	/^    int net_len_refcount[MR_HELPER_NET_LEN]; \/* refcount of each netlength *\/$/;"	m	struct:mroute_helper	access:public
mroute_helper_add_iroute46	mroute.c	/^mroute_helper_add_iroute46(struct mroute_helper *mh, int netbits)$/;"	f	signature:(struct mroute_helper *mh, int netbits)
mroute_helper_add_iroute46	mroute.h	/^void mroute_helper_add_iroute46(struct mroute_helper *mh, int netbits);$/;"	p	signature:(struct mroute_helper *mh, int netbits)
mroute_helper_del_iroute46	mroute.c	/^mroute_helper_del_iroute46(struct mroute_helper *mh, int netbits)$/;"	f	signature:(struct mroute_helper *mh, int netbits)
mroute_helper_del_iroute46	mroute.h	/^void mroute_helper_del_iroute46(struct mroute_helper *mh, int netbits);$/;"	p	signature:(struct mroute_helper *mh, int netbits)
mroute_helper_free	mroute.c	/^mroute_helper_free(struct mroute_helper *mh)$/;"	f	signature:(struct mroute_helper *mh)
mroute_helper_free	mroute.h	/^void mroute_helper_free(struct mroute_helper *mh);$/;"	p	signature:(struct mroute_helper *mh)
mroute_helper_init	mroute.c	/^mroute_helper_init(int ageable_ttl_secs)$/;"	f	signature:(int ageable_ttl_secs)
mroute_helper_init	mroute.h	/^struct mroute_helper *mroute_helper_init(int ageable_ttl_secs);$/;"	p	signature:(int ageable_ttl_secs)
mroute_helper_regenerate	mroute.c	/^mroute_helper_regenerate(struct mroute_helper *mh)$/;"	f	file:	signature:(struct mroute_helper *mh)
mroute_is_mcast	mroute.c	/^mroute_is_mcast(const in_addr_t addr)$/;"	f	file:	signature:(const in_addr_t addr)
mroute_is_mcast_ipv6	mroute.c	/^mroute_is_mcast_ipv6(const struct in6_addr addr)$/;"	f	file:	signature:(const struct in6_addr addr)
mroute_learnable_address	mroute.c	/^mroute_learnable_address(const struct mroute_addr *addr, struct gc_arena *gc)$/;"	f	signature:(const struct mroute_addr *addr, struct gc_arena *gc)
mroute_learnable_address	mroute.h	/^bool mroute_learnable_address(const struct mroute_addr *addr,$/;"	p	signature:(const struct mroute_addr *addr, struct gc_arena *gc)
mroute_union	mroute.h	/^        mroute_union$/;"	m	struct:mroute_addr	typeref:union:mroute_addr::__anon4	access:public
ms_error_text	cryptoapi.c	/^ms_error_text(DWORD ms_err)$/;"	f	file:	signature:(DWORD ms_err)
msg	error.h	151;"	d
msg	error.h	159;"	d
msg	error.h	173;"	d
msg_channel	options.h	/^    HANDLE msg_channel;$/;"	m	struct:options	access:public
msg_channel	tun.h	/^    HANDLE msg_channel;$/;"	m	struct:tuntap_options	access:public
msg_flags	manage.h	/^    unsigned int msg_flags;$/;"	m	union:log_entry_union	access:public
msg_flags_string	error.c	/^msg_flags_string(const unsigned int flags, struct gc_arena *gc)$/;"	f	signature:(const unsigned int flags, struct gc_arena *gc)
msg_flags_string	error.h	/^const char *msg_flags_string(const unsigned int flags, struct gc_arena *gc);$/;"	p	signature:(const unsigned int flags, struct gc_arena *gc)
msg_forked	error.c	/^msg_forked(void)$/;"	f	signature:(void)
msg_forked	error.h	/^void msg_forked(void);$/;"	p	signature:(void)
msg_fp	error.c	/^msg_fp(const unsigned int flags)$/;"	f	signature:(const unsigned int flags)
msg_fp	error.h	/^FILE *msg_fp(const unsigned int flags);$/;"	p	signature:(const unsigned int flags)
msg_get_prefix	error.h	/^msg_get_prefix(void)$/;"	f	signature:(void)
msg_get_virtual_output	error.h	/^msg_get_virtual_output(void)$/;"	f	signature:(void)
msg_prefix	multi.h	/^    char msg_prefix[MULTI_PREFIX_MAX_LENGTH];$/;"	m	struct:multi_instance	access:public
msg_set_prefix	error.h	/^msg_set_prefix(const char *prefix)$/;"	f	signature:(const char *prefix)
msg_set_virtual_output	error.h	/^msg_set_virtual_output(const struct virtual_output *vo)$/;"	f	signature:(const struct virtual_output *vo)
msg_test	error.h	/^msg_test(unsigned int flags)$/;"	f	signature:(unsigned int flags)
msg_thread_init	error.h	/^void msg_thread_init(void);$/;"	p	signature:(void)
msg_thread_uninit	error.h	/^void msg_thread_uninit(void);$/;"	p	signature:(void)
msgfp	error.c	/^static FILE *msgfp;         \/* GLOBAL *\/$/;"	v	file:
msglevel	status.h	/^    int msglevel;$/;"	m	struct:status_output	access:public
msglevel_forward_compatible	options.c	/^msglevel_forward_compatible(struct options *options, const int msglevel)$/;"	f	file:	signature:(struct options *options, const int msglevel)
mss_fixup_dowork	mss.c	/^mss_fixup_dowork(struct buffer *buf, uint16_t maxmss)$/;"	f	signature:(struct buffer *buf, uint16_t maxmss)
mss_fixup_dowork	mss.h	/^void mss_fixup_dowork(struct buffer *buf, uint16_t maxmss);$/;"	p	signature:(struct buffer *buf, uint16_t maxmss)
mss_fixup_ipv4	mss.c	/^mss_fixup_ipv4(struct buffer *buf, int maxmss)$/;"	f	signature:(struct buffer *buf, int maxmss)
mss_fixup_ipv4	mss.h	/^void mss_fixup_ipv4(struct buffer *buf, int maxmss);$/;"	p	signature:(struct buffer *buf, int maxmss)
mss_fixup_ipv6	mss.c	/^mss_fixup_ipv6(struct buffer *buf, int maxmss)$/;"	f	signature:(struct buffer *buf, int maxmss)
mss_fixup_ipv6	mss.h	/^void mss_fixup_ipv6(struct buffer *buf, int maxmss);$/;"	p	signature:(struct buffer *buf, int maxmss)
mssfix	options.h	/^    int mssfix;          \/* Upper bound on TCP MSS *\/$/;"	m	struct:connection_entry	access:public
mssfix_default	options.h	/^    bool mssfix_default; \/* true if --mssfix was supplied without a parameter *\/$/;"	m	struct:connection_entry	access:public
mstats_close	mstats.c	/^mstats_close(void)$/;"	f	signature:(void)
mstats_close	mstats.h	/^void mstats_close(void);$/;"	p	signature:(void)
mstats_open	mstats.c	/^mstats_open(const char *fn)$/;"	f	signature:(const char *fn)
mstats_open	mstats.h	/^void mstats_open(const char *fn);$/;"	p	signature:(const char *fn)
mtcp	multi.h	/^    struct multi_tcp *mtcp;     \/**< State specific to OpenVPN using TCP$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_tcp	access:public
mtu	socket.h	/^    int mtu;                    \/* OS discovered MTU, or 0 if unknown *\/$/;"	m	struct:link_socket	access:public
mtu_changed	socket.h	/^    int mtu_changed;            \/* Set to true when mtu value is changed *\/$/;"	m	struct:link_socket_info	access:public
mtu_discover_type	options.h	/^    int mtu_discover_type; \/* used if OS supports setting Path MTU discovery options on socket *\/$/;"	m	struct:connection_entry	access:public
mtu_discover_type	socket.h	/^    int mtu_discover_type;$/;"	m	struct:link_socket	access:public
mtu_load_test	occ.h	/^struct mtu_load_test$/;"	s
mtu_load_test::delta	occ.h	/^    int delta;                  \/* determine packet size to send by using$/;"	m	struct:mtu_load_test	access:public
mtu_load_test::op	occ.h	/^    int op;                     \/* OCC opcode to send to peer *\/$/;"	m	struct:mtu_load_test	access:public
mtu_load_test_sequence	occ.c	/^static const struct mtu_load_test mtu_load_test_sequence[] = {$/;"	v	typeref:struct:mtu_load_test	file:
mtu_test	options.h	/^    bool mtu_test;$/;"	m	struct:options	access:public
multi_add_iroutes	multi.c	/^multi_add_iroutes(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_add_mbuf	multi.c	/^multi_add_mbuf(struct multi_context *m,$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi, struct mbuf_buffer *mb)
multi_add_mbuf	multi.h	/^void multi_add_mbuf(struct multi_context *m,$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi, struct mbuf_buffer *mb)
multi_bcast	multi.c	/^multi_bcast(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, const struct buffer *buf, const struct multi_instance *sender_instance, const struct mroute_addr *sender_addr)
multi_client_connect_mda	multi.c	/^multi_client_connect_mda(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const struct buffer_list *config, unsigned int option_permissions_mask, unsigned int *option_types_found)
multi_client_connect_post	multi.c	/^multi_client_connect_post(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const char *dc_file, unsigned int option_permissions_mask, unsigned int *option_types_found)
multi_client_connect_post_plugin	multi.c	/^multi_client_connect_post_plugin(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const struct plugin_return *pr, unsigned int option_permissions_mask, unsigned int *option_types_found)
multi_client_connect_setenv	multi.c	/^multi_client_connect_setenv(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_client_disconnect_script	multi.c	/^multi_client_disconnect_script(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_client_disconnect_setenv	multi.c	/^multi_client_disconnect_setenv(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_close_instance	multi.c	/^multi_close_instance(struct multi_context *m,$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi, bool shutdown)
multi_close_instance	multi.h	/^void multi_close_instance(struct multi_context *m, struct multi_instance *mi, bool shutdown);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi, bool shutdown)
multi_close_instance_on_signal	multi.c	/^multi_close_instance_on_signal(struct multi_context *m, struct multi_instance *mi)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi)
multi_close_instance_on_signal	multi.h	/^void multi_close_instance_on_signal(struct multi_context *m, struct multi_instance *mi);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi)
multi_connection_established	multi.c	/^multi_connection_established(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_context	multi.h	/^struct multi_context {$/;"	s
multi_context::cid_counter	multi.h	/^    unsigned long cid_counter;$/;"	m	struct:multi_context	access:public
multi_context::cid_hash	multi.h	/^    struct hash *cid_hash;$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
multi_context::context_buffers	multi.h	/^    struct context_buffers *context_buffers;$/;"	m	struct:multi_context	typeref:struct:multi_context::context_buffers	access:public
multi_context::deferred_shutdown_signal	multi.h	/^    struct deferred_signal_schedule_entry deferred_shutdown_signal;$/;"	m	struct:multi_context	typeref:struct:multi_context::deferred_signal_schedule_entry	access:public
multi_context::earliest_wakeup	multi.h	/^    struct multi_instance *earliest_wakeup;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
multi_context::enable_c2c	multi.h	/^    bool enable_c2c;$/;"	m	struct:multi_context	access:public
multi_context::hash	multi.h	/^    struct hash *hash;          \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
multi_context::ifconfig_pool	multi.h	/^    struct ifconfig_pool *ifconfig_pool;$/;"	m	struct:multi_context	typeref:struct:multi_context::ifconfig_pool	access:public
multi_context::inotify_watchers	multi.h	/^    struct hash *inotify_watchers;$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
multi_context::instances	multi.h	/^    struct multi_instance **instances;  \/**< Array of multi_instances. An instance can be$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
multi_context::iter	multi.h	/^    struct hash *iter;          \/**< VPN tunnel instances indexed by real$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
multi_context::local	multi.h	/^    struct mroute_addr local;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_addr	access:public
multi_context::max_clients	multi.h	/^    int max_clients;$/;"	m	struct:multi_context	access:public
multi_context::mbuf	multi.h	/^    struct mbuf_set *mbuf;      \/**< Set of buffers for passing data$/;"	m	struct:multi_context	typeref:struct:multi_context::mbuf_set	access:public
multi_context::mpp_touched	multi.h	/^    struct multi_instance **mpp_touched;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
multi_context::mtcp	multi.h	/^    struct multi_tcp *mtcp;     \/**< State specific to OpenVPN using TCP$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_tcp	access:public
multi_context::n_clients	multi.h	/^    int n_clients; \/* current number of authenticated clients *\/$/;"	m	struct:multi_context	access:public
multi_context::new_connection_limiter	multi.h	/^    struct frequency_limit *new_connection_limiter;$/;"	m	struct:multi_context	typeref:struct:multi_context::frequency_limit	access:public
multi_context::pending	multi.h	/^    struct multi_instance *pending;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
multi_context::per_second_trigger	multi.h	/^    time_t per_second_trigger;$/;"	m	struct:multi_context	access:public
multi_context::reaper	multi.h	/^    struct multi_reap *reaper;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_reap	access:public
multi_context::route_helper	multi.h	/^    struct mroute_helper *route_helper;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_helper	access:public
multi_context::schedule	multi.h	/^    struct schedule *schedule;$/;"	m	struct:multi_context	typeref:struct:multi_context::schedule	access:public
multi_context::stale_routes_check_et	multi.h	/^    struct event_timeout stale_routes_check_et;$/;"	m	struct:multi_context	typeref:struct:multi_context::event_timeout	access:public
multi_context::status_file_version	multi.h	/^    int status_file_version;$/;"	m	struct:multi_context	access:public
multi_context::tcp_queue_limit	multi.h	/^    int tcp_queue_limit;$/;"	m	struct:multi_context	access:public
multi_context::thread_mode	multi.h	/^    int thread_mode;$/;"	m	struct:multi_context	access:public
multi_context::top	multi.h	/^    struct context top;         \/**< Storage structure for process-wide$/;"	m	struct:multi_context	typeref:struct:multi_context::context	access:public
multi_context::vhash	multi.h	/^    struct hash *vhash;         \/**< VPN tunnel instances indexed by$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
multi_create_instance	multi.c	/^multi_create_instance(struct multi_context *m, const struct mroute_addr *real)$/;"	f	signature:(struct multi_context *m, const struct mroute_addr *real)
multi_create_instance	multi.h	/^struct multi_instance *multi_create_instance(struct multi_context *m, const struct mroute_addr *real);$/;"	p	signature:(struct multi_context *m, const struct mroute_addr *real)
multi_create_instance_tcp	mtcp.c	/^multi_create_instance_tcp(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
multi_del_iroutes	multi.c	/^multi_del_iroutes(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_delete_dup	multi.c	/^multi_delete_dup(struct multi_context *m, struct multi_instance *new_mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *new_mi)
multi_get_create_instance_udp	mudp.c	/^multi_get_create_instance_udp(struct multi_context *m, bool *floated)$/;"	f	signature:(struct multi_context *m, bool *floated)
multi_get_create_instance_udp	mudp.h	/^struct multi_instance *multi_get_create_instance_udp(struct multi_context *m, bool *floated);$/;"	p	signature:(struct multi_context *m, bool *floated)
multi_get_instance_by_virtual_addr	multi.c	/^multi_get_instance_by_virtual_addr(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, const struct mroute_addr *addr, bool cidr_routing)
multi_get_queue	multi.c	/^multi_get_queue(struct mbuf_set *ms)$/;"	f	signature:(struct mbuf_set *ms)
multi_get_queue	multi.h	/^struct multi_instance *multi_get_queue(struct mbuf_set *ms);$/;"	p	signature:(struct mbuf_set *ms)
multi_get_timeout	multi.h	/^multi_get_timeout(struct multi_context *m, struct timeval *dest)$/;"	f	signature:(struct multi_context *m, struct timeval *dest)
multi_ifconfig_pool_persist	multi.c	/^multi_ifconfig_pool_persist(struct multi_context *m, bool force)$/;"	f	signature:(struct multi_context *m, bool force)
multi_ifconfig_pool_persist	multi.h	/^void multi_ifconfig_pool_persist(struct multi_context *m, bool force);$/;"	p	signature:(struct multi_context *m, bool force)
multi_init	multi.c	/^multi_init(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)$/;"	f	signature:(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)
multi_init	multi.h	/^void multi_init(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode);$/;"	p	signature:(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)
multi_instance	multi.h	/^struct multi_instance {$/;"	s
multi_instance::cc_config	multi.h	/^    struct buffer_list *cc_config;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::buffer_list	access:public
multi_instance::connection_established_flag	multi.h	/^    bool connection_established_flag;$/;"	m	struct:multi_instance	access:public
multi_instance::context	multi.h	/^    struct context context;     \/**< The context structure storing state$/;"	m	struct:multi_instance	typeref:struct:multi_instance::context	access:public
multi_instance::created	multi.h	/^    time_t created;             \/**< Time at which a VPN tunnel instance$/;"	m	struct:multi_instance	access:public
multi_instance::defined	multi.h	/^    bool defined;$/;"	m	struct:multi_instance	access:public
multi_instance::did_cid_hash	multi.h	/^    bool did_cid_hash;$/;"	m	struct:multi_instance	access:public
multi_instance::did_iroutes	multi.h	/^    bool did_iroutes;$/;"	m	struct:multi_instance	access:public
multi_instance::did_iter	multi.h	/^    bool did_iter;$/;"	m	struct:multi_instance	access:public
multi_instance::did_open_context	multi.h	/^    bool did_open_context;$/;"	m	struct:multi_instance	access:public
multi_instance::did_real_hash	multi.h	/^    bool did_real_hash;$/;"	m	struct:multi_instance	access:public
multi_instance::gc	multi.h	/^    struct gc_arena gc;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::gc_arena	access:public
multi_instance::halt	multi.h	/^    bool halt;$/;"	m	struct:multi_instance	access:public
multi_instance::inotify_watch	multi.h	/^    int inotify_watch; \/* watch descriptor for acf *\/$/;"	m	struct:multi_instance	access:public
multi_instance::msg_prefix	multi.h	/^    char msg_prefix[MULTI_PREFIX_MAX_LENGTH];$/;"	m	struct:multi_instance	access:public
multi_instance::n_clients_delta	multi.h	/^    int n_clients_delta; \/* added to multi_context.n_clients when instance is closed *\/$/;"	m	struct:multi_instance	access:public
multi_instance::real	multi.h	/^    struct mroute_addr real;    \/**< External network address of the$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mroute_addr	access:public
multi_instance::refcount	multi.h	/^    int refcount;$/;"	m	struct:multi_instance	access:public
multi_instance::reporting_addr	multi.h	/^    in_addr_t reporting_addr;     \/* IP address shown in status listing *\/$/;"	m	struct:multi_instance	access:public
multi_instance::reporting_addr_ipv6	multi.h	/^    struct in6_addr reporting_addr_ipv6; \/* IPv6 address in status listing *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::in6_addr	access:public
multi_instance::route_count	multi.h	/^    int route_count;           \/* number of routes (including cached routes) owned by this instance *\/$/;"	m	struct:multi_instance	access:public
multi_instance::se	multi.h	/^    struct schedule_entry se;  \/* this must be the first element of the structure *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::schedule_entry	access:public
multi_instance::socket_set_called	multi.h	/^    bool socket_set_called;$/;"	m	struct:multi_instance	access:public
multi_instance::tcp_link_out_deferred	multi.h	/^    struct mbuf_set *tcp_link_out_deferred;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mbuf_set	access:public
multi_instance::tcp_rwflags	multi.h	/^    unsigned int tcp_rwflags;$/;"	m	struct:multi_instance	access:public
multi_instance::vaddr_handle	multi.h	/^    ifconfig_pool_handle vaddr_handle;$/;"	m	struct:multi_instance	access:public
multi_instance::wakeup	multi.h	/^    struct timeval wakeup;     \/* absolute time *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::timeval	access:public
multi_instance_dec_refcount	multi.h	/^multi_instance_dec_refcount(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
multi_instance_inc_refcount	multi.h	/^multi_instance_inc_refcount(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
multi_instance_string	multi.c	/^multi_instance_string(const struct multi_instance *mi, bool null, struct gc_arena *gc)$/;"	f	signature:(const struct multi_instance *mi, bool null, struct gc_arena *gc)
multi_instance_string	multi.h	/^const char *multi_instance_string(const struct multi_instance *mi, bool null, struct gc_arena *gc);$/;"	p	signature:(const struct multi_instance *mi, bool null, struct gc_arena *gc)
multi_learn_addr	multi.c	/^multi_learn_addr(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const struct mroute_addr *addr, const unsigned int flags)
multi_learn_in6_addr	multi.c	/^multi_learn_in6_addr(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, struct in6_addr a6, int netbits, bool primary)
multi_learn_in_addr_t	multi.c	/^multi_learn_in_addr_t(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, in_addr_t a, int netbits, bool primary)
multi_output_queue_ready	multi.h	/^multi_output_queue_ready(const struct multi_context *m,$/;"	f	signature:(const struct multi_context *m, const struct multi_instance *mi)
multi_print_status	multi.c	/^multi_print_status(struct multi_context *m, struct status_output *so, const int version)$/;"	f	signature:(struct multi_context *m, struct status_output *so, const int version)
multi_print_status	multi.h	/^void multi_print_status(struct multi_context *m, struct status_output *so, const int version);$/;"	p	signature:(struct multi_context *m, struct status_output *so, const int version)
multi_process_drop_outgoing_tun	multi.c	/^multi_process_drop_outgoing_tun(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_drop_outgoing_tun	multi.h	/^void multi_process_drop_outgoing_tun(struct multi_context *m, const unsigned int mpp_flags);$/;"	p	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_file_closed	multi.c	/^multi_process_file_closed(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_file_closed	multi.h	/^void multi_process_file_closed(struct multi_context *m, const unsigned int mpp_flags);$/;"	p	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_float	multi.c	/^multi_process_float(struct multi_context *m, struct multi_instance *mi)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi)
multi_process_float	multi.h	/^void multi_process_float(struct multi_context *m, struct multi_instance *mi);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi)
multi_process_incoming_link	multi.c	/^multi_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)
multi_process_incoming_link	multi.h	/^bool multi_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags);$/;"	p	signature:(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)
multi_process_incoming_tun	multi.c	/^multi_process_incoming_tun(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_incoming_tun	multi.h	/^bool multi_process_incoming_tun(struct multi_context *m, const unsigned int mpp_flags);$/;"	p	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_io_udp	mudp.c	/^multi_process_io_udp(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
multi_process_outgoing_link	mudp.c	/^multi_process_outgoing_link(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	file:	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_outgoing_link_dowork	multi.h	/^multi_process_outgoing_link_dowork(struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)
multi_process_outgoing_link_pre	multi.h	/^multi_process_outgoing_link_pre(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_process_outgoing_tun	multi.h	/^multi_process_outgoing_tun(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_per_second_timers	multi.h	/^multi_process_per_second_timers(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_process_per_second_timers_dowork	multi.c	/^multi_process_per_second_timers_dowork(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_process_post	multi.c	/^multi_process_post(struct multi_context *m, struct multi_instance *mi, const unsigned int flags)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi, const unsigned int flags)
multi_process_post	multi.h	/^bool multi_process_post(struct multi_context *m, struct multi_instance *mi, const unsigned int flags);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi, const unsigned int flags)
multi_process_signal	multi.c	/^multi_process_signal(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_process_signal	multi.h	/^bool multi_process_signal(struct multi_context *m);$/;"	p	signature:(struct multi_context *m)
multi_process_timeout	multi.c	/^multi_process_timeout(struct multi_context *m, const unsigned int mpp_flags)$/;"	f	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_process_timeout	multi.h	/^bool multi_process_timeout(struct multi_context *m, const unsigned int mpp_flags);$/;"	p	signature:(struct multi_context *m, const unsigned int mpp_flags)
multi_push_restart_schedule_exit	multi.c	/^multi_push_restart_schedule_exit(struct multi_context *m, bool next_server)$/;"	f	file:	signature:(struct multi_context *m, bool next_server)
multi_reap	multi.h	/^struct multi_reap$/;"	s
multi_reap::bucket_base	multi.h	/^    int bucket_base;$/;"	m	struct:multi_reap	access:public
multi_reap::buckets_per_pass	multi.h	/^    int buckets_per_pass;$/;"	m	struct:multi_reap	access:public
multi_reap::last_call	multi.h	/^    time_t last_call;$/;"	m	struct:multi_reap	access:public
multi_reap_all	multi.c	/^multi_reap_all(const struct multi_context *m)$/;"	f	file:	signature:(const struct multi_context *m)
multi_reap_free	multi.c	/^multi_reap_free(struct multi_reap *mr)$/;"	f	file:	signature:(struct multi_reap *mr)
multi_reap_new	multi.c	/^multi_reap_new(int buckets_per_pass)$/;"	f	file:	signature:(int buckets_per_pass)
multi_reap_process	multi.h	/^multi_reap_process(const struct multi_context *m)$/;"	f	signature:(const struct multi_context *m)
multi_reap_process_dowork	multi.c	/^multi_reap_process_dowork(const struct multi_context *m)$/;"	f	signature:(const struct multi_context *m)
multi_reap_range	multi.c	/^multi_reap_range(const struct multi_context *m,$/;"	f	file:	signature:(const struct multi_context *m, int start_bucket, int end_bucket)
multi_route	multi.h	/^struct multi_route$/;"	s
multi_route::addr	multi.h	/^    struct mroute_addr addr;$/;"	m	struct:multi_route	typeref:struct:multi_route::mroute_addr	access:public
multi_route::cache_generation	multi.h	/^    unsigned int cache_generation;$/;"	m	struct:multi_route	access:public
multi_route::flags	multi.h	/^    unsigned int flags;$/;"	m	struct:multi_route	access:public
multi_route::instance	multi.h	/^    struct multi_instance *instance;$/;"	m	struct:multi_route	typeref:struct:multi_route::multi_instance	access:public
multi_route::last_reference	multi.h	/^    time_t last_reference;$/;"	m	struct:multi_route	access:public
multi_route_defined	multi.h	/^multi_route_defined(const struct multi_context *m,$/;"	f	signature:(const struct multi_context *m, const struct multi_route *r)
multi_route_del	multi.h	/^multi_route_del(struct multi_route *route)$/;"	f	signature:(struct multi_route *route)
multi_schedule_context_wakeup	multi.c	/^multi_schedule_context_wakeup(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_select_virtual_addr	multi.c	/^multi_select_virtual_addr(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_set_pending	multi.h	/^multi_set_pending(struct multi_context *m, struct multi_instance *mi)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi)
multi_set_virtual_addr_env	multi.c	/^multi_set_virtual_addr_env(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_signal_instance	multi.c	/^multi_signal_instance(struct multi_context *m, struct multi_instance *mi, const int sig)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const int sig)
multi_tcp	mtcp.h	/^struct multi_tcp$/;"	s
multi_tcp::es	mtcp.h	/^    struct event_set *es;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set	access:public
multi_tcp::esr	mtcp.h	/^    struct event_set_return *esr;$/;"	m	struct:multi_tcp	typeref:struct:multi_tcp::event_set_return	access:public
multi_tcp::management_persist_flags	mtcp.h	/^    unsigned int management_persist_flags;$/;"	m	struct:multi_tcp	access:public
multi_tcp::maxevents	mtcp.h	/^    int maxevents;$/;"	m	struct:multi_tcp	access:public
multi_tcp::n_esr	mtcp.h	/^    int n_esr;$/;"	m	struct:multi_tcp	access:public
multi_tcp::tun_rwflags	mtcp.h	/^    unsigned int tun_rwflags;$/;"	m	struct:multi_tcp	access:public
multi_tcp_action	mtcp.c	/^multi_tcp_action(struct multi_context *m, struct multi_instance *mi, int action, bool poll)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, int action, bool poll)
multi_tcp_context	mtcp.c	/^multi_tcp_context(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_tcp_delete_event	mtcp.c	/^multi_tcp_delete_event(struct multi_tcp *mtcp, event_t event)$/;"	f	signature:(struct multi_tcp *mtcp, event_t event)
multi_tcp_delete_event	mtcp.h	/^void multi_tcp_delete_event(struct multi_tcp *mtcp, event_t event);$/;"	p	signature:(struct multi_tcp *mtcp, event_t event)
multi_tcp_dereference_instance	mtcp.c	/^multi_tcp_dereference_instance(struct multi_tcp *mtcp, struct multi_instance *mi)$/;"	f	signature:(struct multi_tcp *mtcp, struct multi_instance *mi)
multi_tcp_dereference_instance	mtcp.h	/^void multi_tcp_dereference_instance(struct multi_tcp *mtcp, struct multi_instance *mi);$/;"	p	signature:(struct multi_tcp *mtcp, struct multi_instance *mi)
multi_tcp_dispatch	mtcp.c	/^multi_tcp_dispatch(struct multi_context *m, struct multi_instance *mi, const int action)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const int action)
multi_tcp_free	mtcp.c	/^multi_tcp_free(struct multi_tcp *mtcp)$/;"	f	signature:(struct multi_tcp *mtcp)
multi_tcp_free	mtcp.h	/^void multi_tcp_free(struct multi_tcp *mtcp);$/;"	p	signature:(struct multi_tcp *mtcp)
multi_tcp_init	mtcp.c	/^multi_tcp_init(int maxevents, int *maxclients)$/;"	f	signature:(int maxevents, int *maxclients)
multi_tcp_init	mtcp.h	/^struct multi_tcp *multi_tcp_init(int maxevents, int *maxclients);$/;"	p	signature:(int maxevents, int *maxclients)
multi_tcp_instance_specific_free	mtcp.c	/^multi_tcp_instance_specific_free(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
multi_tcp_instance_specific_free	mtcp.h	/^void multi_tcp_instance_specific_free(struct multi_instance *mi);$/;"	p	signature:(struct multi_instance *mi)
multi_tcp_instance_specific_init	mtcp.c	/^multi_tcp_instance_specific_init(struct multi_context *m, struct multi_instance *mi)$/;"	f	signature:(struct multi_context *m, struct multi_instance *mi)
multi_tcp_instance_specific_init	mtcp.h	/^bool multi_tcp_instance_specific_init(struct multi_context *m, struct multi_instance *mi);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi)
multi_tcp_link_out_deferred	mtcp.h	/^void multi_tcp_link_out_deferred(struct multi_context *m, struct multi_instance *mi);$/;"	p	signature:(struct multi_context *m, struct multi_instance *mi)
multi_tcp_post	mtcp.c	/^multi_tcp_post(struct multi_context *m, struct multi_instance *mi, const int action)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const int action)
multi_tcp_process_io	mtcp.c	/^multi_tcp_process_io(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
multi_tcp_process_outgoing_link	mtcp.c	/^multi_tcp_process_outgoing_link(struct multi_context *m, bool defer, const unsigned int mpp_flags)$/;"	f	file:	signature:(struct multi_context *m, bool defer, const unsigned int mpp_flags)
multi_tcp_process_outgoing_link_ready	mtcp.c	/^multi_tcp_process_outgoing_link_ready(struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const unsigned int mpp_flags)
multi_tcp_set_global_rw_flags	mtcp.c	/^multi_tcp_set_global_rw_flags(struct multi_context *m, struct multi_instance *mi)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi)
multi_tcp_wait	mtcp.c	/^multi_tcp_wait(const struct context *c,$/;"	f	file:	signature:(const struct context *c, struct multi_tcp *mtcp)
multi_tcp_wait_lite	mtcp.c	/^multi_tcp_wait_lite(struct multi_context *m, struct multi_instance *mi, const int action, bool *tun_input_pending)$/;"	f	file:	signature:(struct multi_context *m, struct multi_instance *mi, const int action, bool *tun_input_pending)
multi_top_free	multi.c	/^multi_top_free(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_top_free	multi.h	/^void multi_top_free(struct multi_context *m);$/;"	p	signature:(struct multi_context *m)
multi_top_init	multi.c	/^multi_top_init(struct multi_context *m, const struct context *top)$/;"	f	signature:(struct multi_context *m, const struct context *top)
multi_top_init	multi.h	/^void multi_top_init(struct multi_context *m, const struct context *top);$/;"	p	signature:(struct multi_context *m, const struct context *top)
multi_unicast	multi.c	/^multi_unicast(struct multi_context *m,$/;"	f	file:	signature:(struct multi_context *m, const struct buffer *buf, struct multi_instance *mi)
multi_uninit	multi.c	/^multi_uninit(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
multi_uninit	multi.h	/^void multi_uninit(struct multi_context *m);$/;"	p	signature:(struct multi_context *m)
multiline	options.c	/^        struct buffer *multiline;$/;"	m	union:in_src::__anon3	typeref:struct:in_src::__anon3::buffer	file:	access:public
must_die	ssl_common.h	/^    time_t must_die;            \/* this object is destroyed at this time *\/$/;"	m	struct:key_state	access:public
must_have_n_keys	crypto.c	/^must_have_n_keys(const char *filename, const char *option, const struct key2 *key2, int n)$/;"	f	signature:(const char *filename, const char *option, const struct key2 *key2, int n)
must_have_n_keys	crypto.h	/^void must_have_n_keys(const char *filename, const char *option, const struct key2 *key2, int n);$/;"	p	signature:(const char *filename, const char *option, const struct key2 *key2, int n)
must_negotiate	ssl_common.h	/^    time_t must_negotiate;      \/* key negotiation times out if not finished before this time *\/$/;"	m	struct:key_state	access:public
mute	options.h	/^    int mute;$/;"	m	struct:options	access:public
mute_category	error.c	/^static int mute_category;   \/* GLOBAL *\/$/;"	v	file:
mute_count	error.c	/^static int mute_count;      \/* GLOBAL *\/$/;"	v	file:
mute_cutoff	error.c	/^static int mute_cutoff;     \/* GLOBAL *\/$/;"	v	file:
mute_replay_warnings	options.h	/^    bool mute_replay_warnings;$/;"	m	struct:options	access:public
my_debug	ssl_mbedtls.c	/^my_debug( void *ctx, int level, const char *file, int line,$/;"	f	file:	signature:( void *ctx, int level, const char *file, int line, const char *str )
my_strupr	ntlm.c	/^my_strupr(char *str)$/;"	f	file:	signature:(char *str)
mydata_index	ssl_openssl.c	/^int mydata_index; \/* GLOBAL *\/$/;"	v
n	clinat.h	/^    int n;$/;"	m	struct:client_nat_option_list	access:public
n	crypto.h	/^    int n;                      \/**< The number of \\c key objects stored$/;"	m	struct:key2	access:public
n	interval.h	/^    interval_t n;$/;"	m	struct:event_timeout	access:public
n	list.c	/^    int n;$/;"	m	struct:word	file:	access:public
n	otime.h	/^    int n;$/;"	m	struct:frequency_limit	access:public
n	plugin.h	/^    int n;$/;"	m	struct:plugin_common	access:public
n	plugin.h	/^    int n;$/;"	m	struct:plugin_option_list	access:public
n	plugin.h	/^    int n;$/;"	m	struct:plugin_return	access:public
n_addrs	route.h	/^    int n_addrs; \/* len of addrs, may be 0 *\/$/;"	m	struct:route_gateway_info	access:public
n_addrs	route.h	/^    int n_addrs; \/* len of addrs, may be 0 *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
n_bcast_buf	options.h	/^    int n_bcast_buf;$/;"	m	struct:options	access:public
n_buckets	list.h	/^    int n_buckets;$/;"	m	struct:hash	access:public
n_bypass	route.h	/^    int n_bypass;$/;"	m	struct:route_bypass	access:public
n_bytes	ssl_common.h	/^    counter_type n_bytes;                \/* how many bytes sent\/recvd since last key exchange *\/$/;"	m	struct:key_state	access:public
n_check_reload	pf.h	/^    unsigned int n_check_reload;$/;"	m	struct:pf_context	access:public
n_clients	manage.h	/^    int (*n_clients) (void *arg);$/;"	m	struct:management_callback	access:public
n_clients	mstats.h	/^    int n_clients;$/;"	m	struct:mmap_stats	access:public
n_clients	multi.h	/^    int n_clients; \/* current number of authenticated clients *\/$/;"	m	struct:multi_context	access:public
n_clients_delta	multi.h	/^    int n_clients_delta; \/* added to multi_context.n_clients when instance is closed *\/$/;"	m	struct:multi_instance	access:public
n_comp	lzo.h	/^    int n_comp;$/;"	m	struct:lzo_adaptive_compress	access:public
n_elements	list.h	/^    int n_elements;$/;"	m	struct:hash	access:public
n_esr	mtcp.h	/^    int n_esr;$/;"	m	struct:multi_tcp	access:public
n_events	event.c	/^    int n_events;$/;"	m	struct:po_set	file:	access:public
n_events	event.c	/^    int n_events;$/;"	m	struct:we_set	file:	access:public
n_hard_errors	ssl_common.h	/^    int n_hard_errors; \/* errors due to TLS negotiation failure *\/$/;"	m	struct:tls_multi	access:public
n_net_len	mroute.h	/^    int n_net_len;               \/* length of net_len array *\/$/;"	m	struct:mroute_helper	access:public
n_packets	gremlin.h	/^    int n_packets;$/;"	m	struct:packet_flood_parms	access:public
n_packets	ssl_common.h	/^    counter_type n_packets;              \/* how many packets sent\/recvd since last key exchange *\/$/;"	m	struct:key_state	access:public
n_rnd_bytes	misc.c	798;"	d	file:
n_rnd_bytes	misc.c	808;"	d	file:
n_sent_push_requests	openvpn.h	/^    int n_sent_push_requests;$/;"	m	struct:context_2	access:public
n_sessions	ssl_common.h	/^    int n_sessions;             \/**< Number of sessions negotiated thus$/;"	m	struct:tls_multi	access:public
n_soft_errors	ssl_common.h	/^    int n_soft_errors; \/* errors due to unrecognized or failed-to-authenticate incoming packets *\/$/;"	m	struct:tls_multi	access:public
n_total	lzo.h	/^    int n_total;$/;"	m	struct:lzo_adaptive_compress	access:public
n_trunc_post_decrypt	openvpn.h	/^    counter_type n_trunc_post_decrypt;$/;"	m	struct:context_2	access:public
n_trunc_pre_encrypt	openvpn.h	/^    counter_type n_trunc_pre_encrypt;$/;"	m	struct:context_2	access:public
n_trunc_tun_read	openvpn.h	/^    counter_type n_trunc_tun_read;$/;"	m	struct:context_2	access:public
n_trunc_tun_write	openvpn.h	/^    counter_type n_trunc_tun_write;$/;"	m	struct:context_2	access:public
name	comp.h	/^    const char *name;$/;"	m	struct:compress_alg	access:public
name	packet_id.h	/^    const char *name;$/;"	m	struct:packet_id_rec	access:public
name	proxy.h	/^    const char *name;$/;"	m	struct:http_custom_header	access:public
name	ssl_verify.h	/^    const char *name;$/;"	m	struct:x509_track	access:public
name	tun.h	/^    const char *name;$/;"	m	struct:panel_reg	access:public
name	win32.h	/^    const char *name;$/;"	m	struct:semaphore	access:public
name_to_guid	tun.c	/^name_to_guid(const char *name, const struct tap_reg *tap_reg, const struct panel_reg *panel_reg)$/;"	f	file:	signature:(const char *name, const struct tap_reg *tap_reg, const struct panel_reg *panel_reg)
nbdd	tun.h	/^    in_addr_t nbdd[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
nbdd_len	tun.h	/^    int nbdd_len;$/;"	m	struct:tuntap_options	access:public
ncp_ciphers	options.h	/^    const char *ncp_ciphers;$/;"	m	struct:options	access:public
ncp_enabled	options.h	/^    bool ncp_enabled;$/;"	m	struct:options	access:public
ncp_enabled	ssl_common.h	/^    bool ncp_enabled;$/;"	m	struct:tls_options	access:public
ne32	manage.h	/^    struct net_event_win32 ne32;$/;"	m	struct:man_connection	typeref:struct:man_connection::net_event_win32	access:public
need_keys	crypto.h	/^    int need_keys;              \/**< The number of key objects necessary$/;"	m	struct:key_direction_state	access:public
net_event_win32	win32.h	/^struct net_event_win32$/;"	s
net_event_win32::event_mask	win32.h	/^    long event_mask;$/;"	m	struct:net_event_win32	access:public
net_event_win32::handle	win32.h	/^    struct rw_handle handle;$/;"	m	struct:net_event_win32	typeref:struct:net_event_win32::rw_handle	access:public
net_event_win32::sd	win32.h	/^    socket_descriptor_t sd;$/;"	m	struct:net_event_win32	access:public
net_event_win32_clear_selected_events	win32.h	/^net_event_win32_clear_selected_events(struct net_event_win32 *ne, long selected_events)$/;"	f	signature:(struct net_event_win32 *ne, long selected_events)
net_event_win32_close	win32.c	/^net_event_win32_close(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_close	win32.h	/^void net_event_win32_close(struct net_event_win32 *ne);$/;"	p	signature:(struct net_event_win32 *ne)
net_event_win32_defined	win32.h	/^net_event_win32_defined(const struct net_event_win32 *ne)$/;"	f	signature:(const struct net_event_win32 *ne)
net_event_win32_get_event	win32.h	/^net_event_win32_get_event(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_get_event_mask	win32.h	/^net_event_win32_get_event_mask(const struct net_event_win32 *ne)$/;"	f	signature:(const struct net_event_win32 *ne)
net_event_win32_init	win32.c	/^net_event_win32_init(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_init	win32.h	/^void net_event_win32_init(struct net_event_win32 *ne);$/;"	p	signature:(struct net_event_win32 *ne)
net_event_win32_reset	win32.c	/^net_event_win32_reset(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_reset	win32.h	/^void net_event_win32_reset(struct net_event_win32 *ne);$/;"	p	signature:(struct net_event_win32 *ne)
net_event_win32_reset_write	win32.c	/^net_event_win32_reset_write(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_reset_write	win32.h	/^void net_event_win32_reset_write(struct net_event_win32 *ne);$/;"	p	signature:(struct net_event_win32 *ne)
net_event_win32_start	win32.c	/^net_event_win32_start(struct net_event_win32 *ne, long network_events, socket_descriptor_t sd)$/;"	f	signature:(struct net_event_win32 *ne, long network_events, socket_descriptor_t sd)
net_event_win32_start	win32.h	/^void net_event_win32_start(struct net_event_win32 *ne, long network_events, socket_descriptor_t sd);$/;"	p	signature:(struct net_event_win32 *ne, long network_events, socket_descriptor_t sd)
net_event_win32_stop	win32.c	/^net_event_win32_stop(struct net_event_win32 *ne)$/;"	f	signature:(struct net_event_win32 *ne)
net_event_win32_stop	win32.h	/^void net_event_win32_stop(struct net_event_win32 *ne);$/;"	p	signature:(struct net_event_win32 *ne)
net_len	mroute.h	/^    uint8_t net_len[MR_HELPER_NET_LEN];    \/* CIDR netlengths in descending order *\/$/;"	m	struct:mroute_helper	access:public
net_len_refcount	mroute.h	/^    int net_len_refcount[MR_HELPER_NET_LEN]; \/* refcount of each netlength *\/$/;"	m	struct:mroute_helper	access:public
net_time_t	packet_id.h	/^typedef uint16_t net_time_t;$/;"	t
net_time_t	packet_id.h	/^typedef uint32_t net_time_t;$/;"	t
netbios_node_type	tun.h	/^    int netbios_node_type;   \/* NBT 1,2,4,8 (46) *\/$/;"	m	struct:tuntap_options	access:public
netbios_scope	tun.h	/^    const char *netbios_scope; \/* NBS (47) *\/$/;"	m	struct:tuntap_options	access:public
netbits	mroute.h	/^    uint8_t netbits; \/* number of bits in network part of address,$/;"	m	struct:mroute_addr	access:public
netbits	route.h	/^    int netbits;$/;"	m	struct:iroute	access:public
netbits	route.h	/^    unsigned int netbits;$/;"	m	struct:iroute_ipv6	access:public
netbits	route.h	/^    unsigned int netbits;$/;"	m	struct:route_ipv6	access:public
netbits_ipv6	route.h	/^    int netbits_ipv6;$/;"	m	struct:route_ipv6_gateway_address	access:public
netbits_ipv6	tun.h	/^    int netbits_ipv6;$/;"	m	struct:tuntap	access:public
netbits_to_netmask	route.h	/^netbits_to_netmask(const int netbits)$/;"	f	signature:(const int netbits)
netbsd_modify_read_write_return	tun.c	/^netbsd_modify_read_write_return(int len)$/;"	f	file:	signature:(int len)
netcmd_semaphore	win32.c	/^struct semaphore netcmd_semaphore; \/* GLOBAL *\/$/;"	v	typeref:struct:semaphore
netcmd_semaphore_close	win32.c	/^netcmd_semaphore_close(void)$/;"	f	signature:(void)
netcmd_semaphore_close	win32.h	/^void netcmd_semaphore_close(void);$/;"	p	signature:(void)
netcmd_semaphore_init	win32.c	/^netcmd_semaphore_init(void)$/;"	f	signature:(void)
netcmd_semaphore_init	win32.h	/^void netcmd_semaphore_init(void);$/;"	p	signature:(void)
netcmd_semaphore_lock	win32.c	/^netcmd_semaphore_lock(void)$/;"	f	signature:(void)
netcmd_semaphore_lock	win32.h	/^void netcmd_semaphore_lock(void);$/;"	p	signature:(void)
netcmd_semaphore_release	win32.c	/^netcmd_semaphore_release(void)$/;"	f	signature:(void)
netcmd_semaphore_release	win32.h	/^void netcmd_semaphore_release(void);$/;"	p	signature:(void)
netmask	clinat.h	/^    in_addr_t netmask;$/;"	m	struct:client_nat_entry	access:public
netmask	pf.h	/^    in_addr_t netmask;$/;"	m	struct:ipv4_subnet	access:public
netmask	route.h	/^    const char *netmask;$/;"	m	struct:route_option	access:public
netmask	route.h	/^    in_addr_t netmask;$/;"	m	struct:route_gateway_address	access:public
netmask	route.h	/^    in_addr_t netmask;$/;"	m	struct:route_ipv4	access:public
netmask_to_netbits	route.c	/^netmask_to_netbits(const in_addr_t network, const in_addr_t netmask, int *netbits)$/;"	f	signature:(const in_addr_t network, const in_addr_t netmask, int *netbits)
netmask_to_netbits	route.h	/^bool netmask_to_netbits(const in_addr_t network, const in_addr_t netmask, int *netbits);$/;"	p	signature:(const in_addr_t network, const in_addr_t netmask, int *netbits)
netmask_to_netbits2	route.c	/^netmask_to_netbits2(in_addr_t netmask)$/;"	f	signature:(in_addr_t netmask)
netmask_to_netbits2	route.h	/^int netmask_to_netbits2(in_addr_t netmask);$/;"	p	signature:(in_addr_t netmask)
netsh_command	tun.c	/^netsh_command(const struct argv *a, int n, int msglevel)$/;"	f	file:	signature:(const struct argv *a, int n, int msglevel)
netsh_command	tun.c	/^static void netsh_command(const struct argv *a, int n, int msglevel);$/;"	p	file:	signature:(const struct argv *a, int n, int msglevel)
netsh_enable_dhcp	tun.c	/^netsh_enable_dhcp(const struct tuntap_options *to,$/;"	f	file:	signature:(const struct tuntap_options *to, const char *actual_name)
netsh_get_id	tun.c	/^netsh_get_id(const char *dev_node, struct gc_arena *gc)$/;"	f	file:	signature:(const char *dev_node, struct gc_arena *gc)
netsh_get_id	tun.c	/^static const char *netsh_get_id(const char *dev_node, struct gc_arena *gc);$/;"	p	file:	signature:(const char *dev_node, struct gc_arena *gc)
netsh_ifconfig	tun.c	/^netsh_ifconfig(const struct tuntap_options *to,$/;"	f	file:	signature:(const struct tuntap_options *to, const char *flex_name, const in_addr_t ip, const in_addr_t netmask, const unsigned int flags)
netsh_ifconfig	tun.c	/^static void netsh_ifconfig(const struct tuntap_options *to,$/;"	p	file:	signature:(const struct tuntap_options *to, const char *flex_name, const in_addr_t ip, const in_addr_t netmask, const unsigned int flags)
netsh_ifconfig_options	tun.c	/^netsh_ifconfig_options(const char *type,$/;"	f	file:	signature:(const char *type, const in_addr_t *addr_list, const int addr_len, const IP_ADDR_STRING *current, const char *flex_name, const bool test_first)
netsh_set_dns6_servers	tun.c	/^netsh_set_dns6_servers(const struct in6_addr *addr_list,$/;"	f	file:	signature:(const struct in6_addr *addr_list, const int addr_len, const char *flex_name)
netsh_set_dns6_servers	tun.c	/^static void netsh_set_dns6_servers(const struct in6_addr *addr_list,$/;"	p	file:	signature:(const struct in6_addr *addr_list, const int addr_len, const char *flex_name)
network	clinat.h	/^    in_addr_t network;$/;"	m	struct:client_nat_entry	access:public
network	pf.h	/^    in_addr_t network;$/;"	m	struct:ipv4_subnet	access:public
network	route.h	/^    const char *network;$/;"	m	struct:route_option	access:public
network	route.h	/^    in_addr_t network;$/;"	m	struct:iroute	access:public
network	route.h	/^    in_addr_t network;$/;"	m	struct:route_ipv4	access:public
network	route.h	/^    struct in6_addr network;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::in6_addr	access:public
network	route.h	/^    struct in6_addr network;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr	access:public
network_change	manage.h	/^    int (*network_change)(void *arg, bool samenetwork);$/;"	m	struct:management_callback	access:public
new_client_nat_list	clinat.c	/^new_client_nat_list(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
new_client_nat_list	clinat.h	/^struct client_nat_option_list *new_client_nat_list(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
new_connection_limiter	multi.h	/^    struct frequency_limit *new_connection_limiter;$/;"	m	struct:multi_context	typeref:struct:multi_context::frequency_limit	access:public
new_route_ipv6_option_list	route.c	/^new_route_ipv6_option_list(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
new_route_ipv6_option_list	route.h	/^struct route_ipv6_option_list *new_route_ipv6_option_list(struct gc_arena *a);$/;"	p	signature:(struct gc_arena *a)
new_route_option_list	route.c	/^new_route_option_list(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
new_route_option_list	route.h	/^struct route_option_list *new_route_option_list(struct gc_arena *a);$/;"	p	signature:(struct gc_arena *a)
next	buffer.h	/^    struct buffer_entry *next;$/;"	m	struct:buffer_entry	typeref:struct:buffer_entry::buffer_entry	access:public
next	buffer.h	/^    struct gc_entry *next;      \/**< Pointer to the next item in the$/;"	m	struct:gc_entry	typeref:struct:gc_entry::gc_entry	access:public
next	buffer.h	/^    struct gc_entry_special *next;$/;"	m	struct:gc_entry_special	typeref:struct:gc_entry_special::gc_entry_special	access:public
next	gremlin.c	/^static time_t next;      \/* GLOBAL *\/$/;"	v	file:
next	list.h	/^    struct hash_element *next;$/;"	m	struct:hash_element	typeref:struct:hash_element::hash_element	access:public
next	lzo.h	/^    time_t next;$/;"	m	struct:lzo_adaptive_compress	access:public
next	misc.h	/^    struct env_item *next;$/;"	m	struct:env_item	typeref:struct:env_item::env_item	access:public
next	options.c	/^    struct pull_filter *next;$/;"	m	struct:pull_filter	typeref:struct:pull_filter::pull_filter	file:	access:public
next	pf.h	/^    struct pf_cn_elem *next;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn_elem	access:public
next	pf.h	/^    struct pf_subnet *next;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::pf_subnet	access:public
next	ps.c	/^    struct proxy_connection *next;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:	access:public
next	pushlist.h	/^    struct push_entry *next;$/;"	m	struct:push_entry	typeref:struct:push_entry::push_entry	access:public
next	route.h	/^    struct iroute *next;$/;"	m	struct:iroute	typeref:struct:iroute::iroute	access:public
next	route.h	/^    struct iroute_ipv6 *next;$/;"	m	struct:iroute_ipv6	typeref:struct:iroute_ipv6::iroute_ipv6	access:public
next	route.h	/^    struct route_ipv4 *next;$/;"	m	struct:route_ipv4	typeref:struct:route_ipv4::route_ipv4	access:public
next	route.h	/^    struct route_ipv6 *next;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::route_ipv6	access:public
next	route.h	/^    struct route_ipv6_option *next;$/;"	m	struct:route_ipv6_option	typeref:struct:route_ipv6_option::route_ipv6_option	access:public
next	route.h	/^    struct route_option *next;$/;"	m	struct:route_option	typeref:struct:route_option::route_option	access:public
next	socket.h	/^    struct buffer next;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
next	socket.h	/^    struct cached_dns_entry *next;$/;"	m	struct:cached_dns_entry	typeref:struct:cached_dns_entry::cached_dns_entry	access:public
next	ssl_verify.h	/^    const struct x509_track *next;$/;"	m	struct:x509_track	typeref:struct:x509_track::x509_track	access:public
next	tun.h	/^    struct panel_reg *next;$/;"	m	struct:panel_reg	typeref:struct:panel_reg::panel_reg	access:public
next	tun.h	/^    struct tap_reg *next;$/;"	m	struct:tap_reg	typeref:struct:tap_reg::tap_reg	access:public
next_block	ssl_mbedtls.h	/^    buffer_entry *next_block;$/;"	m	struct:_buffer_entry	access:public
next_connection_entry	init.c	/^next_connection_entry(struct context *c)$/;"	f	file:	signature:(struct context *c)
next_try	reliable.h	/^    time_t next_try;$/;"	m	struct:reliable_entry	access:public
nexthdr	proto.h	/^    uint8_t nexthdr;$/;"	m	struct:openvpn_ipv6hdr	access:public
nh	route.c	/^    struct nlmsghdr nh;$/;"	m	struct:rtreq	typeref:struct:rtreq::nlmsghdr	file:	access:public
nice	options.h	/^    int nice;$/;"	m	struct:options	access:public
nid	ssl_verify.h	/^    int nid;$/;"	m	struct:x509_track	access:public
no_advance	options.h	/^    bool no_advance;$/;"	m	struct:options	access:public
no_more_than_n_args	options.c	/^no_more_than_n_args(const int msglevel,$/;"	f	file:	signature:(const int msglevel, char *p[], const int max, const unsigned int flags)
nocache	misc.h	/^    bool nocache;$/;"	m	struct:user_pass	access:public
nonce_data	crypto.c	/^static uint8_t *nonce_data = NULL; \/* GLOBAL *\/$/;"	v	file:
nonce_md	crypto.c	/^static const md_kt_t *nonce_md = NULL; \/* GLOBAL *\/$/;"	v	file:
nonce_secret_len	crypto.c	/^static int nonce_secret_len = 0; \/* GLOBAL *\/$/;"	v	file:
nonfatal	error.h	/^nonfatal(const unsigned int err)$/;"	f	signature:(const unsigned int err)
notnull	options.c	/^notnull(const char *arg, const char *description)$/;"	f	signature:(const char *arg, const char *description)
notnull	options.h	/^void notnull(const char *arg, const char *description);$/;"	p	signature:(const char *arg, const char *description)
now	otime.c	/^time_t now = 0;            \/* GLOBAL *\/$/;"	v
now_adj	otime.c	/^static time_t now_adj = 0; \/* GLOBAL *\/$/;"	v	file:
now_usec	otime.c	/^time_t now_usec = 0;       \/* GLOBAL *\/$/;"	v
np	buffer.c	/^np(const char *str)$/;"	f	signature:(const char *str)
np	buffer.h	/^const char *np(const char *str);$/;"	p	signature:(const char *str)
ns_cert_type	options.h	/^    int ns_cert_type; \/* set to 0, NS_CERT_CHECK_SERVER, or NS_CERT_CHECK_CLIENT *\/$/;"	m	struct:options	access:public
ns_cert_type	ssl_common.h	/^    int ns_cert_type;$/;"	m	struct:tls_options	access:public
ntlm_phase_1	ntlm.c	/^ntlm_phase_1(const struct http_proxy_info *p, struct gc_arena *gc)$/;"	f	signature:(const struct http_proxy_info *p, struct gc_arena *gc)
ntlm_phase_1	ntlm.h	/^const char *ntlm_phase_1(const struct http_proxy_info *p, struct gc_arena *gc);$/;"	p	signature:(const struct http_proxy_info *p, struct gc_arena *gc)
ntlm_phase_3	ntlm.c	/^ntlm_phase_3(const struct http_proxy_info *p, const char *phase_2,$/;"	f	signature:(const struct http_proxy_info *p, const char *phase_2, struct gc_arena *gc)
ntlm_phase_3	ntlm.h	/^const char *ntlm_phase_3(const struct http_proxy_info *p, const char *phase_2, struct gc_arena *gc);$/;"	p	signature:(const struct http_proxy_info *p, const char *phase_2, struct gc_arena *gc)
ntoh_fragment_header_type	fragment.h	198;"	d
ntohpid	packet_id.h	66;"	d
ntohpid	packet_id.h	88;"	d
ntohps	socket.h	61;"	d
ntohtime	packet_id.h	72;"	d
ntohtime	packet_id.h	90;"	d
ntp	tun.h	/^    in_addr_t ntp[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
ntp_len	tun.h	/^    int ntp_len;$/;"	m	struct:tuntap_options	access:public
occ	options.h	/^    bool occ;$/;"	m	struct:options	access:public
occ_interval	openvpn.h	/^    struct event_timeout occ_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
occ_magic	occ.c	/^const uint8_t occ_magic[] = {$/;"	v
occ_mtu_load_n_tries	openvpn.h	/^    int occ_mtu_load_n_tries;$/;"	m	struct:context_2	access:public
occ_mtu_load_size	openvpn.h	/^    int occ_mtu_load_size;$/;"	m	struct:context_2	access:public
occ_mtu_load_test_interval	openvpn.h	/^    struct event_timeout occ_mtu_load_test_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
occ_n_tries	openvpn.h	/^    int occ_n_tries;$/;"	m	struct:context_2	access:public
occ_op	openvpn.h	/^    int occ_op;                 \/* INIT to -1 *\/$/;"	m	struct:context_2	access:public
occ_reset_op	occ-inline.h	/^occ_reset_op(void)$/;"	f	signature:(void)
offset	buffer.h	/^    int offset;                 \/**< Offset in bytes of the actual content$/;"	m	struct:buffer	access:public
offset	reliable.h	/^    int offset;$/;"	m	struct:reliable	access:public
offsetof	mroute.h	/^              offsetof(struct mroute_addr, v4) + 4,$/;"	v
offsetof	mroute.h	/^              offsetof(struct mroute_addr, v4mappedv6) + 12,$/;"	v
offsetof	mroute.h	/^              offsetof(struct mroute_addr, v6) + 16,$/;"	v
old_window_title	win32.h	/^    char old_window_title [256];$/;"	m	struct:window_title	access:public
op	dhcp.h	/^    uint8_t op;        \/* message op *\/$/;"	m	struct:dhcp	access:public
op	occ.h	/^    int op;                     \/* OCC opcode to send to peer *\/$/;"	m	struct:mtu_load_test	access:public
opcode	reliable.h	/^    int opcode;$/;"	m	struct:reliable_entry	access:public
open1	plugin.h	/^    openvpn_plugin_open_v1 open1;$/;"	m	struct:plugin	access:public
open2	plugin.h	/^    openvpn_plugin_open_v2 open2;$/;"	m	struct:plugin	access:public
open3	plugin.h	/^    openvpn_plugin_open_v3 open3;$/;"	m	struct:plugin	access:public
open_biofp	ssl_openssl.c	/^open_biofp(void)$/;"	f	file:	signature:(void)
open_darwin_utun	tun.c	/^open_darwin_utun(const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)$/;"	f	signature:(const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)
open_management	init.c	/^open_management(struct context *c)$/;"	f	signature:(struct context *c)
open_management	init.h	/^bool open_management(struct context *c);$/;"	p	signature:(struct context *c)
open_null	tun.c	/^open_null(struct tuntap *tt)$/;"	f	file:	signature:(struct tuntap *tt)
open_plugins	init.c	/^open_plugins(struct context *c, const bool import_options, int init_point)$/;"	f	signature:(struct context *c, const bool import_options, int init_point)
open_plugins	init.h	/^void open_plugins(struct context *c, const bool import_options, int init_point);$/;"	p	signature:(struct context *c, const bool import_options, int init_point)
open_syslog	error.c	/^open_syslog(const char *pgmname, bool stdio_to_null)$/;"	f	signature:(const char *pgmname, bool stdio_to_null)
open_syslog	error.h	/^void open_syslog(const char *pgmname, bool stdio_to_null);$/;"	p	signature:(const char *pgmname, bool stdio_to_null)
open_tty	console_builtin.c	/^open_tty(const bool write)$/;"	f	file:	signature:(const bool write)
open_tun	tun.c	/^open_tun(const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)$/;"	f	signature:(const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)
open_tun	tun.h	/^void open_tun(const char *dev, const char *dev_type, const char *dev_node,$/;"	p	signature:(const char *dev, const char *dev_type, const char *dev_node, struct tuntap *tt)
open_tun_generic	tun.c	/^open_tun_generic(const char *dev, const char *dev_type, const char *dev_node,$/;"	f	file:	signature:(const char *dev, const char *dev_type, const char *dev_node, bool dynamic, struct tuntap *tt)
openssl_name	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	m	struct:__anon8	access:public
openssl_set_mydata_index	ssl_openssl.h	/^void openssl_set_mydata_index(void);$/;"	p	signature:(void)
openssl_tls_version	ssl_openssl.c	/^openssl_tls_version(int ver)$/;"	f	file:	signature:(int ver)
openvpn_PRF	ssl.c	/^openvpn_PRF(const uint8_t *secret,$/;"	f	file:	signature:(const uint8_t *secret, int secret_len, const char *label, const uint8_t *client_seed, int client_seed_len, const uint8_t *server_seed, int server_seed_len, const struct session_id *client_sid, const struct session_id *server_sid, uint8_t *output, int output_len)
openvpn_arp	proto.h	/^struct openvpn_arp {$/;"	s
openvpn_arp::arp_command	proto.h	/^    uint16_t arp_command;       \/* 0x0001 for ARP request, 0x0002 for ARP reply *\/$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::ip_dest	proto.h	/^    in_addr_t ip_dest;$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::ip_src	proto.h	/^    in_addr_t ip_src;$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::mac_addr_size	proto.h	/^    uint8_t mac_addr_size;      \/* 0x06 *\/$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::mac_addr_type	proto.h	/^    uint16_t mac_addr_type;     \/* 0x0001 *\/$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::mac_dest	proto.h	/^    uint8_t mac_dest[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::mac_src	proto.h	/^    uint8_t mac_src[OPENVPN_ETH_ALEN];$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::proto_addr_size	proto.h	/^    uint8_t proto_addr_size;    \/* 0x04 *\/$/;"	m	struct:openvpn_arp	access:public
openvpn_arp::proto_addr_type	proto.h	/^    uint16_t proto_addr_type;   \/* 0x0800 *\/$/;"	m	struct:openvpn_arp	access:public
openvpn_base64_decode	base64.c	/^openvpn_base64_decode(const char *str, void *data, int size)$/;"	f	signature:(const char *str, void *data, int size)
openvpn_base64_decode	base64.h	/^int openvpn_base64_decode(const char *str, void *data, int size);$/;"	p	signature:(const char *str, void *data, int size)
openvpn_base64_encode	base64.c	/^openvpn_base64_encode(const void *data, int size, char **str)$/;"	f	signature:(const void *data, int size, char **str)
openvpn_base64_encode	base64.h	/^int openvpn_base64_encode(const void *data, int size, char **str);$/;"	p	signature:(const void *data, int size, char **str)
openvpn_close_socket	socket.h	261;"	d
openvpn_close_socket	socket.h	277;"	d
openvpn_connect	socket.c	/^openvpn_connect(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, const struct sockaddr *remote, int connect_timeout, volatile int *signal_received)
openvpn_connect	socket.h	/^int openvpn_connect(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, const struct sockaddr *remote, int connect_timeout, volatile int *signal_received)
openvpn_decrypt	crypto.c	/^openvpn_decrypt(struct buffer *buf, struct buffer work,$/;"	f	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt, const struct frame *frame, const uint8_t *ad_start)
openvpn_decrypt	crypto.h	/^bool openvpn_decrypt(struct buffer *buf, struct buffer work,$/;"	p	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt, const struct frame *frame, const uint8_t *ad_start)
openvpn_decrypt_aead	crypto.c	/^openvpn_decrypt_aead(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt, const struct frame *frame, const uint8_t *ad_start)
openvpn_decrypt_v1	crypto.c	/^openvpn_decrypt_v1(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt, const struct frame *frame)
openvpn_dmalloc	memdbg.h	89;"	d
openvpn_encrypt	crypto.c	/^openvpn_encrypt(struct buffer *buf, struct buffer work,$/;"	f	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt)
openvpn_encrypt	crypto.h	/^void openvpn_encrypt(struct buffer *buf, struct buffer work,$/;"	p	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt)
openvpn_encrypt_aead	crypto.c	/^openvpn_encrypt_aead(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt)
openvpn_encrypt_v1	crypto.c	/^openvpn_encrypt_v1(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct crypto_options *opt)
openvpn_errno	error.h	74;"	d
openvpn_errno	error.h	79;"	d
openvpn_ethhdr	proto.h	/^struct openvpn_ethhdr$/;"	s
openvpn_ethhdr::dest	proto.h	/^    uint8_t dest[OPENVPN_ETH_ALEN];   \/* destination ethernet addr *\/$/;"	m	struct:openvpn_ethhdr	access:public
openvpn_ethhdr::proto	proto.h	/^    uint16_t proto;                   \/* packet type ID field *\/$/;"	m	struct:openvpn_ethhdr	access:public
openvpn_ethhdr::source	proto.h	/^    uint8_t source[OPENVPN_ETH_ALEN]; \/* source ethernet addr   *\/$/;"	m	struct:openvpn_ethhdr	access:public
openvpn_execve	misc.c	/^openvpn_execve(const struct argv *a, const struct env_set *es, const unsigned int flags)$/;"	f	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags)
openvpn_execve	misc.h	/^int openvpn_execve(const struct argv *a, const struct env_set *es, const unsigned int flags);$/;"	p	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags)
openvpn_execve	win32.c	/^openvpn_execve(const struct argv *a, const struct env_set *es, const unsigned int flags)$/;"	f	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags)
openvpn_execve_allowed	misc.c	/^openvpn_execve_allowed(const unsigned int flags)$/;"	f	signature:(const unsigned int flags)
openvpn_execve_allowed	misc.h	/^bool openvpn_execve_allowed(const unsigned int flags);$/;"	p	signature:(const unsigned int flags)
openvpn_execve_check	misc.c	/^openvpn_execve_check(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message)$/;"	f	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message)
openvpn_execve_check	misc.h	/^bool openvpn_execve_check(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message);$/;"	p	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *error_message)
openvpn_exit	error.c	/^openvpn_exit(const int status)$/;"	f	signature:(const int status)
openvpn_exit	error.h	/^void openvpn_exit(const int status);$/;"	p	signature:(const int status)
openvpn_extkey_rsa_finish	ssl_openssl.c	/^openvpn_extkey_rsa_finish(RSA *rsa)$/;"	f	file:	signature:(RSA *rsa)
openvpn_fd_set	fdmisc.h	/^openvpn_fd_set(int fd, fd_set *setp)$/;"	f	signature:(int fd, fd_set *setp)
openvpn_getaddrinfo	socket.c	/^openvpn_getaddrinfo(unsigned int flags,$/;"	f	signature:(unsigned int flags, const char *hostname, const char *servname, int resolve_retry_seconds, volatile int *signal_received, int ai_family, struct addrinfo **res)
openvpn_getaddrinfo	socket.h	/^int openvpn_getaddrinfo(unsigned int flags,$/;"	p	signature:(unsigned int flags, const char *hostname, const char *servname, int resolve_retry_seconds, volatile int *signal_received, int ai_family, struct addrinfo **res)
openvpn_gettimeofday	otime.h	/^openvpn_gettimeofday(struct timeval *tv, void *tz)$/;"	f	signature:(struct timeval *tv, void *tz)
openvpn_inet_aton	socket.c	/^openvpn_inet_aton(const char *dotted_quad, struct in_addr *addr)$/;"	f	signature:(const char *dotted_quad, struct in_addr *addr)
openvpn_inet_aton	socket.h	/^int openvpn_inet_aton(const char *dotted_quad, struct in_addr *addr);$/;"	p	signature:(const char *dotted_quad, struct in_addr *addr)
openvpn_iphdr	proto.h	/^struct openvpn_iphdr {$/;"	s
openvpn_iphdr::check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::daddr	proto.h	/^    uint32_t daddr;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::frag_off	proto.h	/^    uint16_t frag_off;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::id	proto.h	/^    uint16_t id;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::protocol	proto.h	/^    uint8_t protocol;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::saddr	proto.h	/^    uint32_t saddr;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::tos	proto.h	/^    uint8_t tos;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::tot_len	proto.h	/^    uint16_t tot_len;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::ttl	proto.h	/^    uint8_t ttl;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_iphdr::version_len	proto.h	/^    uint8_t version_len;$/;"	m	struct:openvpn_iphdr	access:public
openvpn_ipv6hdr	proto.h	/^struct openvpn_ipv6hdr {$/;"	s
openvpn_ipv6hdr::daddr	proto.h	/^    struct  in6_addr daddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr	access:public
openvpn_ipv6hdr::flow_lbl	proto.h	/^    uint8_t flow_lbl[3];$/;"	m	struct:openvpn_ipv6hdr	access:public
openvpn_ipv6hdr::hop_limit	proto.h	/^    uint8_t hop_limit;$/;"	m	struct:openvpn_ipv6hdr	access:public
openvpn_ipv6hdr::nexthdr	proto.h	/^    uint8_t nexthdr;$/;"	m	struct:openvpn_ipv6hdr	access:public
openvpn_ipv6hdr::payload_len	proto.h	/^    uint16_t payload_len;$/;"	m	struct:openvpn_ipv6hdr	access:public
openvpn_ipv6hdr::saddr	proto.h	/^    struct  in6_addr saddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr	access:public
openvpn_ipv6hdr::version_prio	proto.h	/^    uint8_t version_prio;$/;"	m	struct:openvpn_ipv6hdr	access:public
openvpn_main	openvpn.c	/^openvpn_main(int argc, char *argv[])$/;"	f	file:	signature:(int argc, char *argv[])
openvpn_name	crypto_backend.h	/^    const char *openvpn_name;   \/**< Cipher name used by OpenVPN *\/$/;"	m	struct:__anon16	access:public
openvpn_plugin_string_list_find	plugin.c	/^openvpn_plugin_string_list_find(struct openvpn_plugin_string_list *l, const char *name)$/;"	f	file:	signature:(struct openvpn_plugin_string_list *l, const char *name)
openvpn_plugin_string_list_free	plugin.c	/^openvpn_plugin_string_list_free(struct openvpn_plugin_string_list *l)$/;"	f	file:	signature:(struct openvpn_plugin_string_list *l)
openvpn_plugin_string_list_item_free	plugin.c	/^openvpn_plugin_string_list_item_free(struct openvpn_plugin_string_list *l)$/;"	f	file:	signature:(struct openvpn_plugin_string_list *l)
openvpn_popen	misc.c	/^openvpn_popen(const struct argv *a,  const struct env_set *es)$/;"	f	signature:(const struct argv *a, const struct env_set *es)
openvpn_popen	misc.h	/^int openvpn_popen(const struct argv *a,  const struct env_set *es);$/;"	p	signature:(const struct argv *a, const struct env_set *es)
openvpn_run_script	misc.h	/^openvpn_run_script(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *hook)$/;"	f	signature:(const struct argv *a, const struct env_set *es, const unsigned int flags, const char *hook)
openvpn_snprintf	buffer.c	/^openvpn_snprintf(char *str, size_t size, const char *format, ...)$/;"	f	signature:(char *str, size_t size, const char *format, ...)
openvpn_snprintf	buffer.h	/^bool openvpn_snprintf(char *str, size_t size, const char *format, ...)$/;"	p	signature:(char *str, size_t size, const char *format, ...)
openvpn_sockaddr	socket.h	/^struct openvpn_sockaddr$/;"	s
openvpn_sockaddr::__anon13::in4	socket.h	/^        struct sockaddr_in in4;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr_in	access:public
openvpn_sockaddr::__anon13::in6	socket.h	/^        struct sockaddr_in6 in6;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr_in6	access:public
openvpn_sockaddr::__anon13::sa	socket.h	/^        struct sockaddr sa;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr	access:public
openvpn_sockaddr::addr	socket.h	/^    } addr;$/;"	m	struct:openvpn_sockaddr	typeref:union:openvpn_sockaddr::__anon13	access:public
openvpn_strerror	error.h	75;"	d
openvpn_strerror	error.h	80;"	d
openvpn_tcphdr	proto.h	/^struct openvpn_tcphdr {$/;"	s
openvpn_tcphdr::ack_seq	proto.h	/^    uint32_t ack_seq;      \/* acknowledgement number *\/$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::dest	proto.h	/^    uint16_t dest;         \/* destination port *\/$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::doff_res	proto.h	/^    uint8_t doff_res;$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::flags	proto.h	/^    uint8_t flags;$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::seq	proto.h	/^    uint32_t seq;          \/* sequence number *\/$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::source	proto.h	/^    uint16_t source;       \/* source port *\/$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::urg_ptr	proto.h	/^    uint16_t urg_ptr;$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_tcphdr::window	proto.h	/^    uint16_t window;$/;"	m	struct:openvpn_tcphdr	access:public
openvpn_time	otime.h	/^openvpn_time(time_t *t)$/;"	f	signature:(time_t *t)
openvpn_udphdr	proto.h	/^struct openvpn_udphdr {$/;"	s
openvpn_udphdr::check	proto.h	/^    uint16_t check;$/;"	m	struct:openvpn_udphdr	access:public
openvpn_udphdr::dest	proto.h	/^    uint16_t dest;$/;"	m	struct:openvpn_udphdr	access:public
openvpn_udphdr::len	proto.h	/^    uint16_t len;$/;"	m	struct:openvpn_udphdr	access:public
openvpn_udphdr::source	proto.h	/^    uint16_t source;$/;"	m	struct:openvpn_udphdr	access:public
openvpn_x509_cert_t	ssl_verify_mbedtls.h	/^typedef mbedtls_x509_crt openvpn_x509_cert_t;$/;"	t
openvpn_x509_cert_t	ssl_verify_openssl.h	/^typedef X509 openvpn_x509_cert_t;$/;"	t
openvpn_x509_crt_profile_legacy	ssl_mbedtls.c	/^static const mbedtls_x509_crt_profile openvpn_x509_crt_profile_legacy =$/;"	v	file:
openvpn_x509_crt_profile_preferred	ssl_mbedtls.c	/^static const mbedtls_x509_crt_profile openvpn_x509_crt_profile_preferred =$/;"	v	file:
openvpn_x509_crt_profile_suiteb	ssl_mbedtls.c	90;"	d	file:
opt	ssl_common.h	/^    struct crypto_options opt;  \/**< Crypto state *\/$/;"	m	struct:tls_wrap_ctx	typeref:struct:tls_wrap_ctx::crypto_options	access:public
opt	ssl_common.h	/^    struct tls_options *opt;$/;"	m	struct:tls_session	typeref:struct:tls_session::tls_options	access:public
opt	ssl_common.h	/^    struct tls_options opt;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_options	access:public
optimal_fragment_size	fragment.c	/^optimal_fragment_size(int len, int max_frag_size)$/;"	f	file:	signature:(int len, int max_frag_size)
option	pushlist.h	/^    const char *option;$/;"	m	struct:push_entry	access:public
option	route.h	/^    const struct route_option *option;$/;"	m	struct:route_ipv4	typeref:struct:route_ipv4::route_option	access:public
option_iroute	options.c	/^option_iroute(struct options *o,$/;"	f	file:	signature:(struct options *o, const char *network_str, const char *netmask_str, int msglevel)
option_iroute_ipv6	options.c	/^option_iroute_ipv6(struct options *o,$/;"	f	file:	signature:(struct options *o, const char *prefix_str, int msglevel)
options	dhcp.h	/^    uint8_t options[DHCP_OPTIONS_BUFFER_SIZE];$/;"	m	struct:dhcp_full	access:public
options	openvpn.h	/^    struct options options;     \/**< Options loaded from command line or$/;"	m	struct:context	typeref:struct:context::options	access:public
options	options.h	/^struct options$/;"	s
options	proxy.h	/^    struct http_proxy_options options;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::http_proxy_options	access:public
options	tun.h	/^    struct tuntap_options options; \/* options set on command line *\/$/;"	m	struct:tuntap	typeref:struct:tuntap::tuntap_options	access:public
options::allow_pull_fqdn	options.h	/^    bool allow_pull_fqdn; \/* as a client, allow server to push a FQDN for certain parameters *\/$/;"	m	struct:options	access:public
options::allow_recursive_routing	options.h	/^    bool allow_recursive_routing;$/;"	m	struct:options	access:public
options::auth_token_generate	options.h	/^    bool auth_token_generate;$/;"	m	struct:options	access:public
options::auth_token_lifetime	options.h	/^    unsigned int auth_token_lifetime;$/;"	m	struct:options	access:public
options::auth_user_pass_file	options.h	/^    const char *auth_user_pass_file;$/;"	m	struct:options	access:public
options::auth_user_pass_verify_script	options.h	/^    const char *auth_user_pass_verify_script;$/;"	m	struct:options	access:public
options::auth_user_pass_verify_script_via_file	options.h	/^    bool auth_user_pass_verify_script_via_file;$/;"	m	struct:options	access:public
options::authname	options.h	/^    const char *authname;$/;"	m	struct:options	access:public
options::block_outside_dns	options.h	/^    bool block_outside_dns;$/;"	m	struct:options	access:public
options::ca_file	options.h	/^    const char *ca_file;$/;"	m	struct:options	access:public
options::ca_file_inline	options.h	/^    const char *ca_file_inline;$/;"	m	struct:options	access:public
options::ca_path	options.h	/^    const char *ca_path;$/;"	m	struct:options	access:public
options::ccd_exclusive	options.h	/^    bool ccd_exclusive;$/;"	m	struct:options	access:public
options::cd_dir	options.h	/^    const char *cd_dir;$/;"	m	struct:options	access:public
options::ce	options.h	/^    struct connection_entry ce;$/;"	m	struct:options	typeref:struct:options::connection_entry	access:public
options::cert_file	options.h	/^    const char *cert_file;$/;"	m	struct:options	access:public
options::cert_file_inline	options.h	/^    const char *cert_file_inline;$/;"	m	struct:options	access:public
options::cf_max	options.h	/^    int cf_max;$/;"	m	struct:options	access:public
options::cf_per	options.h	/^    int cf_per;$/;"	m	struct:options	access:public
options::chroot_dir	options.h	/^    const char *chroot_dir;$/;"	m	struct:options	access:public
options::cipher_list	options.h	/^    const char *cipher_list;$/;"	m	struct:options	access:public
options::cipher_list_tls13	options.h	/^    const char *cipher_list_tls13;$/;"	m	struct:options	access:public
options::ciphername	options.h	/^    const char *ciphername;$/;"	m	struct:options	access:public
options::client	options.h	/^    bool client;$/;"	m	struct:options	access:public
options::client_config_dir	options.h	/^    const char *client_config_dir;$/;"	m	struct:options	access:public
options::client_connect_script	options.h	/^    const char *client_connect_script;$/;"	m	struct:options	access:public
options::client_disconnect_script	options.h	/^    const char *client_disconnect_script;$/;"	m	struct:options	access:public
options::client_nat	options.h	/^    struct client_nat_option_list *client_nat;$/;"	m	struct:options	typeref:struct:options::client_nat_option_list	access:public
options::comp	options.h	/^    struct compress_options comp;$/;"	m	struct:options	typeref:struct:options::compress_options	access:public
options::config	options.h	/^    const char *config;$/;"	m	struct:options	access:public
options::connect_retry_max	options.h	/^    int connect_retry_max;$/;"	m	struct:options	access:public
options::connection_list	options.h	/^    struct connection_list *connection_list;$/;"	m	struct:options	typeref:struct:options::connection_list	access:public
options::crl_file	options.h	/^    const char *crl_file;$/;"	m	struct:options	access:public
options::crl_file_inline	options.h	/^    const char *crl_file_inline;$/;"	m	struct:options	access:public
options::cryptoapi_cert	options.h	/^    const char *cryptoapi_cert;$/;"	m	struct:options	access:public
options::daemon	options.h	/^    bool daemon;$/;"	m	struct:options	access:public
options::dev	options.h	/^    const char *dev;$/;"	m	struct:options	access:public
options::dev_node	options.h	/^    const char *dev_node;$/;"	m	struct:options	access:public
options::dev_type	options.h	/^    const char *dev_type;$/;"	m	struct:options	access:public
options::dh_file	options.h	/^    const char *dh_file;$/;"	m	struct:options	access:public
options::dh_file_inline	options.h	/^    const char *dh_file_inline;$/;"	m	struct:options	access:public
options::disable	options.h	/^    bool disable;$/;"	m	struct:options	access:public
options::down_pre	options.h	/^    bool down_pre;$/;"	m	struct:options	access:public
options::down_script	options.h	/^    const char *down_script;$/;"	m	struct:options	access:public
options::duplicate_cn	options.h	/^    bool duplicate_cn;$/;"	m	struct:options	access:public
options::ecdh_curve	options.h	/^    const char *ecdh_curve;$/;"	m	struct:options	access:public
options::enable_c2c	options.h	/^    bool enable_c2c;$/;"	m	struct:options	access:public
options::engine	options.h	/^    const char *engine;$/;"	m	struct:options	access:public
options::exit_event_initial_state	options.h	/^    bool exit_event_initial_state;$/;"	m	struct:options	access:public
options::exit_event_name	options.h	/^    const char *exit_event_name;$/;"	m	struct:options	access:public
options::extra_certs_file	options.h	/^    const char *extra_certs_file;$/;"	m	struct:options	access:public
options::extra_certs_file_inline	options.h	/^    const char *extra_certs_file_inline;$/;"	m	struct:options	access:public
options::fast_io	options.h	/^    bool fast_io;$/;"	m	struct:options	access:public
options::foreign_option_index	options.h	/^    int foreign_option_index;$/;"	m	struct:options	access:public
options::forward_compatible	options.h	/^    bool forward_compatible;$/;"	m	struct:options	access:public
options::gc	options.h	/^    struct gc_arena gc;$/;"	m	struct:options	typeref:struct:options::gc_arena	access:public
options::gc_owned	options.h	/^    bool gc_owned;$/;"	m	struct:options	access:public
options::genkey	options.h	/^    bool genkey;$/;"	m	struct:options	access:public
options::gremlin	options.h	/^    int gremlin;$/;"	m	struct:options	access:public
options::groupname	options.h	/^    const char *groupname;$/;"	m	struct:options	access:public
options::handshake_window	options.h	/^    int handshake_window;$/;"	m	struct:options	access:public
options::http_proxy_override	options.h	/^    struct http_proxy_options *http_proxy_override;$/;"	m	struct:options	typeref:struct:options::http_proxy_options	access:public
options::ifconfig_ipv6_local	options.h	/^    const char *ifconfig_ipv6_local;$/;"	m	struct:options	access:public
options::ifconfig_ipv6_netbits	options.h	/^    int ifconfig_ipv6_netbits;$/;"	m	struct:options	access:public
options::ifconfig_ipv6_pool_base	options.h	/^    struct in6_addr ifconfig_ipv6_pool_base;            \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
options::ifconfig_ipv6_pool_defined	options.h	/^    bool ifconfig_ipv6_pool_defined;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
options::ifconfig_ipv6_pool_netbits	options.h	/^    int ifconfig_ipv6_pool_netbits;                     \/* IPv6 *\/$/;"	m	struct:options	access:public
options::ifconfig_ipv6_remote	options.h	/^    const char *ifconfig_ipv6_remote;$/;"	m	struct:options	access:public
options::ifconfig_local	options.h	/^    const char *ifconfig_local;$/;"	m	struct:options	access:public
options::ifconfig_noexec	options.h	/^    bool ifconfig_noexec;$/;"	m	struct:options	access:public
options::ifconfig_nowarn	options.h	/^    bool ifconfig_nowarn;$/;"	m	struct:options	access:public
options::ifconfig_pool_defined	options.h	/^    bool ifconfig_pool_defined;$/;"	m	struct:options	access:public
options::ifconfig_pool_end	options.h	/^    in_addr_t ifconfig_pool_end;$/;"	m	struct:options	access:public
options::ifconfig_pool_netmask	options.h	/^    in_addr_t ifconfig_pool_netmask;$/;"	m	struct:options	access:public
options::ifconfig_pool_persist_filename	options.h	/^    const char *ifconfig_pool_persist_filename;$/;"	m	struct:options	access:public
options::ifconfig_pool_persist_refresh_freq	options.h	/^    int ifconfig_pool_persist_refresh_freq;$/;"	m	struct:options	access:public
options::ifconfig_pool_start	options.h	/^    in_addr_t ifconfig_pool_start;$/;"	m	struct:options	access:public
options::ifconfig_remote_netmask	options.h	/^    const char *ifconfig_remote_netmask;$/;"	m	struct:options	access:public
options::ignore_unknown_option	options.h	/^    const char **ignore_unknown_option;$/;"	m	struct:options	access:public
options::inactivity_minimum_bytes	options.h	/^    int inactivity_minimum_bytes;$/;"	m	struct:options	access:public
options::inactivity_timeout	options.h	/^    int inactivity_timeout;     \/* --inactive *\/$/;"	m	struct:options	access:public
options::inetd	options.h	/^    int inetd;$/;"	m	struct:options	access:public
options::ip_remote_hint	options.h	/^    const char *ip_remote_hint;$/;"	m	struct:options	access:public
options::ipchange	options.h	/^    const char *ipchange;$/;"	m	struct:options	access:public
options::iroutes	options.h	/^    struct iroute *iroutes;$/;"	m	struct:options	typeref:struct:options::iroute	access:public
options::iroutes_ipv6	options.h	/^    struct iroute_ipv6 *iroutes_ipv6;                   \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::iroute_ipv6	access:public
options::keepalive_ping	options.h	/^    int keepalive_ping;         \/* a proxy for ping\/ping-restart *\/$/;"	m	struct:options	access:public
options::keepalive_timeout	options.h	/^    int keepalive_timeout;$/;"	m	struct:options	access:public
options::key_direction	options.h	/^    int key_direction;$/;"	m	struct:options	access:public
options::key_method	options.h	/^    int key_method;$/;"	m	struct:options	access:public
options::key_pass_file	options.h	/^    const char *key_pass_file;$/;"	m	struct:options	access:public
options::keying_material_exporter_label	options.h	/^    const char *keying_material_exporter_label;$/;"	m	struct:options	access:public
options::keying_material_exporter_length	options.h	/^    int keying_material_exporter_length;$/;"	m	struct:options	access:public
options::keysize	options.h	/^    int keysize;$/;"	m	struct:options	access:public
options::learn_address_script	options.h	/^    const char *learn_address_script;$/;"	m	struct:options	access:public
options::lladdr	options.h	/^    const char *lladdr;$/;"	m	struct:options	access:public
options::log	options.h	/^    bool log;$/;"	m	struct:options	access:public
options::machine_readable_output	options.h	/^    bool machine_readable_output;$/;"	m	struct:options	access:public
options::management_addr	options.h	/^    const char *management_addr;$/;"	m	struct:options	access:public
options::management_certificate	options.h	/^    const char *management_certificate;$/;"	m	struct:options	access:public
options::management_client_group	options.h	/^    const char *management_client_group;$/;"	m	struct:options	access:public
options::management_client_user	options.h	/^    const char *management_client_user;$/;"	m	struct:options	access:public
options::management_echo_buffer_size	options.h	/^    int management_echo_buffer_size;$/;"	m	struct:options	access:public
options::management_flags	options.h	/^    unsigned int management_flags;$/;"	m	struct:options	access:public
options::management_log_history_cache	options.h	/^    int management_log_history_cache;$/;"	m	struct:options	access:public
options::management_port	options.h	/^    const char *management_port;$/;"	m	struct:options	access:public
options::management_state_buffer_size	options.h	/^    int management_state_buffer_size;$/;"	m	struct:options	access:public
options::management_user_pass	options.h	/^    const char *management_user_pass;$/;"	m	struct:options	access:public
options::management_write_peer_info_file	options.h	/^    const char *management_write_peer_info_file;$/;"	m	struct:options	access:public
options::mark	options.h	/^    int mark;$/;"	m	struct:options	access:public
options::max_clients	options.h	/^    int max_clients;$/;"	m	struct:options	access:public
options::max_routes_per_client	options.h	/^    int max_routes_per_client;$/;"	m	struct:options	access:public
options::memstats_fn	options.h	/^    char *memstats_fn;$/;"	m	struct:options	access:public
options::mlock	options.h	/^    bool mlock;$/;"	m	struct:options	access:public
options::mode	options.h	/^    int mode;$/;"	m	struct:options	access:public
options::msg_channel	options.h	/^    HANDLE msg_channel;$/;"	m	struct:options	access:public
options::mtu_test	options.h	/^    bool mtu_test;$/;"	m	struct:options	access:public
options::mute	options.h	/^    int mute;$/;"	m	struct:options	access:public
options::mute_replay_warnings	options.h	/^    bool mute_replay_warnings;$/;"	m	struct:options	access:public
options::n_bcast_buf	options.h	/^    int n_bcast_buf;$/;"	m	struct:options	access:public
options::ncp_ciphers	options.h	/^    const char *ncp_ciphers;$/;"	m	struct:options	access:public
options::ncp_enabled	options.h	/^    bool ncp_enabled;$/;"	m	struct:options	access:public
options::nice	options.h	/^    int nice;$/;"	m	struct:options	access:public
options::no_advance	options.h	/^    bool no_advance;$/;"	m	struct:options	access:public
options::ns_cert_type	options.h	/^    int ns_cert_type; \/* set to 0, NS_CERT_CHECK_SERVER, or NS_CERT_CHECK_CLIENT *\/$/;"	m	struct:options	access:public
options::occ	options.h	/^    bool occ;$/;"	m	struct:options	access:public
options::packet_id_file	options.h	/^    const char *packet_id_file;$/;"	m	struct:options	access:public
options::passtos	options.h	/^    bool passtos;$/;"	m	struct:options	access:public
options::peer_id	options.h	/^    uint32_t peer_id;$/;"	m	struct:options	access:public
options::persist_config	options.h	/^    bool persist_config;$/;"	m	struct:options	access:public
options::persist_key	options.h	/^    bool persist_key;           \/* Don't re-read key files on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
options::persist_local_ip	options.h	/^    bool persist_local_ip;      \/* Don't re-resolve local address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
options::persist_mode	options.h	/^    int persist_mode;$/;"	m	struct:options	access:public
options::persist_remote_ip	options.h	/^    bool persist_remote_ip;     \/* Don't re-resolve remote address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
options::persist_tun	options.h	/^    bool persist_tun;           \/* Don't close\/reopen TUN\/TAP dev on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
options::ping_rec_timeout	options.h	/^    int ping_rec_timeout;       \/* Expect a TCP\/UDP ping from remote at least once every n seconds *\/$/;"	m	struct:options	access:public
options::ping_rec_timeout_action	options.h	/^    int ping_rec_timeout_action; \/* What action to take on ping_rec_timeout (exit or restart)? *\/$/;"	m	struct:options	access:public
options::ping_send_timeout	options.h	/^    int ping_send_timeout;      \/* Send a TCP\/UDP ping to remote every n seconds *\/$/;"	m	struct:options	access:public
options::ping_timer_remote	options.h	/^    bool ping_timer_remote;     \/* Run ping timer only if we have a remote address *\/$/;"	m	struct:options	access:public
options::pkcs11_cert_private	options.h	/^    bool pkcs11_cert_private[MAX_PARMS];$/;"	m	struct:options	access:public
options::pkcs11_id	options.h	/^    const char *pkcs11_id;$/;"	m	struct:options	access:public
options::pkcs11_id_management	options.h	/^    bool pkcs11_id_management;$/;"	m	struct:options	access:public
options::pkcs11_pin_cache_period	options.h	/^    int pkcs11_pin_cache_period;$/;"	m	struct:options	access:public
options::pkcs11_private_mode	options.h	/^    unsigned pkcs11_private_mode[MAX_PARMS];$/;"	m	struct:options	access:public
options::pkcs11_protected_authentication	options.h	/^    bool pkcs11_protected_authentication[MAX_PARMS];$/;"	m	struct:options	access:public
options::pkcs11_providers	options.h	/^    const char *pkcs11_providers[MAX_PARMS];$/;"	m	struct:options	access:public
options::pkcs12_file	options.h	/^    const char *pkcs12_file;$/;"	m	struct:options	access:public
options::pkcs12_file_inline	options.h	/^    const char *pkcs12_file_inline; \/* contains the base64 encoding of pkcs12 file *\/$/;"	m	struct:options	access:public
options::plugin_list	options.h	/^    struct plugin_option_list *plugin_list;$/;"	m	struct:options	typeref:struct:options::plugin_option_list	access:public
options::port_share_host	options.h	/^    char *port_share_host;$/;"	m	struct:options	access:public
options::port_share_journal_dir	options.h	/^    const char *port_share_journal_dir;$/;"	m	struct:options	access:public
options::port_share_port	options.h	/^    char *port_share_port;$/;"	m	struct:options	access:public
options::pre_pull	options.h	/^    struct options_pre_pull *pre_pull;$/;"	m	struct:options	typeref:struct:options::options_pre_pull	access:public
options::priv_key_file	options.h	/^    const char *priv_key_file;$/;"	m	struct:options	access:public
options::priv_key_file_inline	options.h	/^    char *priv_key_file_inline;$/;"	m	struct:options	access:public
options::prng_hash	options.h	/^    const char *prng_hash;$/;"	m	struct:options	access:public
options::prng_nonce_secret_len	options.h	/^    int prng_nonce_secret_len;$/;"	m	struct:options	access:public
options::proto_force	options.h	/^    int proto_force;$/;"	m	struct:options	access:public
options::pull	options.h	/^    bool pull; \/* client pull of config options from server *\/$/;"	m	struct:options	access:public
options::pull_filter_list	options.h	/^    struct pull_filter_list *pull_filter_list;$/;"	m	struct:options	typeref:struct:options::pull_filter_list	access:public
options::push_continuation	options.h	/^    int push_continuation;$/;"	m	struct:options	access:public
options::push_ifconfig_constraint_defined	options.h	/^    bool push_ifconfig_constraint_defined;$/;"	m	struct:options	access:public
options::push_ifconfig_constraint_netmask	options.h	/^    in_addr_t push_ifconfig_constraint_netmask;$/;"	m	struct:options	access:public
options::push_ifconfig_constraint_network	options.h	/^    in_addr_t push_ifconfig_constraint_network;$/;"	m	struct:options	access:public
options::push_ifconfig_defined	options.h	/^    bool push_ifconfig_defined;$/;"	m	struct:options	access:public
options::push_ifconfig_ipv6_blocked	options.h	/^    bool push_ifconfig_ipv6_blocked;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
options::push_ifconfig_ipv6_defined	options.h	/^    bool push_ifconfig_ipv6_defined;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
options::push_ifconfig_ipv6_local	options.h	/^    struct in6_addr push_ifconfig_ipv6_local;           \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
options::push_ifconfig_ipv6_netbits	options.h	/^    int push_ifconfig_ipv6_netbits;                     \/* IPv6 *\/$/;"	m	struct:options	access:public
options::push_ifconfig_ipv6_remote	options.h	/^    struct in6_addr push_ifconfig_ipv6_remote;          \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
options::push_ifconfig_local	options.h	/^    in_addr_t push_ifconfig_local;$/;"	m	struct:options	access:public
options::push_ifconfig_local_alias	options.h	/^    in_addr_t push_ifconfig_local_alias;$/;"	m	struct:options	access:public
options::push_ifconfig_remote_netmask	options.h	/^    in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:options	access:public
options::push_list	options.h	/^    struct push_list push_list;$/;"	m	struct:options	typeref:struct:options::push_list	access:public
options::push_option_types_found	options.h	/^    unsigned int push_option_types_found;$/;"	m	struct:options	access:public
options::push_peer_info	options.h	/^    bool push_peer_info;$/;"	m	struct:options	access:public
options::rcvbuf	options.h	/^    int rcvbuf;$/;"	m	struct:options	access:public
options::real_hash_size	options.h	/^    int real_hash_size;$/;"	m	struct:options	access:public
options::remap_sigusr1	options.h	/^    int remap_sigusr1;$/;"	m	struct:options	access:public
options::remote_cert_eku	options.h	/^    const char *remote_cert_eku;$/;"	m	struct:options	access:public
options::remote_cert_ku	options.h	/^    unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:options	access:public
options::remote_list	options.h	/^    struct remote_list *remote_list;$/;"	m	struct:options	typeref:struct:options::remote_list	access:public
options::remote_random	options.h	/^    bool remote_random;$/;"	m	struct:options	access:public
options::renegotiate_bytes	options.h	/^    int renegotiate_bytes;$/;"	m	struct:options	access:public
options::renegotiate_packets	options.h	/^    int renegotiate_packets;$/;"	m	struct:options	access:public
options::renegotiate_seconds	options.h	/^    int renegotiate_seconds;$/;"	m	struct:options	access:public
options::replay	options.h	/^    bool replay;$/;"	m	struct:options	access:public
options::replay_time	options.h	/^    int replay_time;$/;"	m	struct:options	access:public
options::replay_window	options.h	/^    int replay_window;$/;"	m	struct:options	access:public
options::resolve_in_advance	options.h	/^    bool resolve_in_advance;$/;"	m	struct:options	access:public
options::resolve_retry_seconds	options.h	/^    int resolve_retry_seconds;  \/* If hostname resolve fails, retry for n seconds *\/$/;"	m	struct:options	access:public
options::rh_store	options.h	/^    struct remote_host_store *rh_store;$/;"	m	struct:options	typeref:struct:options::remote_host_store	access:public
options::route_default_gateway	options.h	/^    const char *route_default_gateway;$/;"	m	struct:options	access:public
options::route_default_metric	options.h	/^    int route_default_metric;$/;"	m	struct:options	access:public
options::route_delay	options.h	/^    int route_delay;$/;"	m	struct:options	access:public
options::route_delay_defined	options.h	/^    bool route_delay_defined;$/;"	m	struct:options	access:public
options::route_delay_window	options.h	/^    int route_delay_window;$/;"	m	struct:options	access:public
options::route_gateway_via_dhcp	options.h	/^    bool route_gateway_via_dhcp;$/;"	m	struct:options	access:public
options::route_method	options.h	/^    int route_method;$/;"	m	struct:options	access:public
options::route_noexec	options.h	/^    bool route_noexec;$/;"	m	struct:options	access:public
options::route_nopull	options.h	/^    bool route_nopull;$/;"	m	struct:options	access:public
options::route_predown_script	options.h	/^    const char *route_predown_script;$/;"	m	struct:options	access:public
options::route_script	options.h	/^    const char *route_script;$/;"	m	struct:options	access:public
options::routes	options.h	/^    struct route_option_list *routes;$/;"	m	struct:options	typeref:struct:options::route_option_list	access:public
options::routes_ipv6	options.h	/^    struct route_ipv6_option_list *routes_ipv6;                 \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::route_ipv6_option_list	access:public
options::sc_info	options.h	/^    struct static_challenge_info sc_info;$/;"	m	struct:options	typeref:struct:options::static_challenge_info	access:public
options::scheduled_exit_interval	options.h	/^    int scheduled_exit_interval;$/;"	m	struct:options	access:public
options::selinux_context	options.h	/^    char *selinux_context;$/;"	m	struct:options	access:public
options::server_bridge_defined	options.h	/^    bool server_bridge_defined;$/;"	m	struct:options	access:public
options::server_bridge_ip	options.h	/^    in_addr_t server_bridge_ip;$/;"	m	struct:options	access:public
options::server_bridge_netmask	options.h	/^    in_addr_t server_bridge_netmask;$/;"	m	struct:options	access:public
options::server_bridge_pool_end	options.h	/^    in_addr_t server_bridge_pool_end;$/;"	m	struct:options	access:public
options::server_bridge_pool_start	options.h	/^    in_addr_t server_bridge_pool_start;$/;"	m	struct:options	access:public
options::server_bridge_proxy_dhcp	options.h	/^    bool server_bridge_proxy_dhcp;$/;"	m	struct:options	access:public
options::server_defined	options.h	/^    bool server_defined;$/;"	m	struct:options	access:public
options::server_flags	options.h	/^    unsigned int server_flags;$/;"	m	struct:options	access:public
options::server_ipv6_defined	options.h	/^    bool server_ipv6_defined;                           \/* IPv6 *\/$/;"	m	struct:options	access:public
options::server_netbits_ipv6	options.h	/^    unsigned int server_netbits_ipv6;                   \/* IPv6 *\/$/;"	m	struct:options	access:public
options::server_netmask	options.h	/^    in_addr_t server_netmask;$/;"	m	struct:options	access:public
options::server_network	options.h	/^    in_addr_t server_network;$/;"	m	struct:options	access:public
options::server_network_ipv6	options.h	/^    struct in6_addr server_network_ipv6;                \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
options::shaper	options.h	/^    int shaper;$/;"	m	struct:options	access:public
options::shared_secret_file	options.h	/^    const char *shared_secret_file;$/;"	m	struct:options	access:public
options::shared_secret_file_inline	options.h	/^    const char *shared_secret_file_inline;$/;"	m	struct:options	access:public
options::show_ciphers	options.h	/^    bool show_ciphers;$/;"	m	struct:options	access:public
options::show_curves	options.h	/^    bool show_curves;$/;"	m	struct:options	access:public
options::show_digests	options.h	/^    bool show_digests;$/;"	m	struct:options	access:public
options::show_engines	options.h	/^    bool show_engines;$/;"	m	struct:options	access:public
options::show_net_up	options.h	/^    bool show_net_up;$/;"	m	struct:options	access:public
options::show_tls_ciphers	options.h	/^    bool show_tls_ciphers;$/;"	m	struct:options	access:public
options::single_session	options.h	/^    bool single_session;$/;"	m	struct:options	access:public
options::sndbuf	options.h	/^    int sndbuf;$/;"	m	struct:options	access:public
options::sockflags	options.h	/^    unsigned int sockflags;$/;"	m	struct:options	access:public
options::ssl_flags	options.h	/^    unsigned int ssl_flags; \/* set to SSLF_x flags from ssl.h *\/$/;"	m	struct:options	access:public
options::stale_routes_ageing_time	options.h	/^    int stale_routes_ageing_time;$/;"	m	struct:options	access:public
options::stale_routes_check_interval	options.h	/^    int stale_routes_check_interval;$/;"	m	struct:options	access:public
options::status_file	options.h	/^    const char *status_file;$/;"	m	struct:options	access:public
options::status_file_update_freq	options.h	/^    int status_file_update_freq;$/;"	m	struct:options	access:public
options::status_file_version	options.h	/^    int status_file_version;$/;"	m	struct:options	access:public
options::suppress_timestamps	options.h	/^    bool suppress_timestamps;$/;"	m	struct:options	access:public
options::tcp_queue_limit	options.h	/^    int tcp_queue_limit;$/;"	m	struct:options	access:public
options::test_crypto	options.h	/^    bool test_crypto;$/;"	m	struct:options	access:public
options::tls_auth_file	options.h	/^    const char *tls_auth_file;$/;"	m	struct:options	access:public
options::tls_auth_file_inline	options.h	/^    const char *tls_auth_file_inline;$/;"	m	struct:options	access:public
options::tls_cert_profile	options.h	/^    const char *tls_cert_profile;$/;"	m	struct:options	access:public
options::tls_client	options.h	/^    bool tls_client;$/;"	m	struct:options	access:public
options::tls_crypt_file	options.h	/^    const char *tls_crypt_file;$/;"	m	struct:options	access:public
options::tls_crypt_inline	options.h	/^    const char *tls_crypt_inline;$/;"	m	struct:options	access:public
options::tls_exit	options.h	/^    bool tls_exit;$/;"	m	struct:options	access:public
options::tls_export_cert	options.h	/^    const char *tls_export_cert;$/;"	m	struct:options	access:public
options::tls_server	options.h	/^    bool tls_server;$/;"	m	struct:options	access:public
options::tls_timeout	options.h	/^    int tls_timeout;$/;"	m	struct:options	access:public
options::tls_verify	options.h	/^    const char *tls_verify;$/;"	m	struct:options	access:public
options::tmp_dir	options.h	/^    const char *tmp_dir;$/;"	m	struct:options	access:public
options::topology	options.h	/^    int topology; \/* one of the TOP_x values from proto.h *\/$/;"	m	struct:options	access:public
options::transition_window	options.h	/^    int transition_window;$/;"	m	struct:options	access:public
options::tuntap_options	options.h	/^    struct tuntap_options tuntap_options;$/;"	m	struct:options	typeref:struct:options::tuntap_options	access:public
options::unsuccessful_attempts	options.h	/^    unsigned int unsuccessful_attempts;$/;"	m	struct:options	access:public
options::up_delay	options.h	/^    bool up_delay;$/;"	m	struct:options	access:public
options::up_restart	options.h	/^    bool up_restart;$/;"	m	struct:options	access:public
options::up_script	options.h	/^    const char *up_script;$/;"	m	struct:options	access:public
options::use_iv	options.h	/^    bool use_iv;$/;"	m	struct:options	access:public
options::use_peer_id	options.h	/^    bool use_peer_id;$/;"	m	struct:options	access:public
options::use_prediction_resistance	options.h	/^    bool use_prediction_resistance;$/;"	m	struct:options	access:public
options::user_script_used	options.h	/^    bool user_script_used;$/;"	m	struct:options	access:public
options::username	options.h	/^    const char *username;$/;"	m	struct:options	access:public
options::verbosity	options.h	/^    int verbosity;$/;"	m	struct:options	access:public
options::verify_hash	options.h	/^    uint8_t *verify_hash;$/;"	m	struct:options	access:public
options::verify_hash_algo	options.h	/^    hash_algo_type verify_hash_algo;$/;"	m	struct:options	access:public
options::verify_x509_name	options.h	/^    const char *verify_x509_name;$/;"	m	struct:options	access:public
options::verify_x509_type	options.h	/^    int verify_x509_type;$/;"	m	struct:options	access:public
options::virtual_hash_size	options.h	/^    int virtual_hash_size;$/;"	m	struct:options	access:public
options::writepid	options.h	/^    const char *writepid;$/;"	m	struct:options	access:public
options::x509_track	options.h	/^    const struct x509_track *x509_track;$/;"	m	struct:options	typeref:struct:options::x509_track	access:public
options::x509_username_field	options.h	/^    char *x509_username_field;$/;"	m	struct:options	access:public
options_cmp_equal	options.c	/^options_cmp_equal(char *actual, const char *expected)$/;"	f	signature:(char *actual, const char *expected)
options_cmp_equal	options.h	/^bool options_cmp_equal(char *actual, const char *expected);$/;"	p	signature:(char *actual, const char *expected)
options_cmp_equal_safe	options.c	/^options_cmp_equal_safe(char *actual, const char *expected, size_t actual_n)$/;"	f	signature:(char *actual, const char *expected, size_t actual_n)
options_cmp_equal_safe	options.h	/^bool options_cmp_equal_safe(char *actual, const char *expected, size_t actual_n);$/;"	p	signature:(char *actual, const char *expected, size_t actual_n)
options_detach	options.c	/^options_detach(struct options *o)$/;"	f	signature:(struct options *o)
options_detach	options.h	/^void options_detach(struct options *o);$/;"	p	signature:(struct options *o)
options_hash_changed_or_zero	init.c	/^options_hash_changed_or_zero(const struct sha256_digest *a,$/;"	f	file:	signature:(const struct sha256_digest *a, const struct sha256_digest *b)
options_postprocess	options.c	/^options_postprocess(struct options *options)$/;"	f	signature:(struct options *options)
options_postprocess	options.h	/^void options_postprocess(struct options *options);$/;"	p	signature:(struct options *options)
options_postprocess_filechecks	options.c	/^options_postprocess_filechecks(struct options *options)$/;"	f	file:	signature:(struct options *options)
options_postprocess_http_proxy_override	options.c	/^options_postprocess_http_proxy_override(struct options *o)$/;"	f	file:	signature:(struct options *o)
options_postprocess_mutate	options.c	/^options_postprocess_mutate(struct options *o)$/;"	f	file:	signature:(struct options *o)
options_postprocess_mutate_ce	options.c	/^options_postprocess_mutate_ce(struct options *o, struct connection_entry *ce)$/;"	f	file:	signature:(struct options *o, struct connection_entry *ce)
options_postprocess_mutate_invariant	options.c	/^options_postprocess_mutate_invariant(struct options *options)$/;"	f	file:	signature:(struct options *options)
options_postprocess_verify	options.c	/^options_postprocess_verify(const struct options *o)$/;"	f	file:	signature:(const struct options *o)
options_postprocess_verify_ce	options.c	/^options_postprocess_verify_ce(const struct options *options, const struct connection_entry *ce)$/;"	f	file:	signature:(const struct options *options, const struct connection_entry *ce)
options_pre_pull	options.h	/^struct options_pre_pull$/;"	s
options_pre_pull::client_nat	options.h	/^    struct client_nat_option_list *client_nat;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::client_nat_option_list	access:public
options_pre_pull::client_nat_defined	options.h	/^    bool client_nat_defined;$/;"	m	struct:options_pre_pull	access:public
options_pre_pull::foreign_option_index	options.h	/^    int foreign_option_index;$/;"	m	struct:options_pre_pull	access:public
options_pre_pull::routes	options.h	/^    struct route_option_list *routes;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_option_list	access:public
options_pre_pull::routes_defined	options.h	/^    bool routes_defined;$/;"	m	struct:options_pre_pull	access:public
options_pre_pull::routes_ipv6	options.h	/^    struct route_ipv6_option_list *routes_ipv6;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_ipv6_option_list	access:public
options_pre_pull::routes_ipv6_defined	options.h	/^    bool routes_ipv6_defined;$/;"	m	struct:options_pre_pull	access:public
options_pre_pull::tuntap_options	options.h	/^    struct tuntap_options tuntap_options;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::tuntap_options	access:public
options_pre_pull::tuntap_options_defined	options.h	/^    bool tuntap_options_defined;$/;"	m	struct:options_pre_pull	access:public
options_server_import	options.c	/^options_server_import(struct options *o,$/;"	f	signature:(struct options *o, const char *filename, int msglevel, unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
options_server_import	options.h	/^void options_server_import(struct options *o,$/;"	p	signature:(struct options *o, const char *filename, int msglevel, unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
options_string	options.c	/^options_string(const struct options *o,$/;"	f	signature:(const struct options *o, const struct frame *frame, struct tuntap *tt, bool remote, struct gc_arena *gc)
options_string	options.h	/^char *options_string(const struct options *o,$/;"	p	signature:(const struct options *o, const struct frame *frame, struct tuntap *tt, bool remote, struct gc_arena *gc)
options_string_extract_option	options.c	/^options_string_extract_option(const char *options_string,const char *opt_name,$/;"	f	signature:(const char *options_string,const char *opt_name, struct gc_arena *gc)
options_string_extract_option	options.h	/^char *options_string_extract_option(const char *options_string,$/;"	p	signature:(const char *options_string, const char *opt_name, struct gc_arena *gc)
options_string_import	options.c	/^options_string_import(struct options *options,$/;"	f	signature:(struct options *options, const char *config, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
options_string_import	options.h	/^void options_string_import(struct options *options,$/;"	p	signature:(struct options *options, const char *config, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
options_string_local	openvpn.h	/^    char *options_string_local;$/;"	m	struct:context_2	access:public
options_string_remote	openvpn.h	/^    char *options_string_remote;$/;"	m	struct:context_2	access:public
options_string_version	options.c	/^options_string_version(const char *s, struct gc_arena *gc)$/;"	f	signature:(const char *s, struct gc_arena *gc)
options_string_version	options.h	/^const char *options_string_version(const char *s, struct gc_arena *gc);$/;"	p	signature:(const char *s, struct gc_arena *gc)
options_warning	options.c	/^options_warning(char *actual, const char *expected)$/;"	f	signature:(char *actual, const char *expected)
options_warning	options.h	/^void options_warning(char *actual, const char *expected);$/;"	p	signature:(char *actual, const char *expected)
options_warning_extract_parm1	options.c	/^options_warning_extract_parm1(const char *option_string,$/;"	f	file:	signature:(const char *option_string, struct gc_arena *gc_ret)
options_warning_safe	options.c	/^options_warning_safe(char *actual, const char *expected, size_t actual_n)$/;"	f	signature:(char *actual, const char *expected, size_t actual_n)
options_warning_safe	options.h	/^void options_warning_safe(char *actual, const char *expected, size_t actual_n);$/;"	p	signature:(char *actual, const char *expected, size_t actual_n)
options_warning_safe_ml	options.c	/^options_warning_safe_ml(const int msglevel, char *actual, const char *expected, size_t actual_n)$/;"	f	file:	signature:(const int msglevel, char *actual, const char *expected, size_t actual_n)
options_warning_safe_scan1	options.c	/^options_warning_safe_scan1(const int msglevel,$/;"	f	file:	signature:(const int msglevel, const int delim, const bool report_inconsistent, const struct buffer *b1_src, const struct buffer *b2_src, const char *b1_name, const char *b2_name)
options_warning_safe_scan2	options.c	/^options_warning_safe_scan2(const int msglevel,$/;"	f	file:	signature:(const int msglevel, const int delim, const bool report_inconsistent, const char *p1, const struct buffer *b2_src, const char *b1_name, const char *b2_name)
orig_stderr	error.c	/^static HANDLE orig_stderr;$/;"	v	file:
original_recv_size	openvpn.h	/^    int original_recv_size;     \/* temporary *\/$/;"	m	struct:context_2	access:public
out	manage.h	/^    struct buffer_list *out;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
out	ssl_mbedtls.h	/^    endless_buffer out;$/;"	m	struct:__anon12	access:public
out_key	crypto.h	/^    int out_key;                \/**< Index into the \\c key2.keys array for$/;"	m	struct:key_direction_state	access:public
out_of_memory	error.c	/^out_of_memory(void)$/;"	f	signature:(void)
out_of_memory	error.h	/^void out_of_memory(void);$/;"	p	signature:(void)
outgoing	fragment.h	/^    struct buffer outgoing;     \/**< Buffer containing the remaining parts$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer	access:public
outgoing_frag_id	fragment.h	/^    int outgoing_frag_id;       \/**< The fragment ID of the next part to$/;"	m	struct:fragment_master	access:public
outgoing_frag_size	fragment.h	/^    int outgoing_frag_size;     \/**< Size in bytes of each part to be$/;"	m	struct:fragment_master	access:public
outgoing_return	fragment.h	/^    struct buffer outgoing_return;$/;"	m	struct:fragment_master	typeref:struct:fragment_master::buffer	access:public
outgoing_seq_id	fragment.h	/^    int outgoing_seq_id;        \/**< Fragment sequence ID of the current$/;"	m	struct:fragment_master	access:public
output_peer_info_env	misc.c	/^output_peer_info_env(struct env_set *es, const char *peer_info)$/;"	f	signature:(struct env_set *es, const char *peer_info)
output_peer_info_env	misc.h	/^void output_peer_info_env(struct env_set *es, const char *peer_info);$/;"	p	signature:(struct env_set *es, const char *peer_info)
overlapped	win32.h	/^    OVERLAPPED overlapped;$/;"	m	struct:overlapped_io	access:public
overlapped_io	win32.h	/^struct overlapped_io {$/;"	s
overlapped_io::__anon10::addr	win32.h	/^        struct sockaddr_in addr;$/;"	m	union:overlapped_io::__anon10	typeref:struct:overlapped_io::__anon10::sockaddr_in	access:public
overlapped_io::__anon10::addr6	win32.h	/^        struct sockaddr_in6 addr6;$/;"	m	union:overlapped_io::__anon10	typeref:struct:overlapped_io::__anon10::sockaddr_in6	access:public
overlapped_io::addr_defined	win32.h	/^    bool addr_defined;$/;"	m	struct:overlapped_io	access:public
overlapped_io::addrlen	win32.h	/^    int addrlen;$/;"	m	struct:overlapped_io	access:public
overlapped_io::buf	win32.h	/^    struct buffer buf;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer	access:public
overlapped_io::buf_init	win32.h	/^    struct buffer buf_init;$/;"	m	struct:overlapped_io	typeref:struct:overlapped_io::buffer	access:public
overlapped_io::flags	win32.h	/^    DWORD flags;$/;"	m	struct:overlapped_io	access:public
overlapped_io::iostate	win32.h	/^    int iostate;$/;"	m	struct:overlapped_io	access:public
overlapped_io::overlapped	win32.h	/^    OVERLAPPED overlapped;$/;"	m	struct:overlapped_io	access:public
overlapped_io::size	win32.h	/^    DWORD size;$/;"	m	struct:overlapped_io	access:public
overlapped_io::status	win32.h	/^    int status;$/;"	m	struct:overlapped_io	access:public
overlapped_io_active	win32.h	/^overlapped_io_active(struct overlapped_io *o)$/;"	f	signature:(struct overlapped_io *o)
overlapped_io_close	win32.c	/^overlapped_io_close(struct overlapped_io *o)$/;"	f	signature:(struct overlapped_io *o)
overlapped_io_close	win32.h	/^void overlapped_io_close(struct overlapped_io *o);$/;"	p	signature:(struct overlapped_io *o)
overlapped_io_init	win32.c	/^overlapped_io_init(struct overlapped_io *o,$/;"	f	signature:(struct overlapped_io *o, const struct frame *frame, BOOL event_state, bool tuntap_buffer)
overlapped_io_init	win32.h	/^void overlapped_io_init(struct overlapped_io *o,$/;"	p	signature:(struct overlapped_io *o, const struct frame *frame, BOOL event_state, bool tuntap_buffer)
overlapped_io_state_ascii	win32.c	/^overlapped_io_state_ascii(const struct overlapped_io *o)$/;"	f	signature:(const struct overlapped_io *o)
overlapped_io_state_ascii	win32.h	/^char *overlapped_io_state_ascii(const struct overlapped_io *o);$/;"	p	signature:(const struct overlapped_io *o)
p2mp_iow_flags	mudp.c	/^p2mp_iow_flags(const struct multi_context *m)$/;"	f	file:	signature:(const struct multi_context *m)
p2p_iow_flags	forward-inline.h	/^p2p_iow_flags(const struct context *c)$/;"	f	signature:(const struct context *c)
packet_flood_data	gremlin.c	/^static const struct packet_flood_parms packet_flood_data[] =$/;"	v	typeref:struct:packet_flood_parms	file:
packet_flood_parms	gremlin.h	/^struct packet_flood_parms$/;"	s
packet_flood_parms::n_packets	gremlin.h	/^    int n_packets;$/;"	m	struct:packet_flood_parms	access:public
packet_flood_parms::packet_size	gremlin.h	/^    int packet_size;$/;"	m	struct:packet_flood_parms	access:public
packet_id	crypto.h	/^    struct packet_id packet_id; \/**< Current packet ID state for both$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id	access:public
packet_id	packet_id.h	/^struct packet_id$/;"	s
packet_id	reliable.h	/^    packet_id_type packet_id;$/;"	m	struct:reliable	access:public
packet_id	reliable.h	/^    packet_id_type packet_id;$/;"	m	struct:reliable_entry	access:public
packet_id	reliable.h	/^    packet_id_type packet_id[RELIABLE_ACK_SIZE];$/;"	m	struct:reliable_ack	access:public
packet_id::rec	packet_id.h	/^    struct packet_id_rec rec;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_rec	access:public
packet_id::send	packet_id.h	/^    struct packet_id_send send;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_send	access:public
packet_id_add	packet_id.c	/^packet_id_add(struct packet_id_rec *p, const struct packet_id_net *pin)$/;"	f	signature:(struct packet_id_rec *p, const struct packet_id_net *pin)
packet_id_add	packet_id.h	/^void packet_id_add(struct packet_id_rec *p,$/;"	p	signature:(struct packet_id_rec *p, const struct packet_id_net *pin)
packet_id_close_to_wrapping	packet_id.h	/^packet_id_close_to_wrapping(const struct packet_id_send *p)$/;"	f	signature:(const struct packet_id_send *p)
packet_id_debug	packet_id.c	/^packet_id_debug(int msglevel,$/;"	f	file:	signature:(int msglevel, const struct packet_id_rec *p, const struct packet_id_net *pin, const char *message, int value)
packet_id_debug_print	packet_id.c	/^packet_id_debug_print(int msglevel,$/;"	f	file:	signature:(int msglevel, const struct packet_id_rec *p, const struct packet_id_net *pin, const char *message, int value)
packet_id_debug_print	packet_id.c	/^static void packet_id_debug_print(int msglevel,$/;"	p	file:	signature:(int msglevel, const struct packet_id_rec *p, const struct packet_id_net *pin, const char *message, int value)
packet_id_file	options.h	/^    const char *packet_id_file;$/;"	m	struct:options	access:public
packet_id_format	packet_id.h	97;"	d
packet_id_free	packet_id.c	/^packet_id_free(struct packet_id *p)$/;"	f	signature:(struct packet_id *p)
packet_id_free	packet_id.h	/^void packet_id_free(struct packet_id *p);$/;"	p	signature:(struct packet_id *p)
packet_id_init	packet_id.c	/^packet_id_init(struct packet_id *p, int seq_backtrack, int time_backtrack, const char *name, int unit)$/;"	f	signature:(struct packet_id *p, int seq_backtrack, int time_backtrack, const char *name, int unit)
packet_id_init	packet_id.h	/^void packet_id_init(struct packet_id *p, int seq_backtrack, int time_backtrack, const char *name, int unit);$/;"	p	signature:(struct packet_id *p, int seq_backtrack, int time_backtrack, const char *name, int unit)
packet_id_initialized	packet_id.h	/^packet_id_initialized(const struct packet_id *pid)$/;"	f	signature:(const struct packet_id *pid)
packet_id_interactive_test	packet_id.c	/^packet_id_interactive_test(void)$/;"	f	signature:(void)
packet_id_interactive_test	packet_id.h	/^void packet_id_interactive_test(void);$/;"	p	signature:(void)
packet_id_net	packet_id.h	/^struct packet_id_net$/;"	s
packet_id_net::id	packet_id.h	/^    packet_id_type id;$/;"	m	struct:packet_id_net	access:public
packet_id_net::time	packet_id.h	/^    time_t time; \/* converted to net_time_t before transmission *\/$/;"	m	struct:packet_id_net	access:public
packet_id_net_print	packet_id.c	/^packet_id_net_print(const struct packet_id_net *pin, bool print_timestamp, struct gc_arena *gc)$/;"	f	signature:(const struct packet_id_net *pin, bool print_timestamp, struct gc_arena *gc)
packet_id_net_print	packet_id.h	/^const char *packet_id_net_print(const struct packet_id_net *pin, bool print_timestamp, struct gc_arena *gc);$/;"	p	signature:(const struct packet_id_net *pin, bool print_timestamp, struct gc_arena *gc)
packet_id_persist	openvpn.h	/^struct packet_id_persist$/;"	s
packet_id_persist	packet_id.h	/^struct packet_id_persist$/;"	s
packet_id_persist::dummy	openvpn.h	/^    int dummy;$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::fd	packet_id.h	/^    int fd;$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::filename	packet_id.h	/^    const char *filename;$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::id	packet_id.h	/^    packet_id_type id;     \/* sequence number *\/$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::id_last_written	packet_id.h	/^    packet_id_type id_last_written;$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::time	packet_id.h	/^    time_t time;           \/* time stamp *\/$/;"	m	struct:packet_id_persist	access:public
packet_id_persist::time_last_written	packet_id.h	/^    time_t time_last_written;$/;"	m	struct:packet_id_persist	access:public
packet_id_persist_close	packet_id.c	/^packet_id_persist_close(struct packet_id_persist *p)$/;"	f	signature:(struct packet_id_persist *p)
packet_id_persist_close	packet_id.h	/^void packet_id_persist_close(struct packet_id_persist *p);$/;"	p	signature:(struct packet_id_persist *p)
packet_id_persist_enabled	packet_id.h	/^packet_id_persist_enabled(const struct packet_id_persist *p)$/;"	f	signature:(const struct packet_id_persist *p)
packet_id_persist_file_image	packet_id.h	/^struct packet_id_persist_file_image$/;"	s
packet_id_persist_file_image::id	packet_id.h	/^    packet_id_type id;     \/* sequence number *\/$/;"	m	struct:packet_id_persist_file_image	access:public
packet_id_persist_file_image::time	packet_id.h	/^    time_t time;           \/* time stamp *\/$/;"	m	struct:packet_id_persist_file_image	access:public
packet_id_persist_init	openvpn.h	/^packet_id_persist_init(struct packet_id_persist *p)$/;"	f	signature:(struct packet_id_persist *p)
packet_id_persist_init	packet_id.c	/^packet_id_persist_init(struct packet_id_persist *p)$/;"	f	signature:(struct packet_id_persist *p)
packet_id_persist_init	packet_id.h	/^void packet_id_persist_init(struct packet_id_persist *p);$/;"	p	signature:(struct packet_id_persist *p)
packet_id_persist_interval	openvpn.h	/^    struct event_timeout packet_id_persist_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
packet_id_persist_load	packet_id.c	/^packet_id_persist_load(struct packet_id_persist *p, const char *filename)$/;"	f	signature:(struct packet_id_persist *p, const char *filename)
packet_id_persist_load	packet_id.h	/^void packet_id_persist_load(struct packet_id_persist *p, const char *filename);$/;"	p	signature:(struct packet_id_persist *p, const char *filename)
packet_id_persist_load_obj	packet_id.c	/^packet_id_persist_load_obj(const struct packet_id_persist *p, struct packet_id *pid)$/;"	f	signature:(const struct packet_id_persist *p, struct packet_id *pid)
packet_id_persist_load_obj	packet_id.h	/^void packet_id_persist_load_obj(const struct packet_id_persist *p, struct packet_id *pid);$/;"	p	signature:(const struct packet_id_persist *p, struct packet_id *pid)
packet_id_persist_print	packet_id.c	/^packet_id_persist_print(const struct packet_id_persist *p, struct gc_arena *gc)$/;"	f	signature:(const struct packet_id_persist *p, struct gc_arena *gc)
packet_id_persist_print	packet_id.h	/^const char *packet_id_persist_print(const struct packet_id_persist *p, struct gc_arena *gc);$/;"	p	signature:(const struct packet_id_persist *p, struct gc_arena *gc)
packet_id_persist_save	packet_id.c	/^packet_id_persist_save(struct packet_id_persist *p)$/;"	f	signature:(struct packet_id_persist *p)
packet_id_persist_save	packet_id.h	/^void packet_id_persist_save(struct packet_id_persist *p);$/;"	p	signature:(struct packet_id_persist *p)
packet_id_persist_save_obj	packet_id.h	/^packet_id_persist_save_obj(struct packet_id_persist *p, const struct packet_id *pid)$/;"	f	signature:(struct packet_id_persist *p, const struct packet_id *pid)
packet_id_print_type	packet_id.h	/^typedef unsigned int packet_id_print_type;$/;"	t
packet_id_read	packet_id.c	/^packet_id_read(struct packet_id_net *pin, struct buffer *buf, bool long_form)$/;"	f	signature:(struct packet_id_net *pin, struct buffer *buf, bool long_form)
packet_id_read	packet_id.h	/^bool packet_id_read(struct packet_id_net *pin, struct buffer *buf, bool long_form);$/;"	p	signature:(struct packet_id_net *pin, struct buffer *buf, bool long_form)
packet_id_reap	packet_id.c	/^packet_id_reap(struct packet_id_rec *p)$/;"	f	signature:(struct packet_id_rec *p)
packet_id_reap	packet_id.h	/^void packet_id_reap(struct packet_id_rec *p);$/;"	p	signature:(struct packet_id_rec *p)
packet_id_reap_test	packet_id.h	/^packet_id_reap_test(struct packet_id_rec *p)$/;"	f	signature:(struct packet_id_rec *p)
packet_id_rec	packet_id.h	/^struct packet_id_rec$/;"	s
packet_id_rec::id	packet_id.h	/^    packet_id_type id;        \/* highest sequence number received *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::initialized	packet_id.h	/^    bool initialized;         \/* true if packet_id_init was called *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::last_reap	packet_id.h	/^    time_t last_reap;         \/* last call of packet_id_reap *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::max_backtrack_stat	packet_id.h	/^    int max_backtrack_stat;   \/* maximum backtrack seen so far *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::name	packet_id.h	/^    const char *name;$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::seq_backtrack	packet_id.h	/^    int seq_backtrack;        \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::seq_list	packet_id.h	/^    struct seq_list *seq_list; \/* packet-id "memory" *\/$/;"	m	struct:packet_id_rec	typeref:struct:packet_id_rec::seq_list	access:public
packet_id_rec::time	packet_id.h	/^    time_t time;              \/* highest time stamp received *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::time_backtrack	packet_id.h	/^    int time_backtrack;       \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec	access:public
packet_id_rec::unit	packet_id.h	/^    int unit;$/;"	m	struct:packet_id_rec	access:public
packet_id_send	packet_id.h	/^struct packet_id_send$/;"	s
packet_id_send::id	packet_id.h	/^    packet_id_type id;$/;"	m	struct:packet_id_send	access:public
packet_id_send::time	packet_id.h	/^    time_t time;$/;"	m	struct:packet_id_send	access:public
packet_id_send_update	packet_id.c	/^packet_id_send_update(struct packet_id_send *p, bool long_form)$/;"	f	file:	signature:(struct packet_id_send *p, bool long_form)
packet_id_size	packet_id.h	/^packet_id_size(bool long_form)$/;"	f	signature:(bool long_form)
packet_id_test	packet_id.c	/^packet_id_test(struct packet_id_rec *p,$/;"	f	signature:(struct packet_id_rec *p, const struct packet_id_net *pin)
packet_id_test	packet_id.h	/^bool packet_id_test(struct packet_id_rec *p,$/;"	p	signature:(struct packet_id_rec *p, const struct packet_id_net *pin)
packet_id_type	packet_id.h	/^typedef uint32_t packet_id_type;$/;"	t
packet_id_type	packet_id.h	/^typedef uint8_t packet_id_type;$/;"	t
packet_id_write	packet_id.c	/^packet_id_write(struct packet_id_send *p, struct buffer *buf, bool long_form,$/;"	f	signature:(struct packet_id_send *p, struct buffer *buf, bool long_form, bool prepend)
packet_id_write	packet_id.h	/^bool packet_id_write(struct packet_id_send *p, struct buffer *buf,$/;"	p	signature:(struct packet_id_send *p, struct buffer *buf, bool long_form, bool prepend)
packet_opcode_name	ssl.c	/^packet_opcode_name(int op)$/;"	f	file:	signature:(int op)
packet_size	gremlin.h	/^    int packet_size;$/;"	m	struct:packet_flood_parms	access:public
packet_size_type	socket.h	/^typedef uint16_t packet_size_type;$/;"	t
packet_timeout	ssl_common.h	/^    interval_t packet_timeout;$/;"	m	struct:tls_options	access:public
panel_reg	tun.h	/^struct panel_reg$/;"	s
panel_reg::guid	tun.h	/^    const char *guid;$/;"	m	struct:panel_reg	access:public
panel_reg::name	tun.h	/^    const char *name;$/;"	m	struct:panel_reg	access:public
panel_reg::next	tun.h	/^    struct panel_reg *next;$/;"	m	struct:panel_reg	typeref:struct:panel_reg::panel_reg	access:public
parent	schedule.h	/^    struct schedule_entry *parent; \/* treap (btree) links *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
parse_argv	options.c	/^parse_argv(struct options *options,$/;"	f	signature:(struct options *options, const int argc, char *argv[], const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
parse_argv	options.h	/^void parse_argv(struct options *options,$/;"	p	signature:(struct options *options, const int argc, char *argv[], const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
parse_cid	manage.c	/^parse_cid(const char *str, unsigned long *cid)$/;"	f	file:	signature:(const char *str, unsigned long *cid)
parse_hash_fingerprint	options.c	/^parse_hash_fingerprint(const char *str, int nbytes, int msglevel, struct gc_arena *gc)$/;"	f	file:	signature:(const char *str, int nbytes, int msglevel, struct gc_arena *gc)
parse_http_proxy_override	options.c	/^parse_http_proxy_override(const char *server,$/;"	f	file:	signature:(const char *server, const char *port, const char *flags, const int msglevel, struct gc_arena *gc)
parse_kid	manage.c	/^parse_kid(const char *str, unsigned int *kid)$/;"	f	file:	signature:(const char *str, unsigned int *kid)
parse_line	options.c	/^parse_line(const char *line,$/;"	f	signature:(const char *line, char *p[], const int n, const char *file, const int line_num, int msglevel, struct gc_arena *gc)
parse_line	options.h	/^int parse_line(const char *line,$/;"	p	signature:(const char *line, char *p[], const int n, const char *file, const int line_num, int msglevel, struct gc_arena *gc)
parse_signal	sig.c	/^parse_signal(const char *signame)$/;"	f	signature:(const char *signame)
parse_signal	sig.h	/^int parse_signal(const char *signame);$/;"	p	signature:(const char *signame)
parse_topology	options.c	/^parse_topology(const char *str, const int msglevel)$/;"	f	signature:(const char *str, const int msglevel)
parse_topology	options.h	/^int parse_topology(const char *str, const int msglevel);$/;"	p	signature:(const char *str, const int msglevel)
pass_config_info	ssl_common.h	/^    bool pass_config_info;$/;"	m	struct:tls_options	access:public
passbuf	ssl.c	/^static struct user_pass passbuf; \/* GLOBAL *\/$/;"	v	typeref:struct:user_pass	file:
passtos	options.h	/^    bool passtos;$/;"	m	struct:options	access:public
password	misc.h	/^    char password[USER_PASS_LEN];$/;"	m	struct:user_pass	access:public
password_tries	manage.h	/^    int password_tries;$/;"	m	struct:man_connection	access:public
password_verified	manage.h	/^    bool password_verified;$/;"	m	struct:man_connection	access:public
pattern	options.c	/^    char *pattern;$/;"	m	struct:pull_filter	file:	access:public
pause_exit_enabled	win32.c	/^static bool pause_exit_enabled = false; \/* GLOBAL *\/$/;"	v	file:
paybuf	ssl_common.h	/^    struct buffer_list *paybuf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer_list	access:public
payload_len	proto.h	/^    uint16_t payload_len;$/;"	m	struct:openvpn_ipv6hdr	access:public
pct_name	pf.c	/^pct_name(const int type)$/;"	f	file:	signature:(const int type)
peer_id	options.h	/^    uint32_t peer_id;$/;"	m	struct:options	access:public
peer_id	ssl_common.h	/^    uint32_t peer_id;$/;"	m	struct:tls_multi	access:public
peer_info	ssl_common.h	/^    char *peer_info;$/;"	m	struct:tls_multi	access:public
pem_password_callback	ssl.c	/^pem_password_callback(char *buf, int size, int rwflag, void *u)$/;"	f	signature:(char *buf, int size, int rwflag, void *u)
pem_password_callback	ssl_backend.h	/^int pem_password_callback(char *buf, int size, int rwflag, void *u);$/;"	p	signature:(char *buf, int size, int rwflag, void *u)
pem_password_setup	ssl.c	/^pem_password_setup(const char *auth_file)$/;"	f	signature:(const char *auth_file)
pem_password_setup	ssl.h	/^void pem_password_setup(const char *auth_file);$/;"	p	signature:(const char *auth_file)
pending	multi.h	/^    struct multi_instance *pending;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_instance	access:public
per	otime.h	/^    int per;$/;"	m	struct:frequency_limit	access:public
per_client	plugin.h	/^    struct plugin_per_client per_client;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_per_client	access:public
per_client_context	plugin.h	/^    void *per_client_context[MAX_PLUGINS];$/;"	m	struct:plugin_per_client	access:public
per_second_trigger	multi.h	/^    time_t per_second_trigger;$/;"	m	struct:multi_context	access:public
perf	perf.c	/^    struct perf perf[PERF_N];$/;"	m	struct:perf_set	typeref:struct:perf_set::perf	file:	access:public
perf	perf.c	/^struct perf$/;"	s	file:
perf::count	perf.c	/^    double count;$/;"	m	struct:perf	file:	access:public
perf::max	perf.c	/^    double max;$/;"	m	struct:perf	file:	access:public
perf::sofar	perf.c	/^    double sofar;$/;"	m	struct:perf	file:	access:public
perf::start	perf.c	/^    struct timeval start;$/;"	m	struct:perf	typeref:struct:perf::timeval	file:	access:public
perf::state	perf.c	/^    int state;$/;"	m	struct:perf	file:	access:public
perf::sum	perf.c	/^    double sum;$/;"	m	struct:perf	file:	access:public
perf_interrupt	perf.c	/^perf_interrupt(struct perf *p)$/;"	f	file:	signature:(struct perf *p)
perf_output_results	perf.c	/^perf_output_results(void)$/;"	f	signature:(void)
perf_output_results	perf.h	/^perf_output_results(void)$/;"	f	signature:(void)
perf_output_results	perf.h	/^void perf_output_results(void);$/;"	p	signature:(void)
perf_pop	perf.c	/^perf_pop(void)$/;"	f	signature:(void)
perf_pop	perf.h	/^perf_pop(void)$/;"	f	signature:(void)
perf_pop	perf.h	/^void perf_pop(void);$/;"	p	signature:(void)
perf_print_state	perf.c	/^perf_print_state(int lev)$/;"	f	file:	signature:(int lev)
perf_print_state	perf.c	/^static void perf_print_state(int lev);$/;"	p	file:	signature:(int lev)
perf_push	perf.c	/^perf_push(int type)$/;"	f	signature:(int type)
perf_push	perf.h	/^perf_push(int type)$/;"	f	signature:(int type)
perf_push	perf.h	/^void perf_push(int type);$/;"	p	signature:(int type)
perf_resume	perf.c	/^perf_resume(struct perf *p)$/;"	f	file:	signature:(struct perf *p)
perf_set	perf.c	/^static struct perf_set perf_set;$/;"	v	typeref:struct:perf_set	file:
perf_set	perf.c	/^struct perf_set$/;"	s	file:
perf_set::perf	perf.c	/^    struct perf perf[PERF_N];$/;"	m	struct:perf_set	typeref:struct:perf_set::perf	file:	access:public
perf_set::stack	perf.c	/^    int stack[STACK_N];$/;"	m	struct:perf_set	file:	access:public
perf_set::stack_len	perf.c	/^    int stack_len;$/;"	m	struct:perf_set	file:	access:public
perf_start	perf.c	/^perf_start(struct perf *p)$/;"	f	file:	signature:(struct perf *p)
perf_stop	perf.c	/^perf_stop(struct perf *p)$/;"	f	file:	signature:(struct perf *p)
persist	manage.h	/^    struct man_persist persist;$/;"	m	struct:management	typeref:struct:management::man_persist	access:public
persist	openvpn.h	/^    struct context_persist persist;$/;"	m	struct:context	typeref:struct:context::context_persist	access:public
persist_config	options.h	/^    bool persist_config;$/;"	m	struct:options	access:public
persist_key	options.h	/^    bool persist_key;           \/* Don't re-read key files on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
persist_local_ip	options.h	/^    bool persist_local_ip;      \/* Don't re-resolve local address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
persist_mode	options.h	/^    int persist_mode;$/;"	m	struct:options	access:public
persist_remote_ip	options.h	/^    bool persist_remote_ip;     \/* Don't re-resolve remote address on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
persist_tun	options.h	/^    bool persist_tun;           \/* Don't close\/reopen TUN\/TAP dev on SIGUSR1 or PING_RESTART *\/$/;"	m	struct:options	access:public
persistent_if	tun.h	/^    bool persistent_if;         \/* if existed before, keep on program end *\/$/;"	m	struct:tuntap	access:public
pf	openvpn.h	/^    struct pf_context pf;$/;"	m	struct:context_2	typeref:struct:context_2::pf_context	access:public
pf_addr_test	pf-inline.h	/^pf_addr_test(const struct context *src, const struct mroute_addr *dest, const char *prefix)$/;"	f	signature:(const struct context *src, const struct mroute_addr *dest, const char *prefix)
pf_addr_test_dowork	pf.c	/^pf_addr_test_dowork(const struct context *src, const struct mroute_addr *dest, const char *prefix)$/;"	f	signature:(const struct context *src, const struct mroute_addr *dest, const char *prefix)
pf_addr_test_print	pf.c	/^pf_addr_test_print(const char *prefix,$/;"	f	file:	signature:(const char *prefix, const char *prefix2, const struct context *src, const struct mroute_addr *dest, const bool allow, const struct ipv4_subnet *rule)
pf_c2c_test	pf-inline.h	/^pf_c2c_test(const struct context *src, const struct context *dest, const char *prefix)$/;"	f	signature:(const struct context *src, const struct context *dest, const char *prefix)
pf_check_reload	pf.c	/^pf_check_reload(struct context *c)$/;"	f	signature:(struct context *c)
pf_check_reload	pf.h	/^void pf_check_reload(struct context *c);$/;"	p	signature:(struct context *c)
pf_cn	pf.h	/^struct pf_cn {$/;"	s
pf_cn::cn	pf.h	/^    char *cn;$/;"	m	struct:pf_cn	access:public
pf_cn::exclude	pf.h	/^    bool exclude;$/;"	m	struct:pf_cn	access:public
pf_cn_elem	pf.h	/^struct pf_cn_elem {$/;"	s
pf_cn_elem::next	pf.h	/^    struct pf_cn_elem *next;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn_elem	access:public
pf_cn_elem::rule	pf.h	/^    struct pf_cn rule;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn	access:public
pf_cn_set	pf.h	/^struct pf_cn_set {$/;"	s
pf_cn_set::default_allow	pf.h	/^    bool default_allow;$/;"	m	struct:pf_cn_set	access:public
pf_cn_set::hash_table	pf.h	/^    struct hash *hash_table;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::hash	access:public
pf_cn_set::list	pf.h	/^    struct pf_cn_elem *list;$/;"	m	struct:pf_cn_set	typeref:struct:pf_cn_set::pf_cn_elem	access:public
pf_cn_set_print	pf.c	/^pf_cn_set_print(const struct pf_cn_set *s, const int lev)$/;"	f	file:	signature:(const struct pf_cn_set *s, const int lev)
pf_cn_test	pf.c	/^pf_cn_test(struct pf_set *pfs, const struct tls_multi *tm, const int type, const char *prefix)$/;"	f	signature:(struct pf_set *pfs, const struct tls_multi *tm, const int type, const char *prefix)
pf_cn_test_print	pf.c	/^pf_cn_test_print(const char *prefix,$/;"	f	file:	signature:(const char *prefix, const int type, const char *prefix2, const char *cn, const bool allow, const struct pf_cn *rule)
pf_context	pf.h	/^struct pf_context {$/;"	s
pf_context::enabled	pf.h	/^    bool enabled;$/;"	m	struct:pf_context	access:public
pf_context::file_last_mod	pf.h	/^    time_t file_last_mod;$/;"	m	struct:pf_context	access:public
pf_context::filename	pf.h	/^    char *filename;$/;"	m	struct:pf_context	access:public
pf_context::n_check_reload	pf.h	/^    unsigned int n_check_reload;$/;"	m	struct:pf_context	access:public
pf_context::pfs	pf.h	/^    struct pf_set *pfs;$/;"	m	struct:pf_context	typeref:struct:pf_context::pf_set	access:public
pf_context::reload	pf.h	/^    struct event_timeout reload;$/;"	m	struct:pf_context	typeref:struct:pf_context::event_timeout	access:public
pf_context_print	pf.c	/^pf_context_print(const struct pf_context *pfc, const char *prefix, const int lev)$/;"	f	signature:(const struct pf_context *pfc, const char *prefix, const int lev)
pf_context_print	pf.h	/^void pf_context_print(const struct pf_context *pfc, const char *prefix, const int lev);$/;"	p	signature:(const struct pf_context *pfc, const char *prefix, const int lev)
pf_destroy	pf.c	/^pf_destroy(struct pf_set *pfs)$/;"	f	file:	signature:(struct pf_set *pfs)
pf_destroy_context	pf.c	/^pf_destroy_context(struct pf_context *pfc)$/;"	f	signature:(struct pf_context *pfc)
pf_destroy_context	pf.h	/^void pf_destroy_context(struct pf_context *pfc);$/;"	p	signature:(struct pf_context *pfc)
pf_init	pf.c	/^pf_init(const struct buffer_list *bl, const char *prefix, const bool allow_kill)$/;"	f	file:	signature:(const struct buffer_list *bl, const char *prefix, const bool allow_kill)
pf_init_context	pf.c	/^pf_init_context(struct context *c)$/;"	f	signature:(struct context *c)
pf_init_context	pf.h	/^void pf_init_context(struct context *c);$/;"	p	signature:(struct context *c)
pf_init_from_file	pf.c	/^pf_init_from_file(const char *fn)$/;"	f	file:	signature:(const char *fn)
pf_kill_test	pf-inline.h	/^pf_kill_test(const struct pf_set *pfs)$/;"	f	signature:(const struct pf_set *pfs)
pf_load_from_buffer_list	pf.c	/^pf_load_from_buffer_list(struct context *c, const struct buffer_list *config)$/;"	f	signature:(struct context *c, const struct buffer_list *config)
pf_load_from_buffer_list	pf.h	/^bool pf_load_from_buffer_list(struct context *c, const struct buffer_list *config);$/;"	p	signature:(struct context *c, const struct buffer_list *config)
pf_set	pf.h	/^struct pf_set {$/;"	s
pf_set::cns	pf.h	/^    struct pf_cn_set cns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_cn_set	access:public
pf_set::kill	pf.h	/^    bool kill;$/;"	m	struct:pf_set	access:public
pf_set::sns	pf.h	/^    struct pf_subnet_set sns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_subnet_set	access:public
pf_set_print	pf.c	/^pf_set_print(const struct pf_set *pfs, const int lev)$/;"	f	file:	signature:(const struct pf_set *pfs, const int lev)
pf_subnet	pf.h	/^struct pf_subnet {$/;"	s
pf_subnet::next	pf.h	/^    struct pf_subnet *next;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::pf_subnet	access:public
pf_subnet::rule	pf.h	/^    struct ipv4_subnet rule;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::ipv4_subnet	access:public
pf_subnet_set	pf.h	/^struct pf_subnet_set {$/;"	s
pf_subnet_set::default_allow	pf.h	/^    bool default_allow;$/;"	m	struct:pf_subnet_set	access:public
pf_subnet_set::list	pf.h	/^    struct pf_subnet *list;$/;"	m	struct:pf_subnet_set	typeref:struct:pf_subnet_set::pf_subnet	access:public
pf_subnet_set_print	pf.c	/^pf_subnet_set_print(const struct pf_subnet_set *s, const int lev)$/;"	f	file:	signature:(const struct pf_subnet_set *s, const int lev)
pfs	pf.h	/^    struct pf_set *pfs;$/;"	m	struct:pf_context	typeref:struct:pf_context::pf_set	access:public
pgmname_syslog	error.c	/^static char *pgmname_syslog;  \/* GLOBAL *\/$/;"	v	file:
phase2_inetd	socket.c	/^phase2_inetd(struct link_socket *sock, const struct frame *frame,$/;"	f	file:	signature:(struct link_socket *sock, const struct frame *frame, const char *remote_dynamic, volatile int *signal_received)
phase2_set_socket_flags	socket.c	/^phase2_set_socket_flags(struct link_socket *sock)$/;"	f	file:	signature:(struct link_socket *sock)
phase2_socks_client	socket.c	/^phase2_socks_client(struct link_socket *sock, struct signal_info *sig_info)$/;"	f	file:	signature:(struct link_socket *sock, struct signal_info *sig_info)
phase2_tcp_client	socket.c	/^phase2_tcp_client(struct link_socket *sock, struct signal_info *sig_info)$/;"	f	file:	signature:(struct link_socket *sock, struct signal_info *sig_info)
phase2_tcp_server	socket.c	/^phase2_tcp_server(struct link_socket *sock, const char *remote_dynamic,$/;"	f	file:	signature:(struct link_socket *sock, const char *remote_dynamic, volatile int *signal_received)
pi	socket.h	/^    } pi;$/;"	m	struct:link_socket_actual	typeref:union:link_socket_actual::__anon14	access:public
pid_persist	crypto.h	/^    struct packet_id_persist *pid_persist;$/;"	m	struct:crypto_options	typeref:struct:crypto_options::packet_id_persist	access:public
pid_persist	openvpn.h	/^    struct packet_id_persist pid_persist;$/;"	m	struct:context_1	typeref:struct:context_1::packet_id_persist	access:public
ping_rec_interval	openvpn.h	/^    struct event_timeout ping_rec_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
ping_rec_timeout	options.h	/^    int ping_rec_timeout;       \/* Expect a TCP\/UDP ping from remote at least once every n seconds *\/$/;"	m	struct:options	access:public
ping_rec_timeout_action	options.h	/^    int ping_rec_timeout_action; \/* What action to take on ping_rec_timeout (exit or restart)? *\/$/;"	m	struct:options	access:public
ping_send_interval	openvpn.h	/^    struct event_timeout ping_send_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
ping_send_timeout	options.h	/^    int ping_send_timeout;      \/* Send a TCP\/UDP ping to remote every n seconds *\/$/;"	m	struct:options	access:public
ping_string	ping.c	/^const uint8_t ping_string[] = {$/;"	v
ping_timer_remote	options.h	/^    bool ping_timer_remote;     \/* Run ping timer only if we have a remote address *\/$/;"	m	struct:options	access:public
pkcs11_addProvider	pkcs11.c	/^pkcs11_addProvider($/;"	f	signature:( const char *const provider, const bool protected_auth, const unsigned private_mode, const bool cert_private )
pkcs11_addProvider	pkcs11.h	/^pkcs11_addProvider($/;"	p	signature:( const char *const provider, const bool fProtectedAuthentication, const unsigned private_mode, const bool fCertIsPrivate )
pkcs11_cert_private	options.h	/^    bool pkcs11_cert_private[MAX_PARMS];$/;"	m	struct:options	access:public
pkcs11_certificate_dn	pkcs11_backend.h	/^char *pkcs11_certificate_dn(pkcs11h_certificate_t certificate, struct gc_arena *gc);$/;"	p	signature:(pkcs11h_certificate_t certificate, struct gc_arena *gc)
pkcs11_certificate_dn	pkcs11_mbedtls.c	/^pkcs11_certificate_dn(pkcs11h_certificate_t cert, struct gc_arena *gc)$/;"	f	signature:(pkcs11h_certificate_t cert, struct gc_arena *gc)
pkcs11_certificate_dn	pkcs11_openssl.c	/^pkcs11_certificate_dn(pkcs11h_certificate_t certificate, struct gc_arena *gc)$/;"	f	signature:(pkcs11h_certificate_t certificate, struct gc_arena *gc)
pkcs11_certificate_serial	pkcs11_backend.h	/^int pkcs11_certificate_serial(pkcs11h_certificate_t certificate, char *serial,$/;"	p	signature:(pkcs11h_certificate_t certificate, char *serial, size_t serial_len)
pkcs11_certificate_serial	pkcs11_mbedtls.c	/^pkcs11_certificate_serial(pkcs11h_certificate_t cert, char *serial,$/;"	f	signature:(pkcs11h_certificate_t cert, char *serial, size_t serial_len)
pkcs11_certificate_serial	pkcs11_openssl.c	/^pkcs11_certificate_serial(pkcs11h_certificate_t certificate, char *serial,$/;"	f	signature:(pkcs11h_certificate_t certificate, char *serial, size_t serial_len)
pkcs11_id	options.h	/^    const char *pkcs11_id;$/;"	m	struct:options	access:public
pkcs11_id_management	options.h	/^    bool pkcs11_id_management;$/;"	m	struct:options	access:public
pkcs11_init_tls_session	pkcs11_backend.h	/^int pkcs11_init_tls_session(pkcs11h_certificate_t certificate,$/;"	p	signature:(pkcs11h_certificate_t certificate, struct tls_root_ctx *const ssl_ctx)
pkcs11_init_tls_session	pkcs11_mbedtls.c	/^pkcs11_init_tls_session(pkcs11h_certificate_t certificate,$/;"	f	signature:(pkcs11h_certificate_t certificate, struct tls_root_ctx *const ssl_ctx)
pkcs11_init_tls_session	pkcs11_openssl.c	/^pkcs11_init_tls_session(pkcs11h_certificate_t certificate,$/;"	f	signature:(pkcs11h_certificate_t certificate, struct tls_root_ctx *const ssl_ctx)
pkcs11_initialize	pkcs11.c	/^pkcs11_initialize($/;"	f	signature:( const bool protected_auth, const int nPINCachePeriod )
pkcs11_initialize	pkcs11.h	/^pkcs11_initialize($/;"	p	signature:( const bool fProtectedAuthentication, const int nPINCachePeriod )
pkcs11_logout	pkcs11.c	/^pkcs11_logout(void)$/;"	f	signature:(void)
pkcs11_logout	pkcs11.h	/^pkcs11_logout();$/;"	p	signature:()
pkcs11_management_id_count	pkcs11.c	/^pkcs11_management_id_count(void)$/;"	f	signature:(void)
pkcs11_management_id_count	pkcs11.h	/^pkcs11_management_id_count();$/;"	p	signature:()
pkcs11_management_id_get	pkcs11.c	/^pkcs11_management_id_get($/;"	f	signature:( const int index, char **id, char **base64 )
pkcs11_management_id_get	pkcs11.h	/^pkcs11_management_id_get($/;"	p	signature:( const int index, char **id, char **base64 )
pkcs11_pin_cache_period	options.h	/^    int pkcs11_pin_cache_period;$/;"	m	struct:options	access:public
pkcs11_private_mode	options.h	/^    unsigned pkcs11_private_mode[MAX_PARMS];$/;"	m	struct:options	access:public
pkcs11_protected_authentication	options.h	/^    bool pkcs11_protected_authentication[MAX_PARMS];$/;"	m	struct:options	access:public
pkcs11_providers	options.h	/^    const char *pkcs11_providers[MAX_PARMS];$/;"	m	struct:options	access:public
pkcs11_terminate	pkcs11.c	/^pkcs11_terminate(void)$/;"	f	signature:(void)
pkcs11_terminate	pkcs11.h	/^pkcs11_terminate();$/;"	p	signature:()
pkcs12_file	options.h	/^    const char *pkcs12_file;$/;"	m	struct:options	access:public
pkcs12_file_inline	options.h	/^    const char *pkcs12_file_inline; \/* contains the base64 encoding of pkcs12 file *\/$/;"	m	struct:options	access:public
plaintext_read_buf	ssl_common.h	/^    struct buffer plaintext_read_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
plaintext_write_buf	ssl_common.h	/^    struct buffer plaintext_write_buf;$/;"	m	struct:key_state	typeref:struct:key_state::buffer	access:public
platform_access	platform.c	/^platform_access(const char *path, int mode)$/;"	f	signature:(const char *path, int mode)
platform_access	platform.h	/^int platform_access(const char *path, int mode);$/;"	p	signature:(const char *path, int mode)
platform_chdir	platform.c	/^platform_chdir(const char *dir)$/;"	f	signature:(const char *dir)
platform_chdir	platform.h	/^int platform_chdir(const char *dir);$/;"	p	signature:(const char *dir)
platform_chroot	platform.c	/^platform_chroot(const char *path)$/;"	f	signature:(const char *path)
platform_chroot	platform.h	/^void platform_chroot(const char *path);$/;"	p	signature:(const char *path)
platform_fopen	platform.c	/^platform_fopen(const char *path, const char *mode)$/;"	f	signature:(const char *path, const char *mode)
platform_fopen	platform.h	/^FILE *platform_fopen(const char *path, const char *mode);$/;"	p	signature:(const char *path, const char *mode)
platform_getpid	platform.c	/^platform_getpid(void)$/;"	f	signature:(void)
platform_getpid	platform.h	/^unsigned int platform_getpid(void);$/;"	p	signature:(void)
platform_group_get	platform.c	/^platform_group_get(const char *groupname, struct platform_state_group *state)$/;"	f	signature:(const char *groupname, struct platform_state_group *state)
platform_group_get	platform.h	/^bool platform_group_get(const char *groupname, struct platform_state_group *state);$/;"	p	signature:(const char *groupname, struct platform_state_group *state)
platform_group_set	platform.c	/^platform_group_set(const struct platform_state_group *state)$/;"	f	signature:(const struct platform_state_group *state)
platform_group_set	platform.h	/^void platform_group_set(const struct platform_state_group *state);$/;"	p	signature:(const struct platform_state_group *state)
platform_mlockall	platform.c	/^platform_mlockall(bool print_msg)$/;"	f	signature:(bool print_msg)
platform_mlockall	platform.h	/^void platform_mlockall(bool print_msg);  \/* Disable paging *\/$/;"	p	signature:(bool print_msg)
platform_nice	platform.c	/^platform_nice(int niceval)$/;"	f	signature:(int niceval)
platform_nice	platform.h	/^void platform_nice(int niceval);$/;"	p	signature:(int niceval)
platform_open	platform.c	/^platform_open(const char *path, int flags, int mode)$/;"	f	signature:(const char *path, int flags, int mode)
platform_open	platform.h	/^int platform_open(const char *path, int flags, int mode);$/;"	p	signature:(const char *path, int flags, int mode)
platform_putenv	platform.h	/^int platform_putenv(char *string);$/;"	p	signature:(char *string)
platform_sleep_milliseconds	platform.c	/^platform_sleep_milliseconds(unsigned int n)$/;"	f	signature:(unsigned int n)
platform_sleep_milliseconds	platform.h	/^void platform_sleep_milliseconds(unsigned int n);$/;"	p	signature:(unsigned int n)
platform_sleep_until_signal	platform.c	/^platform_sleep_until_signal(void)$/;"	f	signature:(void)
platform_sleep_until_signal	platform.h	/^void platform_sleep_until_signal(void);$/;"	p	signature:(void)
platform_stat	platform.c	/^platform_stat(const char *path, platform_stat_t *buf)$/;"	f	signature:(const char *path, platform_stat_t *buf)
platform_stat	platform.h	/^int platform_stat(const char *path, platform_stat_t *buf);$/;"	p	signature:(const char *path, platform_stat_t *buf)
platform_stat_t	platform.h	/^typedef struct _stat platform_stat_t;$/;"	t	typeref:struct:_stat
platform_stat_t	platform.h	/^typedef struct stat platform_stat_t;$/;"	t	typeref:struct:stat
platform_state_group	openvpn.h	/^    struct platform_state_group platform_state_group;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_group	access:public
platform_state_group	platform.h	/^struct platform_state_group {$/;"	s
platform_state_group::gr	platform.h	/^    struct group *gr;$/;"	m	struct:platform_state_group	typeref:struct:platform_state_group::group	access:public
platform_state_group::groupname	platform.h	/^    const char *groupname;$/;"	m	struct:platform_state_group	access:public
platform_state_group_gid	platform.h	/^platform_state_group_gid(const struct platform_state_group *s)$/;"	f	signature:(const struct platform_state_group *s)
platform_state_user	openvpn.h	/^    struct platform_state_user platform_state_user;$/;"	m	struct:context_0	typeref:struct:context_0::platform_state_user	access:public
platform_state_user	platform.h	/^struct platform_state_user {$/;"	s
platform_state_user::pw	platform.h	/^    struct passwd *pw;$/;"	m	struct:platform_state_user	typeref:struct:platform_state_user::passwd	access:public
platform_state_user::username	platform.h	/^    const char *username;$/;"	m	struct:platform_state_user	access:public
platform_state_user_uid	platform.h	/^platform_state_user_uid(const struct platform_state_user *s)$/;"	f	signature:(const struct platform_state_user *s)
platform_system_ok	platform.c	/^platform_system_ok(int stat)$/;"	f	signature:(int stat)
platform_system_ok	platform.h	/^bool platform_system_ok(int stat);$/;"	p	signature:(int stat)
platform_unlink	platform.c	/^platform_unlink(const char *filename)$/;"	f	signature:(const char *filename)
platform_unlink	platform.h	/^bool platform_unlink(const char *filename);$/;"	p	signature:(const char *filename)
platform_user_get	platform.c	/^platform_user_get(const char *username, struct platform_state_user *state)$/;"	f	signature:(const char *username, struct platform_state_user *state)
platform_user_get	platform.h	/^bool platform_user_get(const char *username, struct platform_state_user *state);$/;"	p	signature:(const char *username, struct platform_state_user *state)
platform_user_set	platform.c	/^platform_user_set(const struct platform_state_user *state)$/;"	f	signature:(const struct platform_state_user *state)
platform_user_set	platform.h	/^void platform_user_set(const struct platform_state_user *state);$/;"	p	signature:(const struct platform_state_user *state)
plugin	plugin.h	/^struct plugin {$/;"	s
plugin::abort	plugin.h	/^    openvpn_plugin_abort_v1 abort;$/;"	m	struct:plugin	access:public
plugin::client_constructor	plugin.h	/^    openvpn_plugin_client_constructor_v1 client_constructor;$/;"	m	struct:plugin	access:public
plugin::client_destructor	plugin.h	/^    openvpn_plugin_client_destructor_v1 client_destructor;$/;"	m	struct:plugin	access:public
plugin::close	plugin.h	/^    openvpn_plugin_close_v1 close;$/;"	m	struct:plugin	access:public
plugin::func1	plugin.h	/^    openvpn_plugin_func_v1 func1;$/;"	m	struct:plugin	access:public
plugin::func2	plugin.h	/^    openvpn_plugin_func_v2 func2;$/;"	m	struct:plugin	access:public
plugin::func3	plugin.h	/^    openvpn_plugin_func_v3 func3;$/;"	m	struct:plugin	access:public
plugin::handle	plugin.h	/^    void *handle;$/;"	m	struct:plugin	access:public
plugin::initialization_point	plugin.h	/^    openvpn_plugin_select_initialization_point_v1 initialization_point;$/;"	m	struct:plugin	access:public
plugin::initialized	plugin.h	/^    bool initialized;$/;"	m	struct:plugin	access:public
plugin::min_version_required	plugin.h	/^    openvpn_plugin_min_version_required_v1 min_version_required;$/;"	m	struct:plugin	access:public
plugin::module	plugin.h	/^    HMODULE module;$/;"	m	struct:plugin	access:public
plugin::open1	plugin.h	/^    openvpn_plugin_open_v1 open1;$/;"	m	struct:plugin	access:public
plugin::open2	plugin.h	/^    openvpn_plugin_open_v2 open2;$/;"	m	struct:plugin	access:public
plugin::open3	plugin.h	/^    openvpn_plugin_open_v3 open3;$/;"	m	struct:plugin	access:public
plugin::plugin_handle	plugin.h	/^    openvpn_plugin_handle_t plugin_handle;$/;"	m	struct:plugin	access:public
plugin::plugin_type_mask	plugin.h	/^    unsigned int plugin_type_mask;$/;"	m	struct:plugin	access:public
plugin::requested_initialization_point	plugin.h	/^    int requested_initialization_point;$/;"	m	struct:plugin	access:public
plugin::so_pathname	plugin.h	/^    const char *so_pathname;$/;"	m	struct:plugin	access:public
plugin_abort	plugin.c	/^plugin_abort(void)$/;"	f	signature:(void)
plugin_abort_item	plugin.c	/^plugin_abort_item(const struct plugin *p)$/;"	f	file:	signature:(const struct plugin *p)
plugin_call	plugin.h	/^plugin_call(const struct plugin_list *pl,$/;"	f	signature:(const struct plugin_list *pl, const int type, const struct argv *av, struct plugin_return *pr, struct env_set *es)
plugin_call_item	plugin.c	/^plugin_call_item(const struct plugin *p,$/;"	f	file:	signature:(const struct plugin *p, void *per_client_context, const int type, const struct argv *av, struct openvpn_plugin_string_list **retlist, const char **envp , int certdepth, openvpn_x509_cert_t *current_cert )
plugin_call_ssl	plugin.c	/^plugin_call_ssl(const struct plugin_list *pl,$/;"	f	signature:(const struct plugin_list *pl, const int type, const struct argv *av, struct plugin_return *pr, struct env_set *es , int certdepth, openvpn_x509_cert_t *current_cert )
plugin_call_ssl	plugin.h	/^int plugin_call_ssl(const struct plugin_list *pl,$/;"	p	signature:(const struct plugin_list *pl, const int type, const struct argv *av, struct plugin_return *pr, struct env_set *es , int current_cert_depth, openvpn_x509_cert_t *current_cert )
plugin_call_ssl	plugin.h	/^plugin_call_ssl(const struct plugin_list *pl,$/;"	f	signature:(const struct plugin_list *pl, const int type, const struct argv *av, struct plugin_return *pr, struct env_set *es , int current_cert_depth, openvpn_x509_cert_t *current_cert )
plugin_close_item	plugin.c	/^plugin_close_item(struct plugin *p)$/;"	f	file:	signature:(struct plugin *p)
plugin_common	plugin.h	/^struct plugin_common$/;"	s
plugin_common::n	plugin.h	/^    int n;$/;"	m	struct:plugin_common	access:public
plugin_common::plugins	plugin.h	/^    struct plugin plugins[MAX_PLUGINS];$/;"	m	struct:plugin_common	typeref:struct:plugin_common::plugin	access:public
plugin_common_close	plugin.c	/^plugin_common_close(struct plugin_common *pc)$/;"	f	file:	signature:(struct plugin_common *pc)
plugin_common_init	plugin.c	/^plugin_common_init(const struct plugin_option_list *list)$/;"	f	file:	signature:(const struct plugin_option_list *list)
plugin_common_open	plugin.c	/^plugin_common_open(struct plugin_common *pc,$/;"	f	file:	signature:(struct plugin_common *pc, const struct plugin_option_list *list, struct plugin_return *pr, const struct env_set *es, const int init_point)
plugin_defined	plugin.c	/^plugin_defined(const struct plugin_list *pl, const int type)$/;"	f	signature:(const struct plugin_list *pl, const int type)
plugin_defined	plugin.h	/^bool plugin_defined(const struct plugin_list *pl, const int type);$/;"	p	signature:(const struct plugin_list *pl, const int type)
plugin_defined	plugin.h	/^plugin_defined(const struct plugin_list *pl, const int type)$/;"	f	signature:(const struct plugin_list *pl, const int type)
plugin_handle	plugin.h	/^    openvpn_plugin_handle_t plugin_handle;$/;"	m	struct:plugin	access:public
plugin_init_item	plugin.c	/^plugin_init_item(struct plugin *p, const struct plugin_option *o)$/;"	f	file:	signature:(struct plugin *p, const struct plugin_option *o)
plugin_list	options.h	/^    struct plugin_option_list *plugin_list;$/;"	m	struct:options	typeref:struct:options::plugin_option_list	access:public
plugin_list	plugin.h	/^struct plugin_list { int dummy; };$/;"	s
plugin_list	plugin.h	/^struct plugin_list$/;"	s
plugin_list::common	plugin.h	/^    struct plugin_common *common;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_common	access:public
plugin_list::common_owned	plugin.h	/^    bool common_owned;$/;"	m	struct:plugin_list	access:public
plugin_list::dummy	plugin.h	/^struct plugin_list { int dummy; };$/;"	m	struct:plugin_list	access:public
plugin_list::per_client	plugin.h	/^    struct plugin_per_client per_client;$/;"	m	struct:plugin_list	typeref:struct:plugin_list::plugin_per_client	access:public
plugin_list_close	plugin.c	/^plugin_list_close(struct plugin_list *pl)$/;"	f	signature:(struct plugin_list *pl)
plugin_list_close	plugin.h	/^void plugin_list_close(struct plugin_list *pl);$/;"	p	signature:(struct plugin_list *pl)
plugin_list_inherit	plugin.c	/^plugin_list_inherit(const struct plugin_list *src)$/;"	f	signature:(const struct plugin_list *src)
plugin_list_inherit	plugin.h	/^struct plugin_list *plugin_list_inherit(const struct plugin_list *src);$/;"	p	signature:(const struct plugin_list *src)
plugin_list_init	plugin.c	/^plugin_list_init(const struct plugin_option_list *list)$/;"	f	signature:(const struct plugin_option_list *list)
plugin_list_init	plugin.h	/^struct plugin_list *plugin_list_init(const struct plugin_option_list *list);$/;"	p	signature:(const struct plugin_option_list *list)
plugin_list_open	plugin.c	/^plugin_list_open(struct plugin_list *pl,$/;"	f	signature:(struct plugin_list *pl, const struct plugin_option_list *list, struct plugin_return *pr, const struct env_set *es, const int init_point)
plugin_list_open	plugin.h	/^void plugin_list_open(struct plugin_list *pl,$/;"	p	signature:(struct plugin_list *pl, const struct plugin_option_list *list, struct plugin_return *pr, const struct env_set *es, const int init_point)
plugin_log	plugin.c	/^plugin_log(openvpn_plugin_log_flags_t flags, const char *name, const char *format, ...)$/;"	f	file:	signature:(openvpn_plugin_log_flags_t flags, const char *name, const char *format, ...)
plugin_mask_string	plugin.c	/^plugin_mask_string(const unsigned int type_mask, struct gc_arena *gc)$/;"	f	file:	signature:(const unsigned int type_mask, struct gc_arena *gc)
plugin_n	plugin.h	/^plugin_n(const struct plugin_list *pl)$/;"	f	signature:(const struct plugin_list *pl)
plugin_open_item	plugin.c	/^plugin_open_item(struct plugin *p,$/;"	f	file:	signature:(struct plugin *p, const struct plugin_option *o, struct openvpn_plugin_string_list **retlist, const char **envp, const int init_point)
plugin_option	plugin.h	/^struct plugin_option {$/;"	s
plugin_option::argv	plugin.h	/^    const char **argv;$/;"	m	struct:plugin_option	access:public
plugin_option::so_pathname	plugin.h	/^    const char *so_pathname;$/;"	m	struct:plugin_option	access:public
plugin_option_list	plugin.h	/^struct plugin_option_list {$/;"	s
plugin_option_list::n	plugin.h	/^    int n;$/;"	m	struct:plugin_option_list	access:public
plugin_option_list::plugins	plugin.h	/^    struct plugin_option plugins[MAX_PLUGINS];$/;"	m	struct:plugin_option_list	typeref:struct:plugin_option_list::plugin_option	access:public
plugin_option_list_add	plugin.c	/^plugin_option_list_add(struct plugin_option_list *list, char **p, struct gc_arena *gc)$/;"	f	signature:(struct plugin_option_list *list, char **p, struct gc_arena *gc)
plugin_option_list_add	plugin.h	/^bool plugin_option_list_add(struct plugin_option_list *list, char **p, struct gc_arena *gc);$/;"	p	signature:(struct plugin_option_list *list, char **p, struct gc_arena *gc)
plugin_option_list_new	plugin.c	/^plugin_option_list_new(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
plugin_option_list_new	plugin.h	/^struct plugin_option_list *plugin_option_list_new(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
plugin_option_list_print	plugin.c	/^plugin_option_list_print(const struct plugin_option_list *list, int msglevel)$/;"	f	signature:(const struct plugin_option_list *list, int msglevel)
plugin_option_list_print	plugin.h	/^void plugin_option_list_print(const struct plugin_option_list *list, int msglevel);$/;"	p	signature:(const struct plugin_option_list *list, int msglevel)
plugin_per_client	plugin.h	/^struct plugin_per_client$/;"	s
plugin_per_client::per_client_context	plugin.h	/^    void *per_client_context[MAX_PLUGINS];$/;"	m	struct:plugin_per_client	access:public
plugin_per_client_destroy	plugin.c	/^plugin_per_client_destroy(const struct plugin_common *pc, struct plugin_per_client *cli)$/;"	f	file:	signature:(const struct plugin_common *pc, struct plugin_per_client *cli)
plugin_per_client_init	plugin.c	/^plugin_per_client_init(const struct plugin_common *pc,$/;"	f	file:	signature:(const struct plugin_common *pc, struct plugin_per_client *cli, const int init_point)
plugin_return	plugin.h	/^struct plugin_return { int dummy; };$/;"	s
plugin_return	plugin.h	/^struct plugin_return$/;"	s
plugin_return::dummy	plugin.h	/^struct plugin_return { int dummy; };$/;"	m	struct:plugin_return	access:public
plugin_return::list	plugin.h	/^    struct openvpn_plugin_string_list *list[MAX_PLUGINS];$/;"	m	struct:plugin_return	typeref:struct:plugin_return::openvpn_plugin_string_list	access:public
plugin_return::n	plugin.h	/^    int n;$/;"	m	struct:plugin_return	access:public
plugin_return_defined	plugin.h	/^plugin_return_defined(const struct plugin_return *pr)$/;"	f	signature:(const struct plugin_return *pr)
plugin_return_free	plugin.c	/^plugin_return_free(struct plugin_return *pr)$/;"	f	signature:(struct plugin_return *pr)
plugin_return_free	plugin.h	/^void plugin_return_free(struct plugin_return *pr);$/;"	p	signature:(struct plugin_return *pr)
plugin_return_get_column	plugin.c	/^plugin_return_get_column(const struct plugin_return *src,$/;"	f	signature:(const struct plugin_return *src, struct plugin_return *dest, const char *colname)
plugin_return_get_column	plugin.h	/^void plugin_return_get_column(const struct plugin_return *src,$/;"	p	signature:(const struct plugin_return *src, struct plugin_return *dest, const char *colname)
plugin_return_init	plugin.h	/^plugin_return_init(struct plugin_return *pr)$/;"	f	signature:(struct plugin_return *pr)
plugin_return_print	plugin.c	/^plugin_return_print(const int msglevel, const char *prefix, const struct plugin_return *pr)$/;"	f	signature:(const int msglevel, const char *prefix, const struct plugin_return *pr)
plugin_return_print	plugin.h	/^void plugin_return_print(const int msglevel, const char *prefix, const struct plugin_return *pr);$/;"	p	signature:(const int msglevel, const char *prefix, const struct plugin_return *pr)
plugin_show_args_env	plugin.c	/^plugin_show_args_env(int msglevel, const char *argv[], const char *envp[])$/;"	f	file:	signature:(int msglevel, const char *argv[], const char *envp[])
plugin_show_string_array	plugin.c	/^plugin_show_string_array(int msglevel, const char *name, const char *array[])$/;"	f	file:	signature:(int msglevel, const char *name, const char *array[])
plugin_supported_types	plugin.c	/^plugin_supported_types(void)$/;"	f	file:	signature:(void)
plugin_type_mask	plugin.h	/^    unsigned int plugin_type_mask;$/;"	m	struct:plugin	access:public
plugin_type_name	plugin.c	/^plugin_type_name(const int type)$/;"	f	file:	signature:(const int type)
plugin_vlog	plugin.c	/^plugin_vlog(openvpn_plugin_log_flags_t flags, const char *name, const char *format, va_list arglist)$/;"	f	file:	signature:(openvpn_plugin_log_flags_t flags, const char *name, const char *format, va_list arglist)
plugins	openvpn.h	/^    struct plugin_list *plugins; \/**< List of plug-ins. *\/$/;"	m	struct:context	typeref:struct:context::plugin_list	access:public
plugins	plugin.h	/^    struct plugin plugins[MAX_PLUGINS];$/;"	m	struct:plugin_common	typeref:struct:plugin_common::plugin	access:public
plugins	plugin.h	/^    struct plugin_option plugins[MAX_PLUGINS];$/;"	m	struct:plugin_option_list	typeref:struct:plugin_option_list::plugin_option	access:public
plugins	socket.h	/^    const struct plugin_list *plugins;$/;"	m	struct:link_socket_info	typeref:struct:link_socket_info::plugin_list	access:public
plugins	ssl_common.h	/^    const struct plugin_list *plugins;$/;"	m	struct:tls_options	typeref:struct:tls_options::plugin_list	access:public
plugins_owned	openvpn.h	/^    bool plugins_owned;         \/**< Whether the plug-ins should be$/;"	m	struct:context	access:public
po_append_event	event.c	/^po_append_event(struct po_set *pos, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct po_set *pos, event_t event, unsigned int rwflags, void *arg)
po_ctl	event.c	/^po_ctl(struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct event_set *es, event_t event, unsigned int rwflags, void *arg)
po_del	event.c	/^po_del(struct event_set *es, event_t event)$/;"	f	file:	signature:(struct event_set *es, event_t event)
po_free	event.c	/^po_free(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
po_init	event.c	/^po_init(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
po_reset	event.c	/^po_reset(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
po_set	event.c	/^struct po_set$/;"	s	file:
po_set::args	event.c	/^    void **args;$/;"	m	struct:po_set	file:	access:public
po_set::capacity	event.c	/^    int capacity;$/;"	m	struct:po_set	file:	access:public
po_set::events	event.c	/^    struct pollfd *events;$/;"	m	struct:po_set	typeref:struct:po_set::pollfd	file:	access:public
po_set::fast	event.c	/^    bool fast;$/;"	m	struct:po_set	file:	access:public
po_set::func	event.c	/^    struct event_set_functions func;$/;"	m	struct:po_set	typeref:struct:po_set::event_set_functions	file:	access:public
po_set::n_events	event.c	/^    int n_events;$/;"	m	struct:po_set	file:	access:public
po_set_pollfd_events	event.c	/^po_set_pollfd_events(struct pollfd *pfdp, unsigned int rwflags)$/;"	f	file:	signature:(struct pollfd *pfdp, unsigned int rwflags)
po_wait	event.c	/^po_wait(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
pop_perf_index	perf.c	/^pop_perf_index(void)$/;"	f	file:	signature:(void)
port	mroute.h	/^            in_port_t port;     \/* _network order_ TCP\/UDP port *\/$/;"	m	struct:mroute_addr::__anon4::__anon5	access:public
port	mroute.h	/^            in_port_t port;     \/* _network order_ TCP\/UDP port *\/$/;"	m	struct:mroute_addr::__anon4::__anon6	access:public
port	options.h	/^    char port[RH_PORT_LEN];$/;"	m	struct:remote_host_store	access:public
port	proxy.h	/^    const char *port;$/;"	m	struct:http_proxy_options	access:public
port	proxy.h	/^    const char *port;$/;"	m	struct:http_proxy_options_simple	access:public
port	socks.h	/^    const char *port;$/;"	m	struct:socks_proxy_info	access:public
port_from_servname	socks.c	/^port_from_servname(const char *servname)$/;"	f	file:	signature:(const char *servname)
port_share	ps.c	/^struct port_share *port_share = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:port_share
port_share	ps.h	/^struct port_share {$/;"	s
port_share::background_pid	ps.h	/^    pid_t background_pid;$/;"	m	struct:port_share	access:public
port_share::foreground_fd	ps.h	/^    socket_descriptor_t foreground_fd;$/;"	m	struct:port_share	access:public
port_share_abort	ps.c	/^port_share_abort(struct port_share *ps)$/;"	f	signature:(struct port_share *ps)
port_share_abort	ps.h	/^void port_share_abort(struct port_share *ps);$/;"	p	signature:(struct port_share *ps)
port_share_close	ps.c	/^port_share_close(struct port_share *ps)$/;"	f	signature:(struct port_share *ps)
port_share_close	ps.h	/^void port_share_close(struct port_share *ps);$/;"	p	signature:(struct port_share *ps)
port_share_host	options.h	/^    char *port_share_host;$/;"	m	struct:options	access:public
port_share_journal_dir	options.h	/^    const char *port_share_journal_dir;$/;"	m	struct:options	access:public
port_share_open	ps.c	/^port_share_open(const char *host,$/;"	f	signature:(const char *host, const char *port, const int max_initial_buf, const char *journal_dir)
port_share_open	ps.h	/^struct port_share *port_share_open(const char *host,$/;"	p	signature:(const char *host, const char *port, const int max_initial_buf, const char *journal_dir)
port_share_port	options.h	/^    char *port_share_port;$/;"	m	struct:options	access:public
port_share_proxy	ps.c	/^port_share_proxy(const struct sockaddr_in hostaddr,$/;"	f	file:	signature:(const struct sockaddr_in hostaddr, const socket_descriptor_t sd_control, const int max_initial_buf, const char *journal_dir)
port_share_redirect	ps.c	/^port_share_redirect(struct port_share *ps, const struct buffer *head, socket_descriptor_t sd)$/;"	f	signature:(struct port_share *ps, const struct buffer *head, socket_descriptor_t sd)
port_share_redirect	ps.h	/^void port_share_redirect(struct port_share *ps, const struct buffer *head, socket_descriptor_t sd);$/;"	p	signature:(struct port_share *ps, const struct buffer *head, socket_descriptor_t sd)
port_share_sendmsg	ps.c	/^port_share_sendmsg(const socket_descriptor_t sd,$/;"	f	file:	signature:(const socket_descriptor_t sd, const char command, const struct buffer *head, const socket_descriptor_t sd_send)
port_share_state	socket.h	/^    int port_share_state;$/;"	m	struct:stream_buf	access:public
pos	base64.c	/^pos(char c)$/;"	f	file:	signature:(char c)
positive_atoi	options.c	/^positive_atoi(const char *str)$/;"	f	file:	signature:(const char *str)
possibly_become_daemon	init.c	/^possibly_become_daemon(const struct options *options)$/;"	f	signature:(const struct options *options)
possibly_become_daemon	init.h	/^bool possibly_become_daemon(const struct options *options);$/;"	p	signature:(const struct options *options)
post_compress	comp.h	/^    counter_type post_compress;$/;"	m	struct:compress_context	access:public
post_decompress	comp.h	/^    counter_type post_decompress;$/;"	m	struct:compress_context	access:public
post_fork_cleanup_func_t	ps.h	/^typedef void (*post_fork_cleanup_func_t)(void *arg);$/;"	t
post_init_signal_catch	sig.c	/^post_init_signal_catch(void)$/;"	f	signature:(void)
post_init_signal_catch	sig.h	/^void post_init_signal_catch(void);$/;"	p	signature:(void)
post_open_mtu	tun.h	/^    int post_open_mtu;$/;"	m	struct:tuntap	access:public
pract	mtcp.c	/^pract(int action)$/;"	f	file:	signature:(int action)
pre_compress	comp.h	/^    counter_type pre_compress;$/;"	m	struct:compress_context	access:public
pre_decompress	comp.h	/^    counter_type pre_decompress;$/;"	m	struct:compress_context	access:public
pre_init_signal_catch	sig.c	/^pre_init_signal_catch(void)$/;"	f	signature:(void)
pre_init_signal_catch	sig.h	/^void pre_init_signal_catch(void);$/;"	p	signature:(void)
pre_master	ssl_common.h	/^    uint8_t pre_master[48];     \/**< Random used for master secret$/;"	m	struct:key_source	access:public
pre_pull	options.h	/^    struct options_pre_pull *pre_pull;$/;"	m	struct:options	typeref:struct:options::options_pre_pull	access:public
pre_pull_default	options.h	/^void pre_pull_default(struct options *o);$/;"	p	signature:(struct options *o)
pre_pull_restore	options.c	/^pre_pull_restore(struct options *o, struct gc_arena *gc)$/;"	f	signature:(struct options *o, struct gc_arena *gc)
pre_pull_restore	options.h	/^void pre_pull_restore(struct options *o, struct gc_arena *gc);$/;"	p	signature:(struct options *o, struct gc_arena *gc)
pre_pull_save	options.c	/^pre_pull_save(struct options *o)$/;"	f	signature:(struct options *o)
pre_pull_save	options.h	/^void pre_pull_save(struct options *o);$/;"	p	signature:(struct options *o)
pre_select	forward.c	/^pre_select(struct context *c)$/;"	f	signature:(struct context *c)
pre_select	forward.h	/^void pre_select(struct context *c);$/;"	p	signature:(struct context *c)
pre_setup	init.c	/^pre_setup(const struct options *options)$/;"	f	signature:(const struct options *options)
pre_setup	init.h	/^void pre_setup(const struct options *options);$/;"	p	signature:(const struct options *options)
prefix	mroute.h	/^            uint8_t prefix[12];$/;"	m	struct:mroute_addr::__anon4::__anon7	access:public
prefix	route.h	/^    const char *prefix;         \/* e.g. "2001:db8:1::\/64" *\/$/;"	m	struct:route_ipv6_option	access:public
prepare_push_reply	push.c	/^prepare_push_reply(struct context *c, struct gc_arena *gc,$/;"	f	file:	signature:(struct context *c, struct gc_arena *gc, struct push_list *push_list)
pri	schedule.h	/^    unsigned int pri;            \/* random treap priority *\/$/;"	m	struct:schedule_entry	access:public
print_argv	buffer.c	/^print_argv(const char **p, struct gc_arena *gc, const unsigned int flags)$/;"	f	signature:(const char **p, struct gc_arena *gc, const unsigned int flags)
print_argv	buffer.h	/^char *print_argv(const char **p, struct gc_arena *gc, const unsigned int flags);$/;"	p	signature:(const char **p, struct gc_arena *gc, const unsigned int flags)
print_bypass_addresses	route.c	/^print_bypass_addresses(const struct route_bypass *rb)$/;"	f	file:	signature:(const struct route_bypass *rb)
print_cipher	crypto_mbedtls.c	/^print_cipher(const cipher_kt_t *info)$/;"	f	file:	signature:(const cipher_kt_t *info)
print_cipher	crypto_openssl.c	/^print_cipher(const EVP_CIPHER *cipher)$/;"	f	file:	signature:(const EVP_CIPHER *cipher)
print_client_nat_list	clinat.c	/^print_client_nat_list(const struct client_nat_option_list *list, int msglevel)$/;"	f	signature:(const struct client_nat_option_list *list, int msglevel)
print_client_nat_list	clinat.h	/^void print_client_nat_list(const struct client_nat_option_list *list, int msglevel);$/;"	p	signature:(const struct client_nat_option_list *list, int msglevel)
print_default_gateway	route.c	/^print_default_gateway(const int msglevel,$/;"	f	signature:(const int msglevel, const struct route_gateway_info *rgi, const struct route_ipv6_gateway_info *rgi6)
print_default_gateway	route.h	/^void print_default_gateway(const int msglevel,$/;"	p	signature:(const int msglevel, const struct route_gateway_info *rgi, const struct route_ipv6_gateway_info *rgi6)
print_details	ssl_backend.h	/^void print_details(struct key_state_ssl *ks_ssl, const char *prefix);$/;"	p	signature:(struct key_state_ssl *ks_ssl, const char *prefix)
print_details	ssl_mbedtls.c	/^print_details(struct key_state_ssl *ks_ssl, const char *prefix)$/;"	f	signature:(struct key_state_ssl *ks_ssl, const char *prefix)
print_details	ssl_openssl.c	/^print_details(struct key_state_ssl *ks_ssl, const char *prefix)$/;"	f	signature:(struct key_state_ssl *ks_ssl, const char *prefix)
print_in6_addr	socket.c	/^print_in6_addr(struct in6_addr a6, unsigned int flags, struct gc_arena *gc)$/;"	f	signature:(struct in6_addr a6, unsigned int flags, struct gc_arena *gc)
print_in6_addr	socket.h	/^const char *print_in6_addr(struct in6_addr addr6, unsigned int flags, struct gc_arena *gc);$/;"	p	signature:(struct in6_addr addr6, unsigned int flags, struct gc_arena *gc)
print_in_addr_t	socket.c	/^print_in_addr_t(in_addr_t addr, unsigned int flags, struct gc_arena *gc)$/;"	f	signature:(in_addr_t addr, unsigned int flags, struct gc_arena *gc)
print_in_addr_t	socket.h	/^const char *print_in_addr_t(in_addr_t addr, unsigned int flags, struct gc_arena *gc);$/;"	p	signature:(in_addr_t addr, unsigned int flags, struct gc_arena *gc)
print_key_id	ssl.c	/^print_key_id(struct tls_multi *multi, struct gc_arena *gc)$/;"	f	file:	signature:(struct tls_multi *multi, struct gc_arena *gc)
print_link_socket_actual	socket.c	/^print_link_socket_actual(const struct link_socket_actual *act, struct gc_arena *gc)$/;"	f	signature:(const struct link_socket_actual *act, struct gc_arena *gc)
print_link_socket_actual	socket.h	/^const char *print_link_socket_actual(const struct link_socket_actual *act,$/;"	p	signature:(const struct link_socket_actual *act, struct gc_arena *gc)
print_link_socket_actual_ex	socket.c	/^print_link_socket_actual_ex(const struct link_socket_actual *act,$/;"	f	signature:(const struct link_socket_actual *act, const char *separator, const unsigned int flags, struct gc_arena *gc)
print_link_socket_actual_ex	socket.h	/^const char *print_link_socket_actual_ex(const struct link_socket_actual *act,$/;"	p	signature:(const struct link_socket_actual *act, const char *separator, const unsigned int flags, struct gc_arena *gc)
print_netmask	helper.c	/^print_netmask(int netbits, struct gc_arena *gc)$/;"	f	file:	signature:(int netbits, struct gc_arena *gc)
print_nhash	list.c	/^print_nhash(struct hash *hash)$/;"	f	file:	signature:(struct hash *hash)
print_nsCertType	ssl_verify.c	/^print_nsCertType(int type)$/;"	f	file:	signature:(int type)
print_openssl_info	init.c	/^print_openssl_info(const struct options *options)$/;"	f	signature:(const struct options *options)
print_openssl_info	init.h	/^bool print_openssl_info(const struct options *options);$/;"	p	signature:(const struct options *options)
print_openvpn_sockaddr	socket.h	/^print_openvpn_sockaddr(const struct openvpn_sockaddr *addr,$/;"	f	signature:(const struct openvpn_sockaddr *addr, struct gc_arena *gc)
print_openvpn_sockaddr_ex	socket.h	/^print_openvpn_sockaddr_ex(const struct openvpn_sockaddr *addr,$/;"	f	signature:(const struct openvpn_sockaddr *addr, const char *separator, const unsigned int flags, struct gc_arena *gc)
print_opt_route	helper.c	/^print_opt_route(const in_addr_t network, const in_addr_t netmask, struct gc_arena *gc)$/;"	f	file:	signature:(const in_addr_t network, const in_addr_t netmask, struct gc_arena *gc)
print_opt_route_gateway	helper.c	/^print_opt_route_gateway(const in_addr_t route_gateway, struct gc_arena *gc)$/;"	f	file:	signature:(const in_addr_t route_gateway, struct gc_arena *gc)
print_opt_route_gateway_dhcp	helper.c	/^print_opt_route_gateway_dhcp(struct gc_arena *gc)$/;"	f	file:	signature:(struct gc_arena *gc)
print_opt_topology	helper.c	/^print_opt_topology(const int topology, struct gc_arena *gc)$/;"	f	file:	signature:(const int topology, struct gc_arena *gc)
print_pkt	clinat.c	/^print_pkt(struct openvpn_iphdr *iph, const char *prefix, const int direction, const int msglevel)$/;"	f	file:	signature:(struct openvpn_iphdr *iph, const char *prefix, const int direction, const int msglevel)
print_route	route.c	/^print_route(const struct route_ipv4 *r, int level)$/;"	f	file:	signature:(const struct route_ipv4 *r, int level)
print_route_option	route.c	/^print_route_option(const struct route_option *ro, int level)$/;"	f	file:	signature:(const struct route_option *ro, int level)
print_route_options	route.c	/^print_route_options(const struct route_option_list *rol,$/;"	f	signature:(const struct route_option_list *rol, int level)
print_route_options	route.h	/^void print_route_options(const struct route_option_list *rol,$/;"	p	signature:(const struct route_option_list *rol, int level)
print_routes	route.c	/^print_routes(const struct route_list *rl, int level)$/;"	f	signature:(const struct route_list *rl, int level)
print_routes	route.h	/^void print_routes(const struct route_list *rl, int level);$/;"	p	signature:(const struct route_list *rl, int level)
print_signal	sig.c	/^print_signal(const struct signal_info *si, const char *title, int msglevel)$/;"	f	signature:(const struct signal_info *si, const char *title, int msglevel)
print_signal	sig.h	/^void print_signal(const struct signal_info *si, const char *title, int msglevel);$/;"	p	signature:(const struct signal_info *si, const char *title, int msglevel)
print_sockaddr	socket.h	/^print_sockaddr(const struct sockaddr *addr,$/;"	f	signature:(const struct sockaddr *addr, struct gc_arena *gc)
print_sockaddr_ex	socket.c	/^print_sockaddr_ex(const struct sockaddr *sa,$/;"	f	signature:(const struct sockaddr *sa, const char *separator, const unsigned int flags, struct gc_arena *gc)
print_sockaddr_ex	socket.h	/^const char *print_sockaddr_ex(const struct sockaddr *addr,$/;"	p	signature:(const struct sockaddr *addr, const char *separator, const unsigned int flags, struct gc_arena *gc)
print_status	sig.c	/^print_status(const struct context *c, struct status_output *so)$/;"	f	signature:(const struct context *c, struct status_output *so)
print_status	sig.h	/^void print_status(const struct context *c, struct status_output *so);$/;"	p	signature:(const struct context *c, struct status_output *so)
print_status_mode	status.c	/^print_status_mode(unsigned int flags)$/;"	f	file:	signature:(unsigned int flags)
print_str	helper.c	/^print_str(const char *str, struct gc_arena *gc)$/;"	f	file:	signature:(const char *str, struct gc_arena *gc)
print_str_int	helper.c	/^print_str_int(const char *str, const int i, struct gc_arena *gc)$/;"	f	file:	signature:(const char *str, const int i, struct gc_arena *gc)
print_topology	options.c	/^print_topology(const int topology)$/;"	f	signature:(const int topology)
print_topology	options.h	/^const char *print_topology(const int topology);$/;"	p	signature:(const int topology)
printable_char_fmt	crypto.c	/^static const char printable_char_fmt[] =$/;"	v	file:
priv_enc_CNG	cryptoapi.c	/^priv_enc_CNG(const CAPI_DATA *cd, const wchar_t *hash_algo, const unsigned char *from,$/;"	f	file:	signature:(const CAPI_DATA *cd, const wchar_t *hash_algo, const unsigned char *from, int flen, unsigned char *to, int tlen, int padding)
priv_key	ssl_mbedtls.h	/^    mbedtls_pk_context *priv_key;       \/**< Local private key *\/$/;"	m	struct:tls_root_ctx	access:public
priv_key_file	options.h	/^    const char *priv_key_file;$/;"	m	struct:options	access:public
priv_key_file_inline	options.h	/^    char *priv_key_file_inline;$/;"	m	struct:options	access:public
priv_key_pkcs11	ssl_mbedtls.h	/^    mbedtls_pkcs11_context *priv_key_pkcs11;    \/**< PKCS11 private key *\/$/;"	m	struct:tls_root_ctx	access:public
prng_bytes	crypto.c	/^prng_bytes(uint8_t *output, int len)$/;"	f	signature:(uint8_t *output, int len)
prng_bytes	crypto.h	/^void prng_bytes(uint8_t *output, int len);$/;"	p	signature:(uint8_t *output, int len)
prng_hash	options.h	/^    const char *prng_hash;$/;"	m	struct:options	access:public
prng_init	crypto.c	/^prng_init(const char *md_name, const int nonce_secret_len_parm)$/;"	f	signature:(const char *md_name, const int nonce_secret_len_parm)
prng_init	crypto.h	/^void prng_init(const char *md_name, const int nonce_secret_len_parm);$/;"	p	signature:(const char *md_name, const int nonce_secret_len_parm)
prng_nonce_secret_len	options.h	/^    int prng_nonce_secret_len;$/;"	m	struct:options	access:public
prng_reset_nonce	crypto.c	/^prng_reset_nonce(void)$/;"	f	file:	signature:(void)
prng_uninit	crypto.c	/^prng_uninit(void)$/;"	f	signature:(void)
prng_uninit	crypto.h	/^void prng_uninit(void);$/;"	p	signature:(void)
probehdr	mtu.c	/^struct probehdr$/;"	s	file:
probehdr::ttl	mtu.c	/^    uint32_t ttl;$/;"	m	struct:probehdr	file:	access:public
probehdr::tv	mtu.c	/^    struct timeval tv;$/;"	m	struct:probehdr	typeref:struct:probehdr::timeval	file:	access:public
process_coarse_timers	forward.c	/^process_coarse_timers(struct context *c)$/;"	f	file:	signature:(struct context *c)
process_explicit_exit_notification_init	sig.c	/^process_explicit_exit_notification_init(struct context *c)$/;"	f	file:	signature:(struct context *c)
process_explicit_exit_notification_timer_wakeup	sig.c	/^process_explicit_exit_notification_timer_wakeup(struct context *c)$/;"	f	signature:(struct context *c)
process_explicit_exit_notification_timer_wakeup	sig.h	/^void process_explicit_exit_notification_timer_wakeup(struct context *c);$/;"	p	signature:(struct context *c)
process_incoming_link	forward.c	/^process_incoming_link(struct context *c)$/;"	f	file:	signature:(struct context *c)
process_incoming_link_part1	forward.c	/^process_incoming_link_part1(struct context *c, struct link_socket_info *lsi, bool floated)$/;"	f	signature:(struct context *c, struct link_socket_info *lsi, bool floated)
process_incoming_link_part1	forward.h	/^bool process_incoming_link_part1(struct context *c, struct link_socket_info *lsi, bool floated);$/;"	p	signature:(struct context *c, struct link_socket_info *lsi, bool floated)
process_incoming_link_part2	forward.c	/^process_incoming_link_part2(struct context *c, struct link_socket_info *lsi, const uint8_t *orig_buf)$/;"	f	signature:(struct context *c, struct link_socket_info *lsi, const uint8_t *orig_buf)
process_incoming_link_part2	forward.h	/^void process_incoming_link_part2(struct context *c, struct link_socket_info *lsi, const uint8_t *orig_buf);$/;"	p	signature:(struct context *c, struct link_socket_info *lsi, const uint8_t *orig_buf)
process_incoming_push_msg	push.c	/^process_incoming_push_msg(struct context *c,$/;"	f	signature:(struct context *c, const struct buffer *buffer, bool honor_received_options, unsigned int permission_mask, unsigned int *option_types_found)
process_incoming_push_msg	push.h	/^int process_incoming_push_msg(struct context *c,$/;"	p	signature:(struct context *c, const struct buffer *buffer, bool honor_received_options, unsigned int permission_mask, unsigned int *option_types_found)
process_incoming_push_request	push.c	/^process_incoming_push_request(struct context *c)$/;"	f	signature:(struct context *c)
process_incoming_push_request	push.h	/^int process_incoming_push_request(struct context *c);$/;"	p	signature:(struct context *c)
process_incoming_tun	forward.c	/^process_incoming_tun(struct context *c)$/;"	f	signature:(struct context *c)
process_incoming_tun	forward.h	/^void process_incoming_tun(struct context *c);$/;"	p	signature:(struct context *c)
process_io	forward.c	/^process_io(struct context *c)$/;"	f	signature:(struct context *c)
process_io	forward.h	/^void process_io(struct context *c);$/;"	p	signature:(struct context *c)
process_ip_header	forward.c	/^process_ip_header(struct context *c, unsigned int flags, struct buffer *buf)$/;"	f	signature:(struct context *c, unsigned int flags, struct buffer *buf)
process_ip_header	forward.h	/^void process_ip_header(struct context *c, unsigned int flags, struct buffer *buf);$/;"	p	signature:(struct context *c, unsigned int flags, struct buffer *buf)
process_outgoing_link	forward.c	/^process_outgoing_link(struct context *c)$/;"	f	signature:(struct context *c)
process_outgoing_link	forward.h	/^void process_outgoing_link(struct context *c);$/;"	p	signature:(struct context *c)
process_outgoing_tun	forward.c	/^process_outgoing_tun(struct context *c)$/;"	f	signature:(struct context *c)
process_outgoing_tun	forward.h	/^void process_outgoing_tun(struct context *c);$/;"	p	signature:(struct context *c)
process_received_occ_msg	occ.c	/^process_received_occ_msg(struct context *c)$/;"	f	signature:(struct context *c)
process_received_occ_msg	occ.h	/^void process_received_occ_msg(struct context *c);$/;"	p	signature:(struct context *c)
process_signal	sig.c	/^process_signal(struct context *c)$/;"	f	signature:(struct context *c)
process_signal	sig.h	/^bool process_signal(struct context *c);$/;"	p	signature:(struct context *c)
process_signal_p2p	openvpn.c	/^process_signal_p2p(struct context *c)$/;"	f	file:	signature:(struct context *c)
process_sigterm	sig.c	/^process_sigterm(struct context *c)$/;"	f	file:	signature:(struct context *c)
process_sigusr2	sig.c	/^process_sigusr2(const struct context *c)$/;"	f	file:	signature:(const struct context *c)
prompt	console.h	/^    char *prompt;             \/**< Prompt to present to the user *\/$/;"	m	struct:_query_user	access:public
prompt_len	console.h	/^    size_t prompt_len;        \/**< Lenght of the prompt string *\/$/;"	m	struct:_query_user	access:public
protect_fd_nonlocal	socket.c	/^protect_fd_nonlocal(int fd, const struct sockaddr *addr)$/;"	f	file:	signature:(int fd, const struct sockaddr *addr)
proto	options.h	/^    int proto;$/;"	m	struct:connection_entry	access:public
proto	options.h	/^    int proto;$/;"	m	struct:remote_entry	access:public
proto	proto.h	/^    uint16_t proto;                   \/* packet type ID field *\/$/;"	m	struct:openvpn_ethhdr	access:public
proto	socket.c	/^    int proto;$/;"	m	struct:proto_names	file:	access:public
proto	socket.h	/^    int proto;                  \/* Protocol (PROTO_x defined below) *\/$/;"	m	struct:link_socket_info	access:public
proto2ascii	socket.c	/^proto2ascii(int proto, sa_family_t af, bool display_form)$/;"	f	signature:(int proto, sa_family_t af, bool display_form)
proto2ascii	socket.h	/^const char *proto2ascii(int proto, sa_family_t af, bool display_form);$/;"	p	signature:(int proto, sa_family_t af, bool display_form)
proto2ascii_all	socket.c	/^proto2ascii_all(struct gc_arena *gc)$/;"	f	signature:(struct gc_arena *gc)
proto2ascii_all	socket.h	/^const char *proto2ascii_all(struct gc_arena *gc);$/;"	p	signature:(struct gc_arena *gc)
proto_addr_size	proto.h	/^    uint8_t proto_addr_size;    \/* 0x04 *\/$/;"	m	struct:openvpn_arp	access:public
proto_addr_type	proto.h	/^    uint16_t proto_addr_type;   \/* 0x0800 *\/$/;"	m	struct:openvpn_arp	access:public
proto_af	socket.c	/^    sa_family_t proto_af;$/;"	m	struct:proto_names	file:	access:public
proto_force	options.h	/^    int proto_force;$/;"	m	struct:options	access:public
proto_is_dgram	socket.c	/^proto_is_dgram(int proto)$/;"	f	signature:(int proto)
proto_is_dgram	socket.h	/^bool proto_is_dgram(int proto);$/;"	p	signature:(int proto)
proto_is_net	socket.c	/^proto_is_net(int proto)$/;"	f	signature:(int proto)
proto_is_net	socket.h	/^bool proto_is_net(int proto);$/;"	p	signature:(int proto)
proto_is_tcp	socket.c	/^proto_is_tcp(int proto)$/;"	f	signature:(int proto)
proto_is_tcp	socket.h	/^bool proto_is_tcp(int proto);$/;"	p	signature:(int proto)
proto_is_udp	socket.c	/^proto_is_udp(int proto)$/;"	f	signature:(int proto)
proto_is_udp	socket.h	/^bool proto_is_udp(int proto);$/;"	p	signature:(int proto)
proto_names	socket.c	/^static const struct proto_names proto_names[] = {$/;"	v	typeref:struct:proto_names	file:
proto_names	socket.c	/^struct proto_names {$/;"	s	file:
proto_names::display_form	socket.c	/^    const char *display_form;$/;"	m	struct:proto_names	file:	access:public
proto_names::proto	socket.c	/^    int proto;$/;"	m	struct:proto_names	file:	access:public
proto_names::proto_af	socket.c	/^    sa_family_t proto_af;$/;"	m	struct:proto_names	file:	access:public
proto_names::short_form	socket.c	/^    const char *short_form;$/;"	m	struct:proto_names	file:	access:public
proto_num	socket.h	/^enum proto_num {$/;"	g
proto_overhead	socket.c	/^const int proto_overhead[] = { \/* indexed by PROTO_x *\/$/;"	v
proto_remote	socket.c	/^proto_remote(int proto, bool remote)$/;"	f	signature:(int proto, bool remote)
proto_remote	socket.h	/^const char *proto_remote(int proto, bool remote);$/;"	p	signature:(int proto, bool remote)
protocol	proto.h	/^    uint8_t protocol;$/;"	m	struct:openvpn_iphdr	access:public
protocol_dump	ssl.c	/^protocol_dump(struct buffer *buffer, unsigned int flags, struct gc_arena *gc)$/;"	f	signature:(struct buffer *buffer, unsigned int flags, struct gc_arena *gc)
protocol_dump	ssl.h	/^const char *protocol_dump(struct buffer *buffer,$/;"	p	signature:(struct buffer *buffer, unsigned int flags, struct gc_arena *gc)
proxy_authenticate	proxy.h	/^    char *proxy_authenticate;$/;"	m	struct:http_proxy_info	access:public
proxy_cmd	manage.h	/^    bool (*proxy_cmd)(void *arg, const char **p);$/;"	m	struct:management_callback	access:public
proxy_connection	ps.c	/^struct proxy_connection {$/;"	s	file:
proxy_connection::buf	ps.c	/^    struct buffer buf;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::buffer	file:	access:public
proxy_connection::buffer_initial	ps.c	/^    bool buffer_initial;$/;"	m	struct:proxy_connection	file:	access:public
proxy_connection::counterpart	ps.c	/^    struct proxy_connection *counterpart;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:	access:public
proxy_connection::defined	ps.c	/^    bool defined;$/;"	m	struct:proxy_connection	file:	access:public
proxy_connection::jfn	ps.c	/^    char *jfn;$/;"	m	struct:proxy_connection	file:	access:public
proxy_connection::next	ps.c	/^    struct proxy_connection *next;$/;"	m	struct:proxy_connection	typeref:struct:proxy_connection::proxy_connection	file:	access:public
proxy_connection::rwflags	ps.c	/^    int rwflags;$/;"	m	struct:proxy_connection	file:	access:public
proxy_connection::sd	ps.c	/^    int sd;$/;"	m	struct:proxy_connection	file:	access:public
proxy_connection_io_dispatch	ps.c	/^proxy_connection_io_dispatch(struct proxy_connection *pc,$/;"	f	file:	signature:(struct proxy_connection *pc, const int rwflags, struct event_set *es)
proxy_connection_io_recv	ps.c	/^proxy_connection_io_recv(struct proxy_connection *pc)$/;"	f	file:	signature:(struct proxy_connection *pc)
proxy_connection_io_requeue	ps.c	/^proxy_connection_io_requeue(struct proxy_connection *pc, const int rwflags_new, struct event_set *es)$/;"	f	file:	signature:(struct proxy_connection *pc, const int rwflags_new, struct event_set *es)
proxy_connection_io_send	ps.c	/^proxy_connection_io_send(struct proxy_connection *pc, int *bytes_sent)$/;"	f	file:	signature:(struct proxy_connection *pc, int *bytes_sent)
proxy_connection_io_status	ps.c	/^proxy_connection_io_status(const int status, int *rwflags_pc, int *rwflags_cp)$/;"	f	file:	signature:(const int status, int *rwflags_pc, int *rwflags_cp)
proxy_connection_io_xfer	ps.c	/^proxy_connection_io_xfer(struct proxy_connection *pc, const int max_transfer)$/;"	f	file:	signature:(struct proxy_connection *pc, const int max_transfer)
proxy_dest_host	socket.h	/^    const char *proxy_dest_host;$/;"	m	struct:link_socket	access:public
proxy_dest_port	socket.h	/^    const char *proxy_dest_port;$/;"	m	struct:link_socket	access:public
proxy_entry_close_sd	ps.c	/^proxy_entry_close_sd(struct proxy_connection *pc, struct event_set *es)$/;"	f	file:	signature:(struct proxy_connection *pc, struct event_set *es)
proxy_entry_mark_for_close	ps.c	/^proxy_entry_mark_for_close(struct proxy_connection *pc, struct event_set *es)$/;"	f	file:	signature:(struct proxy_connection *pc, struct event_set *es)
proxy_entry_new	ps.c	/^proxy_entry_new(struct proxy_connection **list,$/;"	f	file:	signature:(struct proxy_connection **list, struct event_set *es, const struct sockaddr_in server_addr, const socket_descriptor_t sd_client, struct buffer *initial_data, const char *journal_dir)
proxy_list_close	ps.c	/^proxy_list_close(struct proxy_connection **list)$/;"	f	file:	signature:(struct proxy_connection **list)
proxy_list_housekeeping	ps.c	/^proxy_list_housekeeping(struct proxy_connection **list)$/;"	f	file:	signature:(struct proxy_connection **list)
ptos	socket.h	/^    int ptos;$/;"	m	struct:link_socket	access:public
ptos	socket.h	/^    uint8_t ptos;$/;"	m	struct:link_socket	access:public
ptos_defined	socket.h	/^    bool ptos_defined;$/;"	m	struct:link_socket	access:public
ptr_format	common.h	56;"	d
ptr_format	common.h	58;"	d
ptr_type	common.h	/^typedef unsigned long long ptr_type;$/;"	t
ptr_type	common.h	/^typedef unsigned long ptr_type;$/;"	t
pull	options.h	/^    bool pull; \/* client pull of config options from server *\/$/;"	m	struct:options	access:public
pull	ssl_common.h	/^    bool pull;$/;"	m	struct:tls_options	access:public
pull_filter	options.c	/^struct pull_filter$/;"	s	file:
pull_filter::next	options.c	/^    struct pull_filter *next;$/;"	m	struct:pull_filter	typeref:struct:pull_filter::pull_filter	file:	access:public
pull_filter::pattern	options.c	/^    char *pattern;$/;"	m	struct:pull_filter	file:	access:public
pull_filter::size	options.c	/^    int size;$/;"	m	struct:pull_filter	file:	access:public
pull_filter::type	options.c	/^    int type;$/;"	m	struct:pull_filter	file:	access:public
pull_filter_list	options.c	/^struct pull_filter_list$/;"	s	file:
pull_filter_list	options.h	/^    struct pull_filter_list *pull_filter_list;$/;"	m	struct:options	typeref:struct:options::pull_filter_list	access:public
pull_filter_list::head	options.c	/^    struct pull_filter *head;$/;"	m	struct:pull_filter_list	typeref:struct:pull_filter_list::pull_filter	file:	access:public
pull_filter_list::tail	options.c	/^    struct pull_filter *tail;$/;"	m	struct:pull_filter_list	typeref:struct:pull_filter_list::pull_filter	file:	access:public
pull_filter_type_name	options.c	/^pull_filter_type_name(int type)$/;"	f	file:	signature:(int type)
pull_permission_mask	init.c	/^pull_permission_mask(const struct context *c)$/;"	f	signature:(const struct context *c)
pull_permission_mask	init.h	/^unsigned int pull_permission_mask(const struct context *c);$/;"	p	signature:(const struct context *c)
pulled_options_digest	openvpn.h	/^    struct sha256_digest pulled_options_digest;$/;"	m	struct:context_2	typeref:struct:context_2::sha256_digest	access:public
pulled_options_digest_init_done	openvpn.h	/^    bool pulled_options_digest_init_done;$/;"	m	struct:context_2	access:public
pulled_options_digest_save	openvpn.h	/^    struct sha256_digest pulled_options_digest_save;$/;"	m	struct:context_1	typeref:struct:context_1::sha256_digest	access:public
pulled_options_state	openvpn.h	/^    md_ctx_t *pulled_options_state;$/;"	m	struct:context_2	access:public
purge_user_pass	misc.c	/^purge_user_pass(struct user_pass *up, const bool force)$/;"	f	signature:(struct user_pass *up, const bool force)
purge_user_pass	misc.h	/^void purge_user_pass(struct user_pass *up, const bool force);$/;"	p	signature:(struct user_pass *up, const bool force)
push_continuation	options.h	/^    int push_continuation;$/;"	m	struct:options	access:public
push_entry	pushlist.h	/^struct push_entry {$/;"	s
push_entry::enable	pushlist.h	/^    bool enable;$/;"	m	struct:push_entry	access:public
push_entry::next	pushlist.h	/^    struct push_entry *next;$/;"	m	struct:push_entry	typeref:struct:push_entry::push_entry	access:public
push_entry::option	pushlist.h	/^    const char *option;$/;"	m	struct:push_entry	access:public
push_ifconfig_constraint_defined	options.h	/^    bool push_ifconfig_constraint_defined;$/;"	m	struct:options	access:public
push_ifconfig_constraint_netmask	options.h	/^    in_addr_t push_ifconfig_constraint_netmask;$/;"	m	struct:options	access:public
push_ifconfig_constraint_network	options.h	/^    in_addr_t push_ifconfig_constraint_network;$/;"	m	struct:options	access:public
push_ifconfig_defined	openvpn.h	/^    bool push_ifconfig_defined;$/;"	m	struct:context_2	access:public
push_ifconfig_defined	options.h	/^    bool push_ifconfig_defined;$/;"	m	struct:options	access:public
push_ifconfig_ipv6_blocked	options.h	/^    bool push_ifconfig_ipv6_blocked;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
push_ifconfig_ipv6_defined	openvpn.h	/^    bool push_ifconfig_ipv6_defined;$/;"	m	struct:context_2	access:public
push_ifconfig_ipv6_defined	options.h	/^    bool push_ifconfig_ipv6_defined;                    \/* IPv6 *\/$/;"	m	struct:options	access:public
push_ifconfig_ipv6_local	openvpn.h	/^    struct in6_addr push_ifconfig_ipv6_local;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr	access:public
push_ifconfig_ipv6_local	options.h	/^    struct in6_addr push_ifconfig_ipv6_local;           \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
push_ifconfig_ipv6_netbits	openvpn.h	/^    int push_ifconfig_ipv6_netbits;$/;"	m	struct:context_2	access:public
push_ifconfig_ipv6_netbits	options.h	/^    int push_ifconfig_ipv6_netbits;                     \/* IPv6 *\/$/;"	m	struct:options	access:public
push_ifconfig_ipv6_remote	openvpn.h	/^    struct in6_addr push_ifconfig_ipv6_remote;$/;"	m	struct:context_2	typeref:struct:context_2::in6_addr	access:public
push_ifconfig_ipv6_remote	options.h	/^    struct in6_addr push_ifconfig_ipv6_remote;          \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
push_ifconfig_local	openvpn.h	/^    in_addr_t push_ifconfig_local;$/;"	m	struct:context_2	access:public
push_ifconfig_local	options.h	/^    in_addr_t push_ifconfig_local;$/;"	m	struct:options	access:public
push_ifconfig_local_alias	openvpn.h	/^    in_addr_t push_ifconfig_local_alias;$/;"	m	struct:context_2	access:public
push_ifconfig_local_alias	options.h	/^    in_addr_t push_ifconfig_local_alias;$/;"	m	struct:options	access:public
push_ifconfig_remote_netmask	openvpn.h	/^    in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:context_2	access:public
push_ifconfig_remote_netmask	options.h	/^    in_addr_t push_ifconfig_remote_netmask;$/;"	m	struct:options	access:public
push_list	options.h	/^    struct push_list push_list;$/;"	m	struct:options	typeref:struct:options::push_list	access:public
push_list	pushlist.h	/^struct push_list {$/;"	s
push_list::head	pushlist.h	/^    struct push_entry *head;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry	access:public
push_list::tail	pushlist.h	/^    struct push_entry *tail;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry	access:public
push_option	push.c	/^push_option(struct options *o, const char *opt, int msglevel)$/;"	f	signature:(struct options *o, const char *opt, int msglevel)
push_option	push.h	/^void push_option(struct options *o, const char *opt, int msglevel);$/;"	p	signature:(struct options *o, const char *opt, int msglevel)
push_option_ex	push.c	/^push_option_ex(struct gc_arena *gc, struct push_list *push_list,$/;"	f	file:	signature:(struct gc_arena *gc, struct push_list *push_list, const char *opt, bool enable, int msglevel)
push_option_fmt	push.c	/^push_option_fmt(struct gc_arena *gc, struct push_list *push_list,$/;"	f	file:	signature:(struct gc_arena *gc, struct push_list *push_list, int msglevel, const char *format, ...)
push_option_fmt	push.c	/^static bool push_option_fmt(struct gc_arena *gc, struct push_list *push_list,$/;"	p	file:	signature:(struct gc_arena *gc, struct push_list *push_list, int msglevel, const char *fmt, ...)
push_option_types_found	options.h	/^    unsigned int push_option_types_found;$/;"	m	struct:options	access:public
push_options	push.c	/^push_options(struct options *o, char **p, int msglevel, struct gc_arena *gc)$/;"	f	signature:(struct options *o, char **p, int msglevel, struct gc_arena *gc)
push_options	push.h	/^void push_options(struct options *o, char **p, int msglevel, struct gc_arena *gc);$/;"	p	signature:(struct options *o, char **p, int msglevel, struct gc_arena *gc)
push_peer_info	options.h	/^    bool push_peer_info;$/;"	m	struct:options	access:public
push_peer_info	ssl.c	/^push_peer_info(struct buffer *buf, struct tls_session *session)$/;"	f	file:	signature:(struct buffer *buf, struct tls_session *session)
push_peer_info_detail	ssl_common.h	/^    int push_peer_info_detail;$/;"	m	struct:tls_options	access:public
push_perf_index	perf.c	/^push_perf_index(int pindex)$/;"	f	file:	signature:(int pindex)
push_remove_option	push.c	/^push_remove_option(struct options *o, const char *p)$/;"	f	signature:(struct options *o, const char *p)
push_remove_option	push.h	/^void push_remove_option(struct options *o, const char *p);$/;"	p	signature:(struct options *o, const char *p)
push_reply_cmd	push.c	/^static char push_reply_cmd[] = "PUSH_REPLY";$/;"	v	file:
push_reply_deferred	openvpn.h	/^    bool push_reply_deferred;$/;"	m	struct:context_2	access:public
push_request_interval	openvpn.h	/^    struct event_timeout push_request_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
push_request_received	openvpn.h	/^    bool push_request_received;$/;"	m	struct:context_2	access:public
push_reset	push.c	/^push_reset(struct options *o)$/;"	f	signature:(struct options *o)
push_reset	push.h	/^void push_reset(struct options *o);$/;"	p	signature:(struct options *o)
push_update_digest	push.c	/^push_update_digest(md_ctx_t *ctx, struct buffer *buf, const struct options *opt)$/;"	f	file:	signature:(md_ctx_t *ctx, struct buffer *buf, const struct options *opt)
pw	platform.h	/^    struct passwd *pw;$/;"	m	struct:platform_state_user	typeref:struct:platform_state_user::passwd	access:public
queried_creds	proxy.h	/^    bool queried_creds;$/;"	m	struct:http_proxy_info	access:public
query_user	console.c	/^struct _query_user query_user[QUERY_USER_NUMSLOTS];  \/* GLOBAL *\/$/;"	v	typeref:struct:_query_user
query_user_SINGLE	console.h	/^query_user_SINGLE(char *prompt, size_t prompt_len,$/;"	f	signature:(char *prompt, size_t prompt_len, char *resp, size_t resp_len, bool echo)
query_user_add	console.c	/^query_user_add(char *prompt, size_t prompt_len,$/;"	f	signature:(char *prompt, size_t prompt_len, char *resp, size_t resp_len, bool echo)
query_user_add	console.h	/^void query_user_add(char *prompt, size_t prompt_len,$/;"	p	signature:(char *prompt, size_t prompt_len, char *resp, size_t resp_len, bool echo)
query_user_clear	console.c	/^query_user_clear(void)$/;"	f	signature:(void)
query_user_clear	console.h	/^void query_user_clear(void);$/;"	p	signature:(void)
query_user_exec	console.h	/^bool query_user_exec(void);$/;"	p	signature:(void)
query_user_exec	console.h	/^query_user_exec(void)$/;"	f	signature:(void)
query_user_exec	console_systemd.c	/^query_user_exec(void)$/;"	f	signature:(void)
query_user_exec_builtin	console.h	/^bool query_user_exec_builtin(void);$/;"	p	signature:(void)
query_user_exec_builtin	console_builtin.c	/^query_user_exec_builtin(void)$/;"	f	signature:(void)
rand_bytes	crypto_backend.h	/^int rand_bytes(uint8_t *output, int len);$/;"	p	signature:(uint8_t *output, int len)
rand_bytes	crypto_mbedtls.c	/^rand_bytes(uint8_t *output, int len)$/;"	f	signature:(uint8_t *output, int len)
rand_bytes	crypto_openssl.c	/^rand_bytes(uint8_t *output, int len)$/;"	f	signature:(uint8_t *output, int len)
rand_ctx_enable_prediction_resistance	crypto_mbedtls.c	/^rand_ctx_enable_prediction_resistance(void)$/;"	f	signature:(void)
rand_ctx_enable_prediction_resistance	crypto_mbedtls.h	/^void rand_ctx_enable_prediction_resistance(void);$/;"	p	signature:(void)
rand_ctx_get	crypto_mbedtls.c	/^rand_ctx_get(void)$/;"	f	signature:(void)
rand_ctx_get	crypto_mbedtls.h	/^mbedtls_ctr_drbg_context *rand_ctx_get(void);$/;"	p	signature:(void)
random	syshead.h	43;"	d
random1	ssl_common.h	/^    uint8_t random1[32];        \/**< Seed used for master secret$/;"	m	struct:key_source	access:public
random2	ssl_common.h	/^    uint8_t random2[32];        \/**< Seed used for key expansion, provided$/;"	m	struct:key_source	access:public
random_bytes_to_buf	ssl.c	/^random_bytes_to_buf(struct buffer *buf,$/;"	f	file:	signature:(struct buffer *buf, uint8_t *out, int outlen)
raw_addr	mroute.h	/^        uint8_t raw_addr[MR_MAX_ADDR_LEN]; \/* actual address *\/$/;"	m	union:mroute_addr::__anon4	access:public
raw_addr	mroute.h	102;"	d
rcvbuf	options.h	/^    int rcvbuf;$/;"	m	struct:options	access:public
rcvbuf	socket.h	/^    int rcvbuf;$/;"	m	struct:socket_buffer_size	access:public
read	win32.h	/^    HANDLE read;$/;"	m	struct:rw_handle	access:public
read_buf	status.h	/^    struct buffer read_buf;$/;"	m	struct:status_output	typeref:struct:status_output::buffer	access:public
read_config_file	options.c	/^read_config_file(struct options *options,$/;"	f	file:	signature:(struct options *options, const char *file, int level, const char *top_file, const int top_line, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
read_config_string	options.c	/^read_config_string(const char *prefix,$/;"	f	file:	signature:(const char *prefix, struct options *options, const char *config, const int msglevel, const unsigned int permission_mask, unsigned int *option_types_found, struct env_set *es)
read_control_auth	ssl.c	/^read_control_auth(struct buffer *buf,$/;"	f	file:	signature:(struct buffer *buf, struct tls_wrap_ctx *ctx, const struct link_socket_actual *from)
read_incoming_link	forward.c	/^read_incoming_link(struct context *c)$/;"	f	signature:(struct context *c)
read_incoming_link	forward.h	/^void read_incoming_link(struct context *c);$/;"	p	signature:(struct context *c)
read_incoming_tun	forward.c	/^read_incoming_tun(struct context *c)$/;"	f	signature:(struct context *c)
read_incoming_tun	forward.h	/^void read_incoming_tun(struct context *c);$/;"	p	signature:(struct context *c)
read_inline_file	options.c	/^read_inline_file(struct in_src *is, const char *close_tag, struct gc_arena *gc)$/;"	f	file:	signature:(struct in_src *is, const char *close_tag, struct gc_arena *gc)
read_key	crypto.c	/^read_key(struct key *key, const struct key_type *kt, struct buffer *buf)$/;"	f	signature:(struct key *key, const struct key_type *kt, struct buffer *buf)
read_key	crypto.h	/^int read_key(struct key *key, const struct key_type *kt, struct buffer *buf);$/;"	p	signature:(struct key *key, const struct key_type *kt, struct buffer *buf)
read_key_file	crypto.c	/^read_key_file(struct key2 *key2, const char *file, const unsigned int flags)$/;"	f	signature:(struct key2 *key2, const char *file, const unsigned int flags)
read_key_file	crypto.h	/^void read_key_file(struct key2 *key2, const char *file, const unsigned int flags);$/;"	p	signature:(struct key2 *key2, const char *file, const unsigned int flags)
read_link_buf	openvpn.h	/^    struct buffer read_link_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
read_passphrase_hash	crypto.h	/^int read_passphrase_hash(const char *passphrase_file,$/;"	p	signature:(const char *passphrase_file, const md_kt_t *digest, uint8_t *output, int len)
read_string	ssl.c	/^read_string(struct buffer *buf, char *str, const unsigned int capacity)$/;"	f	file:	signature:(struct buffer *buf, char *str, const unsigned int capacity)
read_string_alloc	ssl.c	/^read_string_alloc(struct buffer *buf)$/;"	f	file:	signature:(struct buffer *buf)
read_tun	tun.c	/^read_tun(struct tuntap *tt, uint8_t *buf, int len)$/;"	f	signature:(struct tuntap *tt, uint8_t *buf, int len)
read_tun	tun.h	/^int read_tun(struct tuntap *tt, uint8_t *buf, int len);$/;"	p	signature:(struct tuntap *tt, uint8_t *buf, int len)
read_tun_buf	openvpn.h	/^    struct buffer read_tun_buf;$/;"	m	struct:context_buffers	typeref:struct:context_buffers::buffer	access:public
read_tun_buffered	tun.h	/^read_tun_buffered(struct tuntap *tt, struct buffer *buf, int maxsize)$/;"	f	signature:(struct tuntap *tt, struct buffer *buf, int maxsize)
read_tun_header	tun.c	/^read_tun_header(struct tuntap *tt, uint8_t *buf, int len)$/;"	f	signature:(struct tuntap *tt, uint8_t *buf, int len)
readfds	event.c	/^    fd_set readfds;$/;"	m	struct:se_set	file:	access:public
reads	socket.h	/^    struct overlapped_io reads;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io	access:public
reads	tun.h	/^    struct overlapped_io reads;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io	access:public
real	multi.h	/^    struct mroute_addr real;    \/**< External network address of the$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mroute_addr	access:public
real_hash_size	options.h	/^    int real_hash_size;$/;"	m	struct:options	access:public
reap_buckets_per_pass	multi.c	/^reap_buckets_per_pass(int n_buckets)$/;"	f	file:	signature:(int n_buckets)
reaper	multi.h	/^    struct multi_reap *reaper;$/;"	m	struct:multi_context	typeref:struct:multi_context::multi_reap	access:public
rec	packet_id.h	/^    struct packet_id_rec rec;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_rec	access:public
rec_ack	ssl_common.h	/^    struct reliable_ack *rec_ack; \/* buffers all packet IDs we want to ACK back to sender *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable_ack	access:public
rec_reliable	ssl_common.h	/^    struct reliable *rec_reliable; \/* order incoming ciphertext packets before we pass to TLS *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable	access:public
receive_auth_failed	push.c	/^receive_auth_failed(struct context *c, const struct buffer *buffer)$/;"	f	signature:(struct context *c, const struct buffer *buffer)
receive_auth_failed	push.h	/^void receive_auth_failed(struct context *c, const struct buffer *buffer);$/;"	p	signature:(struct context *c, const struct buffer *buffer)
received_os_mtu_hint	fragment.h	/^    bool received_os_mtu_hint;  \/**< Whether the operating system has$/;"	m	struct:fragment_master	access:public
recv_control	ps.c	/^recv_control(const socket_descriptor_t fd)$/;"	f	file:	signature:(const socket_descriptor_t fd)
recv_line	proxy.c	/^recv_line(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, char *buf, int len, const int timeout_sec, const bool verbose, struct buffer *lookahead, volatile int *signal_received)
recv_socks_reply	socks.c	/^recv_socks_reply(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, struct openvpn_sockaddr *addr, volatile int *signal_received)
redirect_default_route_to_vpn	route.c	/^redirect_default_route_to_vpn(struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	file:	signature:(struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
redirect_stdout_stderr	error.c	/^redirect_stdout_stderr(const char *file, bool append)$/;"	f	signature:(const char *file, bool append)
redirect_stdout_stderr	error.h	/^void redirect_stdout_stderr(const char *file, bool append);$/;"	p	signature:(const char *file, bool append)
refcount	mbuf.h	/^    int refcount;$/;"	m	struct:mbuf_buffer	access:public
refcount	multi.h	/^    int refcount;$/;"	m	struct:multi_instance	access:public
refresh	interval.h	/^    interval_t refresh;$/;"	m	struct:interval	access:public
register_activity	forward-inline.h	/^register_activity(struct context *c, const int size)$/;"	f	signature:(struct context *c, const int size)
register_dns	tun.h	/^    bool register_dns;$/;"	m	struct:tuntap_options	access:public
register_dns_service	tun.c	/^register_dns_service(const struct tuntap *tt)$/;"	f	file:	signature:(const struct tuntap *tt)
register_signal	sig.c	/^register_signal(struct context *c, int sig, const char *text)$/;"	f	signature:(struct context *c, int sig, const char *text)
register_signal	sig.h	/^void register_signal(struct context *c, int sig, const char *text);$/;"	p	signature:(struct context *c, int sig, const char *text)
reliable	reliable.h	/^struct reliable$/;"	s
reliable::array	reliable.h	/^    struct reliable_entry array[RELIABLE_CAPACITY];$/;"	m	struct:reliable	typeref:struct:reliable::reliable_entry	access:public
reliable::hold	reliable.h	/^    bool hold; \/* don't xmit until reliable_schedule_now is called *\/$/;"	m	struct:reliable	access:public
reliable::initial_timeout	reliable.h	/^    interval_t initial_timeout;$/;"	m	struct:reliable	access:public
reliable::offset	reliable.h	/^    int offset;$/;"	m	struct:reliable	access:public
reliable::packet_id	reliable.h	/^    packet_id_type packet_id;$/;"	m	struct:reliable	access:public
reliable::size	reliable.h	/^    int size;$/;"	m	struct:reliable	access:public
reliable_ack	reliable.h	/^struct reliable_ack$/;"	s
reliable_ack::len	reliable.h	/^    int len;$/;"	m	struct:reliable_ack	access:public
reliable_ack::packet_id	reliable.h	/^    packet_id_type packet_id[RELIABLE_ACK_SIZE];$/;"	m	struct:reliable_ack	access:public
reliable_ack_acknowledge_packet_id	reliable.c	/^reliable_ack_acknowledge_packet_id(struct reliable_ack *ack, packet_id_type pid)$/;"	f	signature:(struct reliable_ack *ack, packet_id_type pid)
reliable_ack_acknowledge_packet_id	reliable.h	/^bool reliable_ack_acknowledge_packet_id(struct reliable_ack *ack, packet_id_type pid);$/;"	p	signature:(struct reliable_ack *ack, packet_id_type pid)
reliable_ack_adjust_frame_parameters	reliable.c	/^reliable_ack_adjust_frame_parameters(struct frame *frame, int max)$/;"	f	signature:(struct frame *frame, int max)
reliable_ack_adjust_frame_parameters	reliable.h	/^void reliable_ack_adjust_frame_parameters(struct frame *frame, int max);$/;"	p	signature:(struct frame *frame, int max)
reliable_ack_debug_print	reliable.h	/^void reliable_ack_debug_print(const struct reliable_ack *ack, char *desc);$/;"	p	signature:(const struct reliable_ack *ack, char *desc)
reliable_ack_empty	reliable.h	/^reliable_ack_empty(struct reliable_ack *ack)$/;"	f	signature:(struct reliable_ack *ack)
reliable_ack_packet_id_present	reliable.c	/^reliable_ack_packet_id_present(struct reliable_ack *ack, packet_id_type pid)$/;"	f	file:	signature:(struct reliable_ack *ack, packet_id_type pid)
reliable_ack_print	reliable.c	/^reliable_ack_print(struct buffer *buf, bool verbose, struct gc_arena *gc)$/;"	f	signature:(struct buffer *buf, bool verbose, struct gc_arena *gc)
reliable_ack_print	reliable.h	/^const char *reliable_ack_print(struct buffer *buf, bool verbose, struct gc_arena *gc);$/;"	p	signature:(struct buffer *buf, bool verbose, struct gc_arena *gc)
reliable_ack_read	reliable.c	/^reliable_ack_read(struct reliable_ack *ack,$/;"	f	signature:(struct reliable_ack *ack, struct buffer *buf, const struct session_id *sid)
reliable_ack_read	reliable.h	/^bool reliable_ack_read(struct reliable_ack *ack,$/;"	p	signature:(struct reliable_ack *ack, struct buffer *buf, const struct session_id *sid)
reliable_ack_read_packet_id	reliable.c	/^reliable_ack_read_packet_id(struct buffer *buf, packet_id_type *pid)$/;"	f	signature:(struct buffer *buf, packet_id_type *pid)
reliable_ack_read_packet_id	reliable.h	/^bool reliable_ack_read_packet_id(struct buffer *buf, packet_id_type *pid);$/;"	p	signature:(struct buffer *buf, packet_id_type *pid)
reliable_ack_write	reliable.c	/^reliable_ack_write(struct reliable_ack *ack,$/;"	f	signature:(struct reliable_ack *ack, struct buffer *buf, const struct session_id *sid, int max, bool prepend)
reliable_ack_write	reliable.h	/^bool reliable_ack_write(struct reliable_ack *ack,$/;"	p	signature:(struct reliable_ack *ack, struct buffer *buf, const struct session_id *sid, int max, bool prepend)
reliable_can_get	reliable.c	/^reliable_can_get(const struct reliable *rel)$/;"	f	signature:(const struct reliable *rel)
reliable_can_get	reliable.h	/^bool reliable_can_get(const struct reliable *rel);$/;"	p	signature:(const struct reliable *rel)
reliable_can_send	reliable.c	/^reliable_can_send(const struct reliable *rel)$/;"	f	signature:(const struct reliable *rel)
reliable_can_send	reliable.h	/^bool reliable_can_send(const struct reliable *rel);$/;"	p	signature:(const struct reliable *rel)
reliable_debug_print	reliable.h	/^void reliable_debug_print(const struct reliable *rel, char *desc);$/;"	p	signature:(const struct reliable *rel, char *desc)
reliable_empty	reliable.c	/^reliable_empty(const struct reliable *rel)$/;"	f	signature:(const struct reliable *rel)
reliable_empty	reliable.h	/^bool reliable_empty(const struct reliable *rel);$/;"	p	signature:(const struct reliable *rel)
reliable_entry	reliable.h	/^struct reliable_entry$/;"	s
reliable_entry::active	reliable.h	/^    bool active;$/;"	m	struct:reliable_entry	access:public
reliable_entry::buf	reliable.h	/^    struct buffer buf;$/;"	m	struct:reliable_entry	typeref:struct:reliable_entry::buffer	access:public
reliable_entry::next_try	reliable.h	/^    time_t next_try;$/;"	m	struct:reliable_entry	access:public
reliable_entry::opcode	reliable.h	/^    int opcode;$/;"	m	struct:reliable_entry	access:public
reliable_entry::packet_id	reliable.h	/^    packet_id_type packet_id;$/;"	m	struct:reliable_entry	access:public
reliable_entry::timeout	reliable.h	/^    interval_t timeout;$/;"	m	struct:reliable_entry	access:public
reliable_free	reliable.c	/^reliable_free(struct reliable *rel)$/;"	f	signature:(struct reliable *rel)
reliable_free	reliable.h	/^void reliable_free(struct reliable *rel);$/;"	p	signature:(struct reliable *rel)
reliable_get_buf	reliable.c	/^reliable_get_buf(struct reliable *rel)$/;"	f	signature:(struct reliable *rel)
reliable_get_buf	reliable.h	/^struct buffer *reliable_get_buf(struct reliable *rel);$/;"	p	signature:(struct reliable *rel)
reliable_get_buf_output_sequenced	reliable.c	/^reliable_get_buf_output_sequenced(struct reliable *rel)$/;"	f	signature:(struct reliable *rel)
reliable_get_buf_output_sequenced	reliable.h	/^struct buffer *reliable_get_buf_output_sequenced(struct reliable *rel);$/;"	p	signature:(struct reliable *rel)
reliable_get_buf_sequenced	reliable.c	/^reliable_get_buf_sequenced(struct reliable *rel)$/;"	f	signature:(struct reliable *rel)
reliable_get_buf_sequenced	reliable.h	/^struct buffer *reliable_get_buf_sequenced(struct reliable *rel);$/;"	p	signature:(struct reliable *rel)
reliable_init	reliable.c	/^reliable_init(struct reliable *rel, int buf_size, int offset, int array_size, bool hold)$/;"	f	signature:(struct reliable *rel, int buf_size, int offset, int array_size, bool hold)
reliable_init	reliable.h	/^void reliable_init(struct reliable *rel, int buf_size, int offset, int array_size, bool hold);$/;"	p	signature:(struct reliable *rel, int buf_size, int offset, int array_size, bool hold)
reliable_mark_active_incoming	reliable.c	/^reliable_mark_active_incoming(struct reliable *rel, struct buffer *buf,$/;"	f	signature:(struct reliable *rel, struct buffer *buf, packet_id_type pid, int opcode)
reliable_mark_active_incoming	reliable.h	/^void reliable_mark_active_incoming(struct reliable *rel, struct buffer *buf,$/;"	p	signature:(struct reliable *rel, struct buffer *buf, packet_id_type pid, int opcode)
reliable_mark_active_outgoing	reliable.c	/^reliable_mark_active_outgoing(struct reliable *rel, struct buffer *buf, int opcode)$/;"	f	signature:(struct reliable *rel, struct buffer *buf, int opcode)
reliable_mark_active_outgoing	reliable.h	/^void reliable_mark_active_outgoing(struct reliable *rel, struct buffer *buf, int opcode);$/;"	p	signature:(struct reliable *rel, struct buffer *buf, int opcode)
reliable_mark_deleted	reliable.c	/^reliable_mark_deleted(struct reliable *rel, struct buffer *buf, bool inc_pid)$/;"	f	signature:(struct reliable *rel, struct buffer *buf, bool inc_pid)
reliable_mark_deleted	reliable.h	/^void reliable_mark_deleted(struct reliable *rel, struct buffer *buf, bool inc_pid);$/;"	p	signature:(struct reliable *rel, struct buffer *buf, bool inc_pid)
reliable_not_replay	reliable.c	/^reliable_not_replay(const struct reliable *rel, packet_id_type id)$/;"	f	signature:(const struct reliable *rel, packet_id_type id)
reliable_not_replay	reliable.h	/^bool reliable_not_replay(const struct reliable *rel, packet_id_type id);$/;"	p	signature:(const struct reliable *rel, packet_id_type id)
reliable_pid_in_range1	reliable.c	/^reliable_pid_in_range1(const packet_id_type test,$/;"	f	file:	signature:(const packet_id_type test, const packet_id_type base, const unsigned int extent)
reliable_pid_in_range2	reliable.c	/^reliable_pid_in_range2(const packet_id_type test,$/;"	f	file:	signature:(const packet_id_type test, const packet_id_type base, const unsigned int extent)
reliable_pid_min	reliable.c	/^reliable_pid_min(const packet_id_type p1,$/;"	f	file:	signature:(const packet_id_type p1, const packet_id_type p2)
reliable_print_ids	reliable.c	/^reliable_print_ids(const struct reliable *rel, struct gc_arena *gc)$/;"	f	file:	signature:(const struct reliable *rel, struct gc_arena *gc)
reliable_schedule_now	reliable.c	/^reliable_schedule_now(struct reliable *rel)$/;"	f	signature:(struct reliable *rel)
reliable_schedule_now	reliable.h	/^void reliable_schedule_now(struct reliable *rel);$/;"	p	signature:(struct reliable *rel)
reliable_send	reliable.c	/^reliable_send(struct reliable *rel, int *opcode)$/;"	f	signature:(struct reliable *rel, int *opcode)
reliable_send	reliable.h	/^struct buffer *reliable_send(struct reliable *rel, int *opcode);$/;"	p	signature:(struct reliable *rel, int *opcode)
reliable_send_purge	reliable.c	/^reliable_send_purge(struct reliable *rel, struct reliable_ack *ack)$/;"	f	signature:(struct reliable *rel, struct reliable_ack *ack)
reliable_send_purge	reliable.h	/^void reliable_send_purge(struct reliable *rel, struct reliable_ack *ack);$/;"	p	signature:(struct reliable *rel, struct reliable_ack *ack)
reliable_send_timeout	reliable.c	/^reliable_send_timeout(const struct reliable *rel)$/;"	f	signature:(const struct reliable *rel)
reliable_send_timeout	reliable.h	/^interval_t reliable_send_timeout(const struct reliable *rel);$/;"	p	signature:(const struct reliable *rel)
reliable_set_timeout	reliable.h	/^reliable_set_timeout(struct reliable *rel, interval_t timeout)$/;"	f	signature:(struct reliable *rel, interval_t timeout)
reliable_unique_retry	reliable.c	/^reliable_unique_retry(struct reliable *rel, time_t retry)$/;"	f	file:	signature:(struct reliable *rel, time_t retry)
reliable_wont_break_sequentiality	reliable.c	/^reliable_wont_break_sequentiality(const struct reliable *rel, packet_id_type id)$/;"	f	signature:(const struct reliable *rel, packet_id_type id)
reliable_wont_break_sequentiality	reliable.h	/^bool reliable_wont_break_sequentiality(const struct reliable *rel, packet_id_type id);$/;"	p	signature:(const struct reliable *rel, packet_id_type id)
reload	pf.h	/^    struct event_timeout reload;$/;"	m	struct:pf_context	typeref:struct:pf_context::event_timeout	access:public
remap_redirect_gateway_flags	options.c	/^remap_redirect_gateway_flags(struct options *opt)$/;"	f	file:	signature:(struct options *opt)
remap_signal	sig.c	/^remap_signal(struct context *c)$/;"	f	signature:(struct context *c)
remap_signal	sig.h	/^void remap_signal(struct context *c);$/;"	p	signature:(struct context *c)
remap_sigusr1	options.h	/^    int remap_sigusr1;$/;"	m	struct:options	access:public
remote	manage.h	/^    struct openvpn_sockaddr remote;$/;"	m	struct:man_connection	typeref:struct:man_connection::openvpn_sockaddr	access:public
remote	options.h	/^    const char *remote;$/;"	m	struct:connection_entry	access:public
remote	options.h	/^    const char *remote;$/;"	m	struct:remote_entry	access:public
remote_addr	ssl_common.h	/^    struct link_socket_actual remote_addr; \/* peer's IP addr *\/$/;"	m	struct:key_state	typeref:struct:key_state::link_socket_actual	access:public
remote_cert_eku	options.h	/^    const char *remote_cert_eku;$/;"	m	struct:options	access:public
remote_cert_eku	ssl_common.h	/^    const char *remote_cert_eku;$/;"	m	struct:tls_options	access:public
remote_cert_ku	options.h	/^    unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:options	access:public
remote_cert_ku	ssl_common.h	/^    unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:tls_options	access:public
remote_ciphername	ssl_common.h	/^    char *remote_ciphername;    \/**< cipher specified in peer's config file *\/$/;"	m	struct:tls_multi	access:public
remote_cmd	manage.h	/^    bool (*remote_cmd) (void *arg, const char **p);$/;"	m	struct:management_callback	access:public
remote_endpoint	route.h	/^    in_addr_t remote_endpoint;$/;"	m	struct:route_special_addr	access:public
remote_endpoint_ipv6	route.h	/^    struct in6_addr remote_endpoint_ipv6; \/* inside tun *\/$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::in6_addr	access:public
remote_entry	options.h	/^struct remote_entry$/;"	s
remote_entry::af	options.h	/^    sa_family_t af;$/;"	m	struct:remote_entry	access:public
remote_entry::proto	options.h	/^    int proto;$/;"	m	struct:remote_entry	access:public
remote_entry::remote	options.h	/^    const char *remote;$/;"	m	struct:remote_entry	access:public
remote_entry::remote_port	options.h	/^    const char *remote_port;$/;"	m	struct:remote_entry	access:public
remote_float	options.h	/^    bool remote_float;$/;"	m	struct:connection_entry	access:public
remote_float	socket.h	/^    bool remote_float;$/;"	m	struct:link_socket_info	access:public
remote_host	route.h	/^    in_addr_t remote_host;$/;"	m	struct:route_special_addr	access:public
remote_host	socket.h	/^    const char *remote_host;$/;"	m	struct:link_socket	access:public
remote_host_ipv6	route.h	/^    struct in6_addr remote_host_ipv6;   \/* --remote address *\/$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::in6_addr	access:public
remote_host_local	route.h	/^    int remote_host_local; \/* TLA_x value *\/$/;"	m	struct:route_special_addr	access:public
remote_host_store	options.h	/^struct remote_host_store$/;"	s
remote_host_store::host	options.h	/^    char host[RH_HOST_LEN];$/;"	m	struct:remote_host_store	access:public
remote_host_store::port	options.h	/^    char port[RH_PORT_LEN];$/;"	m	struct:remote_host_store	access:public
remote_ipv6	tun.h	/^    struct in6_addr remote_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr	access:public
remote_list	options.h	/^    struct remote_list *remote_list;$/;"	m	struct:options	typeref:struct:options::remote_list	access:public
remote_list	options.h	/^struct remote_list$/;"	s
remote_list	socket.h	/^    struct addrinfo *remote_list; \/* complete remote list *\/$/;"	m	struct:link_socket_addr	typeref:struct:link_socket_addr::addrinfo	access:public
remote_list::array	options.h	/^    struct remote_entry *array[CONNECTION_LIST_SIZE];$/;"	m	struct:remote_list	typeref:struct:remote_list::remote_entry	access:public
remote_list::len	options.h	/^    int len;$/;"	m	struct:remote_list	access:public
remote_netmask	tun.h	/^    in_addr_t remote_netmask;$/;"	m	struct:tuntap	access:public
remote_options	ssl_common.h	/^    const char *remote_options;$/;"	m	struct:tls_options	access:public
remote_port	options.h	/^    const char *remote_port;$/;"	m	struct:connection_entry	access:public
remote_port	options.h	/^    const char *remote_port;$/;"	m	struct:remote_entry	access:public
remote_port	socket.h	/^    const char *remote_port;$/;"	m	struct:link_socket	access:public
remote_random	options.h	/^    bool remote_random;$/;"	m	struct:options	access:public
remote_sock	manage.h	/^    struct openvpn_sockaddr remote_sock;$/;"	m	struct:log_entry	typeref:struct:log_entry::openvpn_sockaddr	access:public
remove_env_item	misc.c	/^remove_env_item(const char *str, const bool do_free, struct env_item **list)$/;"	f	file:	signature:(const char *str, const bool do_free, struct env_item **list)
remove_iroutes_from_push_route_list	push.c	/^remove_iroutes_from_push_route_list(struct options *o)$/;"	f	signature:(struct options *o)
remove_iroutes_from_push_route_list	push.h	/^void remove_iroutes_from_push_route_list(struct options *o);$/;"	p	signature:(struct options *o)
renegotiate_bytes	options.h	/^    int renegotiate_bytes;$/;"	m	struct:options	access:public
renegotiate_bytes	ssl_common.h	/^    int renegotiate_bytes;$/;"	m	struct:tls_options	access:public
renegotiate_packets	options.h	/^    int renegotiate_packets;$/;"	m	struct:options	access:public
renegotiate_packets	ssl_common.h	/^    int renegotiate_packets;$/;"	m	struct:tls_options	access:public
renegotiate_seconds	options.h	/^    int renegotiate_seconds;$/;"	m	struct:options	access:public
renegotiate_seconds	ssl_common.h	/^    interval_t renegotiate_seconds;$/;"	m	struct:tls_options	access:public
replay	options.h	/^    bool replay;$/;"	m	struct:options	access:public
replay	ssl_common.h	/^    bool replay;$/;"	m	struct:tls_options	access:public
replay_time	options.h	/^    int replay_time;$/;"	m	struct:options	access:public
replay_time	ssl_common.h	/^    int replay_time;                   \/* --replay-window parm *\/$/;"	m	struct:tls_options	access:public
replay_window	options.h	/^    int replay_window;$/;"	m	struct:options	access:public
replay_window	ssl_common.h	/^    int replay_window;                 \/* --replay-window parm *\/$/;"	m	struct:tls_options	access:public
reporting_addr	multi.h	/^    in_addr_t reporting_addr;     \/* IP address shown in status listing *\/$/;"	m	struct:multi_instance	access:public
reporting_addr_ipv6	multi.h	/^    struct in6_addr reporting_addr_ipv6; \/* IPv6 address in status listing *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::in6_addr	access:public
requested_initialization_point	plugin.h	/^    int requested_initialization_point;$/;"	m	struct:plugin	access:public
reset	event.h	/^    void (*reset)(struct event_set *es);$/;"	m	struct:event_set_functions	access:public
reset	otime.h	/^    time_t reset;$/;"	m	struct:frequency_limit	access:public
reset_check_status	error.c	/^reset_check_status(void)$/;"	f	signature:(void)
reset_check_status	error.h	/^void reset_check_status(void);$/;"	p	signature:(void)
reset_coarse_timers	init.c	/^reset_coarse_timers(struct context *c)$/;"	f	signature:(struct context *c)
reset_coarse_timers	init.h	/^void reset_coarse_timers(struct context *c);$/;"	p	signature:(struct context *c)
reset_net_event_win32	win32.c	/^reset_net_event_win32(struct rw_handle *event, socket_descriptor_t sd)$/;"	f	signature:(struct rw_handle *event, socket_descriptor_t sd)
reset_net_event_win32	win32.h	/^long reset_net_event_win32(struct rw_handle *event, socket_descriptor_t sd);$/;"	p	signature:(struct rw_handle *event, socket_descriptor_t sd)
reset_session	ssl.c	/^reset_session(struct tls_multi *multi, struct tls_session *session)$/;"	f	file:	signature:(struct tls_multi *multi, struct tls_session *session)
residual	manage.h	/^    struct buffer residual;$/;"	m	struct:command_line	typeref:struct:command_line::buffer	access:public
residual	socket.h	/^    struct buffer residual;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
residual_fully_formed	socket.h	/^    bool residual_fully_formed;$/;"	m	struct:stream_buf	access:public
resolve_bind_local	socket.c	/^resolve_bind_local(struct link_socket *sock, const sa_family_t af)$/;"	f	file:	signature:(struct link_socket *sock, const sa_family_t af)
resolve_in_advance	options.h	/^    bool resolve_in_advance;$/;"	m	struct:options	access:public
resolve_remote	socket.c	/^resolve_remote(struct link_socket *sock,$/;"	f	file:	signature:(struct link_socket *sock, int phase, const char **remote_dynamic, volatile int *signal_received)
resolve_retry_seconds	options.h	/^    int resolve_retry_seconds;  \/* If hostname resolve fails, retry for n seconds *\/$/;"	m	struct:options	access:public
resolve_retry_seconds	socket.h	/^    int resolve_retry_seconds;$/;"	m	struct:link_socket	access:public
response	console.h	/^    char *response;           \/**< The user's response *\/$/;"	m	struct:_query_user	access:public
response_len	console.h	/^    size_t response_len;      \/**< Lenght the of the user reposone *\/$/;"	m	struct:_query_user	access:public
restart_sleep_seconds	openvpn.h	/^    int restart_sleep_seconds;$/;"	m	struct:context_persist	access:public
restore_ncp_options	init.c	/^restore_ncp_options(struct context *c)$/;"	f	file:	signature:(struct context *c)
restore_signal_state	sig.c	/^restore_signal_state(void)$/;"	f	signature:(void)
restore_signal_state	sig.h	/^void restore_signal_state(void);$/;"	p	signature:(void)
result_t	ssl_verify_backend.h	/^typedef enum { SUCCESS = 0, FAILURE = 1 } result_t;$/;"	t	typeref:enum:__anon9
ret	mtcp.c	/^    unsigned int ret;$/;"	m	struct:ta_iow_flags	file:	access:public
rgi	route.h	/^    struct route_gateway_info rgi;$/;"	m	struct:route_list	typeref:struct:route_list::route_gateway_info	access:public
rgi6	route.h	/^    struct route_ipv6_gateway_info rgi6;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::route_ipv6_gateway_info	access:public
rh_store	options.h	/^    struct remote_host_store *rh_store;$/;"	m	struct:options	typeref:struct:options::remote_host_store	access:public
rm_trailing_chars	buffer.c	/^rm_trailing_chars(char *str, const char *what_to_delete)$/;"	f	signature:(char *str, const char *what_to_delete)
rm_trailing_chars	buffer.h	/^void rm_trailing_chars(char *str, const char *what_to_delete);$/;"	p	signature:(char *str, const char *what_to_delete)
rmhash	list.c	/^rmhash(struct hash *hash, const char *word)$/;"	f	file:	signature:(struct hash *hash, const char *word)
rol6_check_alloc	options.c	/^rol6_check_alloc(struct options *options)$/;"	f	file:	signature:(struct options *options)
rol_check_alloc	options.c	/^rol_check_alloc(struct options *options)$/;"	f	signature:(struct options *options)
rol_check_alloc	options.h	/^void rol_check_alloc(struct options *options);$/;"	p	signature:(struct options *options)
roll	gremlin.c	/^roll(int low, int high)$/;"	f	file:	signature:(int low, int high)
root	schedule.h	/^    struct schedule_entry *root;          \/* the root of the treap (btree) *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry	access:public
route_bypass	route.h	/^struct route_bypass$/;"	s
route_bypass::bypass	route.h	/^    in_addr_t bypass[N_ROUTE_BYPASS];$/;"	m	struct:route_bypass	access:public
route_bypass::n_bypass	route.h	/^    int n_bypass;$/;"	m	struct:route_bypass	access:public
route_count	multi.h	/^    int route_count;           \/* number of routes (including cached routes) owned by this instance *\/$/;"	m	struct:multi_instance	access:public
route_default_gateway	options.h	/^    const char *route_default_gateway;$/;"	m	struct:options	access:public
route_default_metric	options.h	/^    int route_default_metric;$/;"	m	struct:options	access:public
route_delay	options.h	/^    int route_delay;$/;"	m	struct:options	access:public
route_delay_defined	options.h	/^    bool route_delay_defined;$/;"	m	struct:options	access:public
route_delay_window	options.h	/^    int route_delay_window;$/;"	m	struct:options	access:public
route_did_redirect_default_gateway	route.h	/^route_did_redirect_default_gateway(const struct route_list *rl)$/;"	f	signature:(const struct route_list *rl)
route_gateway_address	route.h	/^struct route_gateway_address {$/;"	s
route_gateway_address::addr	route.h	/^    in_addr_t addr;$/;"	m	struct:route_gateway_address	access:public
route_gateway_address::netmask	route.h	/^    in_addr_t netmask;$/;"	m	struct:route_gateway_address	access:public
route_gateway_info	route.h	/^struct route_gateway_info {$/;"	s
route_gateway_info::adapter_index	route.h	/^    DWORD adapter_index; \/* interface or ~0 if undefined *\/$/;"	m	struct:route_gateway_info	access:public
route_gateway_info::addrs	route.h	/^    struct route_gateway_address addrs[RGI_N_ADDRESSES]; \/* local addresses attached to iface *\/$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address	access:public
route_gateway_info::flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_gateway_info	access:public
route_gateway_info::gateway	route.h	/^    struct route_gateway_address gateway;$/;"	m	struct:route_gateway_info	typeref:struct:route_gateway_info::route_gateway_address	access:public
route_gateway_info::hwaddr	route.h	/^    uint8_t hwaddr[6];$/;"	m	struct:route_gateway_info	access:public
route_gateway_info::iface	route.h	/^    char iface[16]; \/* interface name (null terminated), may be empty *\/$/;"	m	struct:route_gateway_info	access:public
route_gateway_info::n_addrs	route.h	/^    int n_addrs; \/* len of addrs, may be 0 *\/$/;"	m	struct:route_gateway_info	access:public
route_gateway_via_dhcp	options.h	/^    bool route_gateway_via_dhcp;$/;"	m	struct:options	access:public
route_helper	multi.h	/^    struct mroute_helper *route_helper;$/;"	m	struct:multi_context	typeref:struct:multi_context::mroute_helper	access:public
route_ipv4	route.h	/^struct route_ipv4 {$/;"	s
route_ipv4::flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_ipv4	access:public
route_ipv4::gateway	route.h	/^    in_addr_t gateway;$/;"	m	struct:route_ipv4	access:public
route_ipv4::metric	route.h	/^    int metric;$/;"	m	struct:route_ipv4	access:public
route_ipv4::netmask	route.h	/^    in_addr_t netmask;$/;"	m	struct:route_ipv4	access:public
route_ipv4::network	route.h	/^    in_addr_t network;$/;"	m	struct:route_ipv4	access:public
route_ipv4::next	route.h	/^    struct route_ipv4 *next;$/;"	m	struct:route_ipv4	typeref:struct:route_ipv4::route_ipv4	access:public
route_ipv4::option	route.h	/^    const struct route_option *option;$/;"	m	struct:route_ipv4	typeref:struct:route_ipv4::route_option	access:public
route_ipv6	route.h	/^struct route_ipv6 {$/;"	s
route_ipv6::adapter_index	route.h	/^    DWORD adapter_index;        \/* interface or ~0 if undefined *\/$/;"	m	struct:route_ipv6	access:public
route_ipv6::flags	route.h	/^    unsigned int flags;                         \/* RT_ flags, see route_ipv4 *\/$/;"	m	struct:route_ipv6	access:public
route_ipv6::gateway	route.h	/^    struct in6_addr gateway;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr	access:public
route_ipv6::iface	route.h	/^    char *iface;                \/* interface name (null terminated) *\/$/;"	m	struct:route_ipv6	access:public
route_ipv6::metric	route.h	/^    int metric;$/;"	m	struct:route_ipv6	access:public
route_ipv6::netbits	route.h	/^    unsigned int netbits;$/;"	m	struct:route_ipv6	access:public
route_ipv6::network	route.h	/^    struct in6_addr network;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::in6_addr	access:public
route_ipv6::next	route.h	/^    struct route_ipv6 *next;$/;"	m	struct:route_ipv6	typeref:struct:route_ipv6::route_ipv6	access:public
route_ipv6_clear_host_bits	route.c	/^route_ipv6_clear_host_bits( struct route_ipv6 *r6 )$/;"	f	signature:( struct route_ipv6 *r6 )
route_ipv6_clear_host_bits	route.h	/^void route_ipv6_clear_host_bits( struct route_ipv6 *r6 );$/;"	p	signature:( struct route_ipv6 *r6 )
route_ipv6_gateway_address	route.h	/^struct route_ipv6_gateway_address {$/;"	s
route_ipv6_gateway_address::addr_ipv6	route.h	/^    struct in6_addr addr_ipv6;$/;"	m	struct:route_ipv6_gateway_address	typeref:struct:route_ipv6_gateway_address::in6_addr	access:public
route_ipv6_gateway_address::netbits_ipv6	route.h	/^    int netbits_ipv6;$/;"	m	struct:route_ipv6_gateway_address	access:public
route_ipv6_gateway_info	route.h	/^struct route_ipv6_gateway_info {$/;"	s
route_ipv6_gateway_info::adapter_index	route.h	/^    DWORD adapter_index; \/* interface or ~0 if undefined *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
route_ipv6_gateway_info::addrs	route.h	/^    struct route_ipv6_gateway_address addrs[RGI_N_ADDRESSES]; \/* local addresses attached to iface *\/$/;"	m	struct:route_ipv6_gateway_info	typeref:struct:route_ipv6_gateway_info::route_ipv6_gateway_address	access:public
route_ipv6_gateway_info::flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_ipv6_gateway_info	access:public
route_ipv6_gateway_info::gateway	route.h	/^    struct route_ipv6_gateway_address gateway;$/;"	m	struct:route_ipv6_gateway_info	typeref:struct:route_ipv6_gateway_info::route_ipv6_gateway_address	access:public
route_ipv6_gateway_info::hwaddr	route.h	/^    uint8_t hwaddr[6];$/;"	m	struct:route_ipv6_gateway_info	access:public
route_ipv6_gateway_info::iface	route.h	/^    char iface[16]; \/* interface name (null terminated), may be empty *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
route_ipv6_gateway_info::n_addrs	route.h	/^    int n_addrs; \/* len of addrs, may be 0 *\/$/;"	m	struct:route_ipv6_gateway_info	access:public
route_ipv6_list	openvpn.h	/^    struct route_ipv6_list *route_ipv6_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_ipv6_list	access:public
route_ipv6_list	route.h	/^struct route_ipv6_list {$/;"	s
route_ipv6_list::default_metric	route.h	/^    int default_metric;$/;"	m	struct:route_ipv6_list	access:public
route_ipv6_list::flags	route.h	/^    unsigned int flags;                 \/* RG_x flags, see route_option_list *\/$/;"	m	struct:route_ipv6_list	access:public
route_ipv6_list::gc	route.h	/^    struct gc_arena gc;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::gc_arena	access:public
route_ipv6_list::iflags	route.h	/^    unsigned int iflags;                \/* RL_ flags, see route_list *\/$/;"	m	struct:route_ipv6_list	access:public
route_ipv6_list::remote_endpoint_ipv6	route.h	/^    struct in6_addr remote_endpoint_ipv6; \/* inside tun *\/$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::in6_addr	access:public
route_ipv6_list::remote_host_ipv6	route.h	/^    struct in6_addr remote_host_ipv6;   \/* --remote address *\/$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::in6_addr	access:public
route_ipv6_list::rgi6	route.h	/^    struct route_ipv6_gateway_info rgi6;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::route_ipv6_gateway_info	access:public
route_ipv6_list::routes_ipv6	route.h	/^    struct route_ipv6 *routes_ipv6;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::route_ipv6	access:public
route_ipv6_list::spec_flags	route.h	/^    unsigned int spec_flags;            \/* RTSA_ flags, route_special_addr *\/$/;"	m	struct:route_ipv6_list	access:public
route_ipv6_match_host	route.c	/^route_ipv6_match_host( const struct route_ipv6 *r6,$/;"	f	file:	signature:( const struct route_ipv6 *r6, const struct in6_addr *host )
route_ipv6_option	route.h	/^struct route_ipv6_option {$/;"	s
route_ipv6_option::gateway	route.h	/^    const char *gateway;        \/* e.g. "2001:db8:0::2" *\/$/;"	m	struct:route_ipv6_option	access:public
route_ipv6_option::metric	route.h	/^    const char *metric;         \/* e.g. "5" *\/$/;"	m	struct:route_ipv6_option	access:public
route_ipv6_option::next	route.h	/^    struct route_ipv6_option *next;$/;"	m	struct:route_ipv6_option	typeref:struct:route_ipv6_option::route_ipv6_option	access:public
route_ipv6_option::prefix	route.h	/^    const char *prefix;         \/* e.g. "2001:db8:1::\/64" *\/$/;"	m	struct:route_ipv6_option	access:public
route_ipv6_option_list	route.h	/^struct route_ipv6_option_list {$/;"	s
route_ipv6_option_list::flags	route.h	/^    unsigned int flags;         \/* RG_x flags, see route_option-list *\/$/;"	m	struct:route_ipv6_option_list	access:public
route_ipv6_option_list::gc	route.h	/^    struct gc_arena *gc;$/;"	m	struct:route_ipv6_option_list	typeref:struct:route_ipv6_option_list::gc_arena	access:public
route_ipv6_option_list::routes_ipv6	route.h	/^    struct route_ipv6_option *routes_ipv6;$/;"	m	struct:route_ipv6_option_list	typeref:struct:route_ipv6_option_list::route_ipv6_option	access:public
route_list	openvpn.h	/^    struct route_list *route_list;$/;"	m	struct:context_1	typeref:struct:context_1::route_list	access:public
route_list	route.h	/^struct route_list {$/;"	s
route_list::flags	route.h	/^    unsigned int flags;   \/* RG_x flags *\/$/;"	m	struct:route_list	access:public
route_list::gc	route.h	/^    struct gc_arena gc;$/;"	m	struct:route_list	typeref:struct:route_list::gc_arena	access:public
route_list::iflags	route.h	/^    unsigned int iflags;$/;"	m	struct:route_list	access:public
route_list::rgi	route.h	/^    struct route_gateway_info rgi;$/;"	m	struct:route_list	typeref:struct:route_list::route_gateway_info	access:public
route_list::routes	route.h	/^    struct route_ipv4 *routes;$/;"	m	struct:route_list	typeref:struct:route_list::route_ipv4	access:public
route_list::spec	route.h	/^    struct route_special_addr spec;$/;"	m	struct:route_list	typeref:struct:route_list::route_special_addr	access:public
route_list_add_vpn_gateway	route.c	/^route_list_add_vpn_gateway(struct route_list *rl,$/;"	f	signature:(struct route_list *rl, struct env_set *es, const in_addr_t addr)
route_list_add_vpn_gateway	route.h	/^void route_list_add_vpn_gateway(struct route_list *rl,$/;"	p	signature:(struct route_list *rl, struct env_set *es, const in_addr_t addr)
route_list_vpn_gateway_needed	route.h	/^route_list_vpn_gateway_needed(const struct route_list *rl)$/;"	f	signature:(const struct route_list *rl)
route_method	options.h	/^    int route_method;$/;"	m	struct:options	access:public
route_noexec	options.h	/^    bool route_noexec;$/;"	m	struct:options	access:public
route_nopull	options.h	/^    bool route_nopull;$/;"	m	struct:options	access:public
route_option	route.h	/^struct route_option {$/;"	s
route_option::gateway	route.h	/^    const char *gateway;$/;"	m	struct:route_option	access:public
route_option::metric	route.h	/^    const char *metric;$/;"	m	struct:route_option	access:public
route_option::netmask	route.h	/^    const char *netmask;$/;"	m	struct:route_option	access:public
route_option::network	route.h	/^    const char *network;$/;"	m	struct:route_option	access:public
route_option::next	route.h	/^    struct route_option *next;$/;"	m	struct:route_option	typeref:struct:route_option::route_option	access:public
route_option_list	route.h	/^struct route_option_list {$/;"	s
route_option_list::flags	route.h	/^    unsigned int flags; \/* RG_x flags *\/$/;"	m	struct:route_option_list	access:public
route_option_list::gc	route.h	/^    struct gc_arena *gc;$/;"	m	struct:route_option_list	typeref:struct:route_option_list::gc_arena	access:public
route_option_list::routes	route.h	/^    struct route_option *routes;$/;"	m	struct:route_option_list	typeref:struct:route_option_list::route_option	access:public
route_order	tun.h	/^route_order(void)$/;"	f	signature:(void)
route_predown_script	options.h	/^    const char *route_predown_script;$/;"	m	struct:options	access:public
route_quota_dec	multi.h	/^route_quota_dec(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
route_quota_exceeded	multi.c	/^route_quota_exceeded(const struct multi_context *m, const struct multi_instance *mi)$/;"	f	signature:(const struct multi_context *m, const struct multi_instance *mi)
route_quota_exceeded	multi.h	/^void route_quota_exceeded(const struct multi_context *m, const struct multi_instance *mi);$/;"	p	signature:(const struct multi_context *m, const struct multi_instance *mi)
route_quota_inc	multi.h	/^route_quota_inc(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
route_quota_test	multi.h	/^route_quota_test(const struct multi_context *m, const struct multi_instance *mi)$/;"	f	signature:(const struct multi_context *m, const struct multi_instance *mi)
route_script	options.h	/^    const char *route_script;$/;"	m	struct:options	access:public
route_special_addr	route.h	/^struct route_special_addr$/;"	s
route_special_addr::bypass	route.h	/^    struct route_bypass bypass;$/;"	m	struct:route_special_addr	typeref:struct:route_special_addr::route_bypass	access:public
route_special_addr::default_metric	route.h	/^    int default_metric;$/;"	m	struct:route_special_addr	access:public
route_special_addr::flags	route.h	/^    unsigned int flags;$/;"	m	struct:route_special_addr	access:public
route_special_addr::remote_endpoint	route.h	/^    in_addr_t remote_endpoint;$/;"	m	struct:route_special_addr	access:public
route_special_addr::remote_host	route.h	/^    in_addr_t remote_host;$/;"	m	struct:route_special_addr	access:public
route_special_addr::remote_host_local	route.h	/^    int remote_host_local; \/* TLA_x value *\/$/;"	m	struct:route_special_addr	access:public
route_string	route.c	/^route_string(const struct route_ipv4 *r, struct gc_arena *gc)$/;"	f	file:	signature:(const struct route_ipv4 *r, struct gc_arena *gc)
route_wakeup	openvpn.h	/^    struct event_timeout route_wakeup;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
route_wakeup_expire	openvpn.h	/^    struct event_timeout route_wakeup_expire;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
routes	options.h	/^    struct route_option_list *routes;$/;"	m	struct:options	typeref:struct:options::route_option_list	access:public
routes	options.h	/^    struct route_option_list *routes;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_option_list	access:public
routes	route.h	/^    struct route_ipv4 *routes;$/;"	m	struct:route_list	typeref:struct:route_list::route_ipv4	access:public
routes	route.h	/^    struct route_option *routes;$/;"	m	struct:route_option_list	typeref:struct:route_option_list::route_option	access:public
routes_defined	options.h	/^    bool routes_defined;$/;"	m	struct:options_pre_pull	access:public
routes_ipv6	options.h	/^    struct route_ipv6_option_list *routes_ipv6;                 \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::route_ipv6_option_list	access:public
routes_ipv6	options.h	/^    struct route_ipv6_option_list *routes_ipv6;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::route_ipv6_option_list	access:public
routes_ipv6	route.h	/^    struct route_ipv6 *routes_ipv6;$/;"	m	struct:route_ipv6_list	typeref:struct:route_ipv6_list::route_ipv6	access:public
routes_ipv6	route.h	/^    struct route_ipv6_option *routes_ipv6;$/;"	m	struct:route_ipv6_option_list	typeref:struct:route_ipv6_option_list::route_ipv6_option	access:public
routes_ipv6_defined	options.h	/^    bool routes_ipv6_defined;$/;"	m	struct:options_pre_pull	access:public
rsa_priv_dec	cryptoapi.c	/^rsa_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_priv_dec	ssl_openssl.c	/^rsa_priv_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_priv_enc	cryptoapi.c	/^rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_priv_enc	ssl_openssl.c	/^rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_pub_dec	cryptoapi.c	/^rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_pub_dec	ssl_openssl.c	/^rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_pub_enc	cryptoapi.c	/^rsa_pub_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_pub_enc	ssl_openssl.c	/^rsa_pub_enc(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)$/;"	f	file:	signature:(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding)
rsa_sig	manage.h	/^    struct buffer_list *rsa_sig;$/;"	m	struct:man_connection	typeref:struct:man_connection::buffer_list	access:public
rsa_sign_CNG	cryptoapi.c	/^rsa_sign_CNG(int type, const unsigned char *m, unsigned int m_len,$/;"	f	file:	signature:(int type, const unsigned char *m, unsigned int m_len, unsigned char *sig, unsigned int *siglen, const RSA *rsa)
rtm	route.c	/^    struct rtmsg rtm;$/;"	m	struct:rtreq	typeref:struct:rtreq::rtmsg	file:	access:public
rtm	route.c	3599;"	d	file:
rtmsg	route.c	/^struct rtmsg {$/;"	s	file:
rtmsg::m_rtm	route.c	/^    struct rt_msghdr m_rtm;$/;"	m	struct:rtmsg	typeref:struct:rtmsg::rt_msghdr	file:	access:public
rtmsg::m_space	route.c	/^    char m_space[512];$/;"	m	struct:rtmsg	file:	access:public
rtreq	route.c	/^struct rtreq {$/;"	s	file:
rtreq::attrbuf	route.c	/^    char attrbuf[512];$/;"	m	struct:rtreq	file:	access:public
rtreq::nh	route.c	/^    struct nlmsghdr nh;$/;"	m	struct:rtreq	typeref:struct:rtreq::nlmsghdr	file:	access:public
rtreq::rtm	route.c	/^    struct rtmsg rtm;$/;"	m	struct:rtreq	typeref:struct:rtreq::rtmsg	file:	access:public
rule	pf.h	/^    struct ipv4_subnet rule;$/;"	m	struct:pf_subnet	typeref:struct:pf_subnet::ipv4_subnet	access:public
rule	pf.h	/^    struct pf_cn rule;$/;"	m	struct:pf_cn_elem	typeref:struct:pf_cn_elem::pf_cn	access:public
run_up_down	init.c	/^run_up_down(const char *command,$/;"	f	file:	signature:(const char *command, const struct plugin_list *plugins, int plugin_type, const char *arg, DWORD adapter_index, const char *dev_type, int tun_mtu, int link_mtu, const char *ifconfig_local, const char *ifconfig_remote, const char *context, const char *signal_text, const char *script_type, struct env_set *es)
rw_handle	socket.h	/^    struct rw_handle rw_handle;$/;"	m	struct:link_socket	typeref:struct:link_socket::rw_handle	access:public
rw_handle	tun.h	/^    struct rw_handle rw_handle;$/;"	m	struct:tuntap	typeref:struct:tuntap::rw_handle	access:public
rw_handle	win32.h	/^struct rw_handle {$/;"	s
rw_handle::read	win32.h	/^    HANDLE read;$/;"	m	struct:rw_handle	access:public
rw_handle::write	win32.h	/^    HANDLE write;$/;"	m	struct:rw_handle	access:public
rwflags	event.h	/^    unsigned int rwflags;$/;"	m	struct:event_set_return	access:public
rwflags	ps.c	/^    int rwflags;$/;"	m	struct:proxy_connection	file:	access:public
rwflags_debug	socket.h	/^    unsigned int rwflags_debug;$/;"	m	struct:link_socket	access:public
rwflags_debug	tun.h	/^    unsigned int rwflags_debug;$/;"	m	struct:tuntap	access:public
s_pkcs11h_sys_engine	pkcs11.c	/^static pkcs11h_engine_system_t s_pkcs11h_sys_engine = {$/;"	v	file:
sa	socket.h	/^        struct sockaddr sa;$/;"	m	union:openvpn_sockaddr::__anon13	typeref:struct:openvpn_sockaddr::__anon13::sockaddr	access:public
sa	win32.h	/^    SECURITY_ATTRIBUTES sa;$/;"	m	struct:security_attributes	access:public
sa_family_t	syshead.h	/^typedef unsigned short sa_family_t;$/;"	t
saddr	proto.h	/^    struct  in6_addr saddr;$/;"	m	struct:openvpn_ipv6hdr	typeref:struct:openvpn_ipv6hdr::in6_addr	access:public
saddr	proto.h	/^    uint32_t saddr;$/;"	m	struct:openvpn_iphdr	access:public
safe_print	misc.c	/^safe_print(const char *str, struct gc_arena *gc)$/;"	f	signature:(const char *str, struct gc_arena *gc)
safe_print	misc.h	/^const char *safe_print(const char *str, struct gc_arena *gc);$/;"	p	signature:(const char *str, struct gc_arena *gc)
sanitize_control_message	misc.c	/^sanitize_control_message(const char *src, struct gc_arena *gc)$/;"	f	signature:(const char *src, struct gc_arena *gc)
sanitize_control_message	misc.h	/^const char *sanitize_control_message(const char *str, struct gc_arena *gc);$/;"	p	signature:(const char *str, struct gc_arena *gc)
save_inetd_socket_descriptor	misc.c	/^save_inetd_socket_descriptor(void)$/;"	f	signature:(void)
save_inetd_socket_descriptor	misc.h	/^void save_inetd_socket_descriptor(void);$/;"	p	signature:(void)
save_ks	ssl_common.h	/^    struct key_state *save_ks;  \/* temporary pointer used between pre\/post routines *\/$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state	access:public
save_ncp_options	init.c	/^save_ncp_options(struct context *c)$/;"	f	file:	signature:(struct context *c)
saved	win32.h	/^    bool saved;$/;"	m	struct:window_title	access:public
sc_info	options.h	/^    struct static_challenge_info sc_info;$/;"	m	struct:options	typeref:struct:options::static_challenge_info	access:public
schedule	multi.h	/^    struct schedule *schedule;$/;"	m	struct:multi_context	typeref:struct:multi_context::schedule	access:public
schedule	schedule.h	/^struct schedule$/;"	s
schedule::earliest_wakeup	schedule.h	/^    struct schedule_entry *earliest_wakeup; \/* cached earliest wakeup *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry	access:public
schedule::root	schedule.h	/^    struct schedule_entry *root;          \/* the root of the treap (btree) *\/$/;"	m	struct:schedule	typeref:struct:schedule::schedule_entry	access:public
schedule_add_entry	schedule.h	/^schedule_add_entry(struct schedule *s,$/;"	f	signature:(struct schedule *s, struct schedule_entry *e, const struct timeval *tv, unsigned int sigma)
schedule_add_modify	schedule.c	/^schedule_add_modify(struct schedule *s, struct schedule_entry *e)$/;"	f	signature:(struct schedule *s, struct schedule_entry *e)
schedule_add_modify	schedule.h	/^void schedule_add_modify(struct schedule *s, struct schedule_entry *e);$/;"	p	signature:(struct schedule *s, struct schedule_entry *e)
schedule_debug	schedule.c	/^schedule_debug(struct schedule *s, int *count, struct timeval *least)$/;"	f	signature:(struct schedule *s, int *count, struct timeval *least)
schedule_debug_entry	schedule.c	/^schedule_debug_entry(const struct schedule_entry *e,$/;"	f	signature:(const struct schedule_entry *e, int depth, int *count, struct timeval *least, const struct timeval *min, const struct timeval *max)
schedule_detach_parent	schedule.c	/^schedule_detach_parent(struct schedule *s, struct schedule_entry *e)$/;"	f	file:	signature:(struct schedule *s, struct schedule_entry *e)
schedule_entry	schedule.h	/^struct schedule_entry$/;"	s
schedule_entry::gt	schedule.h	/^    struct schedule_entry *gt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
schedule_entry::lt	schedule.h	/^    struct schedule_entry *lt;$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
schedule_entry::parent	schedule.h	/^    struct schedule_entry *parent; \/* treap (btree) links *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::schedule_entry	access:public
schedule_entry::pri	schedule.h	/^    unsigned int pri;            \/* random treap priority *\/$/;"	m	struct:schedule_entry	access:public
schedule_entry::tv	schedule.h	/^    struct timeval tv;           \/* wakeup time *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::timeval	access:public
schedule_entry_compare	schedule.c	/^schedule_entry_compare(const struct schedule_entry *e1,$/;"	f	file:	signature:(const struct schedule_entry *e1, const struct schedule_entry *e2)
schedule_entry_debug_info	schedule.c	/^schedule_entry_debug_info(const char *caller, const struct schedule_entry *e)$/;"	f	file:	signature:(const char *caller, const struct schedule_entry *e)
schedule_exit	forward.c	/^schedule_exit(struct context *c, const int n_seconds, const int signal)$/;"	f	signature:(struct context *c, const int n_seconds, const int signal)
schedule_exit	forward.h	/^void schedule_exit(struct context *c, const int n_seconds, const int signal);$/;"	p	signature:(struct context *c, const int n_seconds, const int signal)
schedule_find_earliest_wakeup	schedule.c	/^schedule_find_earliest_wakeup(struct schedule *s)$/;"	f	file:	signature:(struct schedule *s)
schedule_find_least	schedule.c	/^schedule_find_least(struct schedule_entry *e)$/;"	f	signature:(struct schedule_entry *e)
schedule_find_least	schedule.h	/^struct schedule_entry *schedule_find_least(struct schedule_entry *e);$/;"	p	signature:(struct schedule_entry *e)
schedule_free	schedule.c	/^schedule_free(struct schedule *s)$/;"	f	signature:(struct schedule *s)
schedule_free	schedule.h	/^void schedule_free(struct schedule *s);$/;"	p	signature:(struct schedule *s)
schedule_get_earliest_wakeup	schedule.h	/^schedule_get_earliest_wakeup(struct schedule *s,$/;"	f	signature:(struct schedule *s, struct timeval *wakeup)
schedule_init	schedule.c	/^schedule_init(void)$/;"	f	signature:(void)
schedule_init	schedule.h	/^struct schedule *schedule_init(void);$/;"	p	signature:(void)
schedule_insert	schedule.c	/^schedule_insert(struct schedule *s, struct schedule_entry *e)$/;"	f	file:	signature:(struct schedule *s, struct schedule_entry *e)
schedule_print	schedule.c	/^schedule_print(struct schedule *s)$/;"	f	signature:(struct schedule *s)
schedule_print_work	schedule.c	/^schedule_print_work(struct schedule_entry *e, int indent)$/;"	f	signature:(struct schedule_entry *e, int indent)
schedule_randomize_array	schedule.c	/^schedule_randomize_array(struct schedule_entry **array, int size)$/;"	f	signature:(struct schedule_entry **array, int size)
schedule_remove_entry	schedule.c	/^schedule_remove_entry(struct schedule *s, struct schedule_entry *e)$/;"	f	signature:(struct schedule *s, struct schedule_entry *e)
schedule_remove_entry	schedule.h	/^void schedule_remove_entry(struct schedule *s, struct schedule_entry *e);$/;"	p	signature:(struct schedule *s, struct schedule_entry *e)
schedule_remove_node	schedule.c	/^schedule_remove_node(struct schedule *s, struct schedule_entry *e)$/;"	f	signature:(struct schedule *s, struct schedule_entry *e)
schedule_remove_node	schedule.h	/^void schedule_remove_node(struct schedule *s, struct schedule_entry *e);$/;"	p	signature:(struct schedule *s, struct schedule_entry *e)
schedule_rotate_up	schedule.c	/^schedule_rotate_up(struct schedule *s, struct schedule_entry *e)$/;"	f	file:	signature:(struct schedule *s, struct schedule_entry *e)
schedule_set_pri	schedule.c	/^schedule_set_pri(struct schedule_entry *e)$/;"	f	file:	signature:(struct schedule_entry *e)
schedule_test	schedule.c	/^schedule_test(void)$/;"	f	signature:(void)
schedule_test	schedule.h	/^void schedule_test(void);$/;"	p	signature:(void)
schedule_verify	schedule.c	/^schedule_verify(struct schedule *s)$/;"	f	signature:(struct schedule *s)
scheduled_exit	openvpn.h	/^    struct event_timeout scheduled_exit;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
scheduled_exit_interval	options.h	/^    int scheduled_exit_interval;$/;"	m	struct:options	access:public
scheduled_exit_signal	openvpn.h	/^    int scheduled_exit_signal;$/;"	m	struct:context_2	access:public
sci	ssl_common.h	/^    const struct static_challenge_info *sci;$/;"	m	struct:tls_options	typeref:struct:tls_options::static_challenge_info	access:public
script_security	misc.c	/^int script_security = SSEC_BUILT_IN; \/* GLOBAL *\/$/;"	v
sd	ps.c	/^    int sd;$/;"	m	struct:proxy_connection	file:	access:public
sd	socket.h	/^    socket_descriptor_t sd;$/;"	m	struct:link_socket	access:public
sd	win32.h	/^    SECURITY_DESCRIPTOR sd;$/;"	m	struct:security_attributes	access:public
sd	win32.h	/^    socket_descriptor_t sd;$/;"	m	struct:net_event_win32	access:public
sd_cli	manage.h	/^    socket_descriptor_t sd_cli;$/;"	m	struct:man_connection	access:public
sd_close	socket.c	/^sd_close(socket_descriptor_t *sd)$/;"	f	signature:(socket_descriptor_t *sd)
sd_close	socket.h	/^void sd_close(socket_descriptor_t *sd);$/;"	p	signature:(socket_descriptor_t *sd)
sd_top	manage.h	/^    socket_descriptor_t sd_top;$/;"	m	struct:man_connection	access:public
se	multi.h	/^    struct schedule_entry se;  \/* this must be the first element of the structure *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::schedule_entry	access:public
se	multi.h	/^    struct schedule_entry se;$/;"	m	struct:deferred_signal_schedule_entry	typeref:struct:deferred_signal_schedule_entry::schedule_entry	access:public
se_ctl	event.c	/^se_ctl(struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct event_set *es, event_t event, unsigned int rwflags, void *arg)
se_del	event.c	/^se_del(struct event_set *es, event_t event)$/;"	f	file:	signature:(struct event_set *es, event_t event)
se_free	event.c	/^se_free(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
se_init	event.c	/^se_init(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
se_reset	event.c	/^se_reset(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
se_set	event.c	/^struct se_set$/;"	s	file:
se_set::args	event.c	/^    void **args; \/* allocated to capacity size *\/$/;"	m	struct:se_set	file:	access:public
se_set::capacity	event.c	/^    int capacity; \/* fixed largest fd + 1 *\/$/;"	m	struct:se_set	file:	access:public
se_set::fast	event.c	/^    bool fast;$/;"	m	struct:se_set	file:	access:public
se_set::func	event.c	/^    struct event_set_functions func;$/;"	m	struct:se_set	typeref:struct:se_set::event_set_functions	file:	access:public
se_set::maxfd	event.c	/^    int maxfd;  \/* largest fd seen so far, always < capacity *\/$/;"	m	struct:se_set	file:	access:public
se_set::readfds	event.c	/^    fd_set readfds;$/;"	m	struct:se_set	file:	access:public
se_set::writefds	event.c	/^    fd_set writefds;$/;"	m	struct:se_set	file:	access:public
se_wait_fast	event.c	/^se_wait_fast(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
se_wait_return	event.c	/^se_wait_return(struct se_set *ses,$/;"	f	file:	signature:(struct se_set *ses, fd_set *read, fd_set *write, struct event_set_return *out, int outlen)
se_wait_scalable	event.c	/^se_wait_scalable(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
secs	dhcp.h	/^    uint16_t secs;     \/* seconds since request process began, set by client *\/$/;"	m	struct:dhcp	access:public
secure_memzero	buffer.h	/^secure_memzero(void *data, size_t len)$/;"	f	signature:(void *data, size_t len)
security_attributes	win32.h	/^struct security_attributes$/;"	s
security_attributes::sa	win32.h	/^    SECURITY_ATTRIBUTES sa;$/;"	m	struct:security_attributes	access:public
security_attributes::sd	win32.h	/^    SECURITY_DESCRIPTOR sd;$/;"	m	struct:security_attributes	access:public
selinux_context	options.h	/^    char *selinux_context;$/;"	m	struct:options	access:public
semaphore	win32.h	/^struct semaphore$/;"	s
semaphore::hand	win32.h	/^    HANDLE hand;$/;"	m	struct:semaphore	access:public
semaphore::locked	win32.h	/^    bool locked;$/;"	m	struct:semaphore	access:public
semaphore::name	win32.h	/^    const char *name;$/;"	m	struct:semaphore	access:public
semaphore_clear	win32.c	/^semaphore_clear(struct semaphore *s)$/;"	f	signature:(struct semaphore *s)
semaphore_clear	win32.h	/^void semaphore_clear(struct semaphore *s);$/;"	p	signature:(struct semaphore *s)
semaphore_close	win32.c	/^semaphore_close(struct semaphore *s)$/;"	f	signature:(struct semaphore *s)
semaphore_close	win32.h	/^void semaphore_close(struct semaphore *s);$/;"	p	signature:(struct semaphore *s)
semaphore_lock	win32.c	/^semaphore_lock(struct semaphore *s, int timeout_milliseconds)$/;"	f	signature:(struct semaphore *s, int timeout_milliseconds)
semaphore_lock	win32.h	/^bool semaphore_lock(struct semaphore *s, int timeout_milliseconds);$/;"	p	signature:(struct semaphore *s, int timeout_milliseconds)
semaphore_open	win32.c	/^semaphore_open(struct semaphore *s, const char *name)$/;"	f	signature:(struct semaphore *s, const char *name)
semaphore_open	win32.h	/^void semaphore_open(struct semaphore *s, const char *name);$/;"	p	signature:(struct semaphore *s, const char *name)
semaphore_release	win32.c	/^semaphore_release(struct semaphore *s)$/;"	f	signature:(struct semaphore *s)
semaphore_release	win32.h	/^void semaphore_release(struct semaphore *s);$/;"	p	signature:(struct semaphore *s)
send	packet_id.h	/^    struct packet_id_send send;$/;"	m	struct:packet_id	typeref:struct:packet_id::packet_id_send	access:public
send_auth_failed	push.c	/^send_auth_failed(struct context *c, const char *client_reason)$/;"	f	signature:(struct context *c, const char *client_reason)
send_auth_failed	push.h	/^void send_auth_failed(struct context *c, const char *client_reason);$/;"	p	signature:(struct context *c, const char *client_reason)
send_control	ps.c	/^send_control(const socket_descriptor_t fd, int code)$/;"	f	file:	signature:(const socket_descriptor_t fd, int code)
send_control_channel_string	forward.c	/^send_control_channel_string(struct context *c, const char *str, int msglevel)$/;"	f	signature:(struct context *c, const char *str, int msglevel)
send_control_channel_string	forward.h	/^bool send_control_channel_string(struct context *c, const char *str, int msglevel);$/;"	p	signature:(struct context *c, const char *str, int msglevel)
send_crlf	proxy.c	/^send_crlf(socket_descriptor_t sd)$/;"	f	file:	signature:(socket_descriptor_t sd)
send_line	proxy.c	/^send_line(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, const char *buf)
send_line_crlf	proxy.c	/^send_line_crlf(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, const char *src)
send_push_options	push.c	/^send_push_options(struct context *c, struct buffer *buf,$/;"	f	file:	signature:(struct context *c, struct buffer *buf, struct push_list *push_list, int safe_cap, bool *push_sent, bool *multi_push)
send_push_reply	push.c	/^send_push_reply(struct context *c, struct push_list *per_client_push_list)$/;"	f	file:	signature:(struct context *c, struct push_list *per_client_push_list)
send_push_request	push.c	/^send_push_request(struct context *c)$/;"	f	signature:(struct context *c)
send_push_request	push.h	/^bool send_push_request(struct context *c);$/;"	p	signature:(struct context *c)
send_reliable	ssl_common.h	/^    struct reliable *send_reliable; \/* holds a copy of outgoing packets until ACK received *\/$/;"	m	struct:key_state	typeref:struct:key_state::reliable	access:public
send_restart	push.c	/^send_restart(struct context *c, const char *kill_msg)$/;"	f	signature:(struct context *c, const char *kill_msg)
send_restart	push.h	/^void send_restart(struct context *c, const char *kill_msg);$/;"	p	signature:(struct context *c, const char *kill_msg)
sent_push_reply_expiry	openvpn.h	/^    time_t sent_push_reply_expiry;$/;"	m	struct:context_2	access:public
seq	proto.h	/^    uint32_t seq;          \/* sequence number *\/$/;"	m	struct:openvpn_tcphdr	access:public
seq_backtrack	packet_id.h	/^    int seq_backtrack;        \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec	access:public
seq_id	fragment.h	/^    int seq_id;                 \/**< Highest fragmentation sequence ID of$/;"	m	struct:fragment_list	access:public
seq_list	packet_id.h	/^    struct seq_list *seq_list; \/* packet-id "memory" *\/$/;"	m	struct:packet_id_rec	typeref:struct:packet_id_rec::seq_list	access:public
server	proxy.h	/^    const char *server;$/;"	m	struct:http_proxy_options	access:public
server	proxy.h	/^    const char *server;$/;"	m	struct:http_proxy_options_simple	access:public
server	socks.h	/^    char server[128];$/;"	m	struct:socks_proxy_info	access:public
server	ssl_common.h	/^    bool server;$/;"	m	struct:tls_options	access:public
server	ssl_common.h	/^    struct key_source server;   \/**< Random provided by server. *\/$/;"	m	struct:key_source2	typeref:struct:key_source2::key_source	access:public
server_bridge_defined	options.h	/^    bool server_bridge_defined;$/;"	m	struct:options	access:public
server_bridge_ip	options.h	/^    in_addr_t server_bridge_ip;$/;"	m	struct:options	access:public
server_bridge_netmask	options.h	/^    in_addr_t server_bridge_netmask;$/;"	m	struct:options	access:public
server_bridge_pool_end	options.h	/^    in_addr_t server_bridge_pool_end;$/;"	m	struct:options	access:public
server_bridge_pool_start	options.h	/^    in_addr_t server_bridge_pool_start;$/;"	m	struct:options	access:public
server_bridge_proxy_dhcp	options.h	/^    bool server_bridge_proxy_dhcp;$/;"	m	struct:options	access:public
server_defined	options.h	/^    bool server_defined;$/;"	m	struct:options	access:public
server_flags	options.h	/^    unsigned int server_flags;$/;"	m	struct:options	access:public
server_ipv6_defined	options.h	/^    bool server_ipv6_defined;                           \/* IPv6 *\/$/;"	m	struct:options	access:public
server_netbits_ipv6	options.h	/^    unsigned int server_netbits_ipv6;                   \/* IPv6 *\/$/;"	m	struct:options	access:public
server_netmask	options.h	/^    in_addr_t server_netmask;$/;"	m	struct:options	access:public
server_network	options.h	/^    in_addr_t server_network;$/;"	m	struct:options	access:public
server_network_ipv6	options.h	/^    struct in6_addr server_network_ipv6;                \/* IPv6 *\/$/;"	m	struct:options	typeref:struct:options::in6_addr	access:public
server_poll_interval	openvpn.h	/^    struct event_timeout server_poll_interval;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
server_poll_timeout	socket.h	/^    struct event_timeout *server_poll_timeout;$/;"	m	struct:link_socket	typeref:struct:link_socket::event_timeout	access:public
server_pushed_signal	push.c	/^server_pushed_signal(struct context *c, const struct buffer *buffer, const bool restart, const int adv)$/;"	f	signature:(struct context *c, const struct buffer *buffer, const bool restart, const int adv)
server_pushed_signal	push.h	/^void server_pushed_signal(struct context *c, const struct buffer *buffer, const bool restart, const int adv);$/;"	p	signature:(struct context *c, const struct buffer *buffer, const bool restart, const int adv)
service_enable_dhcp	tun.c	/^service_enable_dhcp(const struct tuntap *tt)$/;"	f	file:	signature:(const struct tuntap *tt)
servname	socket.h	/^    const char *servname;$/;"	m	struct:cached_dns_entry	access:public
session	ssl_common.h	/^    struct tls_session session[TM_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_session	access:public
session_id	session_id.h	/^struct session_id$/;"	s
session_id	ssl_common.h	/^    struct session_id session_id; \/* our random session ID *\/$/;"	m	struct:tls_session	typeref:struct:tls_session::session_id	access:public
session_id::id	session_id.h	/^    uint8_t id[8];$/;"	m	struct:session_id	access:public
session_id_defined	session_id.h	/^session_id_defined(const struct session_id *sid1)$/;"	f	signature:(const struct session_id *sid1)
session_id_equal	session_id.h	/^session_id_equal(const struct session_id *sid1,$/;"	f	signature:(const struct session_id *sid1, const struct session_id *sid2)
session_id_print	session_id.c	/^session_id_print(const struct session_id *sid, struct gc_arena *gc)$/;"	f	signature:(const struct session_id *sid, struct gc_arena *gc)
session_id_print	session_id.h	/^const char *session_id_print(const struct session_id *sid, struct gc_arena *gc);$/;"	p	signature:(const struct session_id *sid, struct gc_arena *gc)
session_id_random	session_id.c	/^session_id_random(struct session_id *sid)$/;"	f	signature:(struct session_id *sid)
session_id_random	session_id.h	/^void session_id_random(struct session_id *sid);$/;"	p	signature:(struct session_id *sid)
session_id_read	session_id.h	/^session_id_read(struct session_id *sid, struct buffer *buf)$/;"	f	signature:(struct session_id *sid, struct buffer *buf)
session_id_remote	ssl_common.h	/^    struct session_id session_id_remote; \/* peer's random session ID *\/$/;"	m	struct:key_state	typeref:struct:key_state::session_id	access:public
session_id_write	session_id.h	/^session_id_write(const struct session_id *sid, struct buffer *buf)$/;"	f	signature:(const struct session_id *sid, struct buffer *buf)
session_id_write_prepend	session_id.h	/^session_id_write_prepend(const struct session_id *sid, struct buffer *buf)$/;"	f	signature:(const struct session_id *sid, struct buffer *buf)
session_index_name	ssl.c	/^session_index_name(int index)$/;"	f	file:	signature:(int index)
set_actual_address	socket.c	/^set_actual_address(struct link_socket_actual *actual, struct addrinfo *ai)$/;"	f	signature:(struct link_socket_actual *actual, struct addrinfo *ai)
set_actual_address	socket.h	/^void set_actual_address(struct link_socket_actual *actual,$/;"	p	signature:(struct link_socket_actual *actual, struct addrinfo *ai)
set_auth_token	misc.c	/^set_auth_token(struct user_pass *up, struct user_pass *tk, const char *token)$/;"	f	signature:(struct user_pass *up, struct user_pass *tk, const char *token)
set_auth_token	misc.h	/^void set_auth_token(struct user_pass *up, struct user_pass *tk,$/;"	p	signature:(struct user_pass *up, struct user_pass *tk, const char *token)
set_cc_config	multi.c	/^set_cc_config(struct multi_instance *mi, struct buffer_list *cc_config)$/;"	f	file:	signature:(struct multi_instance *mi, struct buffer_list *cc_config)
set_check_status	error.c	/^set_check_status(unsigned int info_level, unsigned int verbose_level)$/;"	f	signature:(unsigned int info_level, unsigned int verbose_level)
set_check_status	error.h	/^void set_check_status(unsigned int info_level, unsigned int verbose_level);$/;"	p	signature:(unsigned int info_level, unsigned int verbose_level)
set_check_status_error_delay	error.h	/^set_check_status_error_delay(unsigned int milliseconds)$/;"	f	signature:(unsigned int milliseconds)
set_cloexec	fdmisc.c	/^set_cloexec(int fd)$/;"	f	signature:(int fd)
set_cloexec	fdmisc.h	/^void set_cloexec(int fd);$/;"	p	signature:(int fd)
set_cloexec_action	fdmisc.c	/^set_cloexec_action(int fd)$/;"	f	signature:(int fd)
set_cloexec_action	fdmisc.h	/^bool set_cloexec_action(int fd);$/;"	p	signature:(int fd)
set_common_name	ssl_verify.c	/^set_common_name(struct tls_session *session, const char *common_name)$/;"	f	file:	signature:(struct tls_session *session, const char *common_name)
set_debug_level	error.c	/^set_debug_level(const int level, const unsigned int flags)$/;"	f	signature:(const int level, const unsigned int flags)
set_debug_level	error.h	/^bool set_debug_level(const int level, const unsigned int flags);$/;"	p	signature:(const int level, const unsigned int flags)
set_interface_metric	block_dns.c	/^set_interface_metric(const NET_IFINDEX index, const ADDRESS_FAMILY family,$/;"	f	signature:(const NET_IFINDEX index, const ADDRESS_FAMILY family, const ULONG metric)
set_interface_metric	block_dns.h	/^set_interface_metric(const NET_IFINDEX index, const ADDRESS_FAMILY family,$/;"	p	signature:(const NET_IFINDEX index, const ADDRESS_FAMILY family, const ULONG metric)
set_lladdr	lladdr.c	/^set_lladdr(const char *ifname, const char *lladdr,$/;"	f	signature:(const char *ifname, const char *lladdr, const struct env_set *es)
set_lladdr	lladdr.h	/^int set_lladdr(const char *ifname, const char *lladdr,$/;"	p	signature:(const char *ifname, const char *lladdr, const struct env_set *es)
set_machine_readable_output	error.c	/^set_machine_readable_output(bool parsable)$/;"	f	signature:(bool parsable)
set_machine_readable_output	error.h	/^void set_machine_readable_output(bool parsable);$/;"	p	signature:(bool parsable)
set_mtu_discover_type	mtu.c	/^set_mtu_discover_type(int sd, int mtu_type, sa_family_t proto_af)$/;"	f	signature:(int sd, int mtu_type, sa_family_t proto_af)
set_mtu_discover_type	mtu.h	/^void set_mtu_discover_type(int sd, int mtu_type, sa_family_t proto_af);$/;"	p	signature:(int sd, int mtu_type, sa_family_t proto_af)
set_mute_cutoff	error.c	/^set_mute_cutoff(const int cutoff)$/;"	f	signature:(const int cutoff)
set_mute_cutoff	error.h	/^bool set_mute_cutoff(const int cutoff);$/;"	p	signature:(const int cutoff)
set_nonblock	fdmisc.c	/^set_nonblock(int fd)$/;"	f	signature:(int fd)
set_nonblock	fdmisc.h	/^void set_nonblock(int fd);$/;"	p	signature:(int fd)
set_nonblock_action	fdmisc.c	/^set_nonblock_action(int fd)$/;"	f	signature:(int fd)
set_nonblock_action	fdmisc.h	/^bool set_nonblock_action(int fd);$/;"	p	signature:(int fd)
set_pause_exit_win32	win32.c	/^set_pause_exit_win32(void)$/;"	f	signature:(void)
set_pause_exit_win32	win32.h	/^void set_pause_exit_win32(void);$/;"	p	signature:(void)
set_prefix	multi.h	/^set_prefix(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
set_signals	ps.c	/^set_signals(void)$/;"	f	file:	signature:(void)
set_sock_extended_error_passing	mtu.c	/^set_sock_extended_error_passing(int sd)$/;"	f	signature:(int sd)
set_sock_extended_error_passing	mtu.h	/^void set_sock_extended_error_passing(int sd);$/;"	p	signature:(int sd)
set_std_files_to_null	misc.c	/^set_std_files_to_null(bool stdin_only)$/;"	f	signature:(bool stdin_only)
set_std_files_to_null	misc.h	/^void set_std_files_to_null(bool stdin_only);$/;"	p	signature:(bool stdin_only)
set_suppress_timestamps	error.c	/^set_suppress_timestamps(bool suppressed)$/;"	f	signature:(bool suppressed)
set_suppress_timestamps	error.h	/^void set_suppress_timestamps(bool suppressed);$/;"	p	signature:(bool suppressed)
set_user_script	options.c	/^set_user_script(struct options *options,$/;"	f	file:	signature:(struct options *options, const char **script, const char *new_script, const char *type, bool in_chroot)
set_win_sys_path	win32.c	/^set_win_sys_path(const char *newpath, struct env_set *es)$/;"	f	signature:(const char *newpath, struct env_set *es)
set_win_sys_path	win32.h	/^void set_win_sys_path(const char *newpath, struct env_set *es);$/;"	p	signature:(const char *newpath, struct env_set *es)
set_win_sys_path_via_env	win32.c	/^set_win_sys_path_via_env(struct env_set *es)$/;"	f	signature:(struct env_set *es)
set_win_sys_path_via_env	win32.h	/^void set_win_sys_path_via_env(struct env_set *es);$/;"	p	signature:(struct env_set *es)
setenv_connection_entry	options.c	/^setenv_connection_entry(struct env_set *es,$/;"	f	file:	signature:(struct env_set *es, const struct connection_entry *e, const int i)
setenv_counter	misc.c	/^setenv_counter(struct env_set *es, const char *name, counter_type value)$/;"	f	signature:(struct env_set *es, const char *name, counter_type value)
setenv_counter	misc.h	/^void setenv_counter(struct env_set *es, const char *name, counter_type value);$/;"	p	signature:(struct env_set *es, const char *name, counter_type value)
setenv_del	misc.c	/^setenv_del(struct env_set *es, const char *name)$/;"	f	signature:(struct env_set *es, const char *name)
setenv_del	misc.h	/^void setenv_del(struct env_set *es, const char *name);$/;"	p	signature:(struct env_set *es, const char *name)
setenv_format_indexed_name	misc.c	/^setenv_format_indexed_name(const char *name, const int i, struct gc_arena *gc)$/;"	f	file:	signature:(const char *name, const int i, struct gc_arena *gc)
setenv_in6_addr	socket.c	/^setenv_in6_addr(struct env_set *es,$/;"	f	signature:(struct env_set *es, const char *name_prefix, const struct in6_addr *addr, const unsigned int flags)
setenv_in6_addr	socket.h	/^void setenv_in6_addr(struct env_set *es,$/;"	p	signature:(struct env_set *es, const char *name_prefix, const struct in6_addr *addr, const unsigned int flags)
setenv_in_addr_t	socket.c	/^setenv_in_addr_t(struct env_set *es, const char *name_prefix, in_addr_t addr, const unsigned int flags)$/;"	f	signature:(struct env_set *es, const char *name_prefix, in_addr_t addr, const unsigned int flags)
setenv_in_addr_t	socket.h	/^void setenv_in_addr_t(struct env_set *es,$/;"	p	signature:(struct env_set *es, const char *name_prefix, in_addr_t addr, const unsigned int flags)
setenv_int	misc.c	/^setenv_int(struct env_set *es, const char *name, int value)$/;"	f	signature:(struct env_set *es, const char *name, int value)
setenv_int	misc.h	/^void setenv_int(struct env_set *es, const char *name, int value);$/;"	p	signature:(struct env_set *es, const char *name, int value)
setenv_int_i	misc.c	/^setenv_int_i(struct env_set *es, const char *name, const int value, const int i)$/;"	f	signature:(struct env_set *es, const char *name, const int value, const int i)
setenv_int_i	misc.h	/^void setenv_int_i(struct env_set *es, const char *name, const int value, const int i);$/;"	p	signature:(struct env_set *es, const char *name, const int value, const int i)
setenv_link_socket_actual	socket.c	/^setenv_link_socket_actual(struct env_set *es,$/;"	f	signature:(struct env_set *es, const char *name_prefix, const struct link_socket_actual *act, const unsigned int flags)
setenv_link_socket_actual	socket.h	/^void setenv_link_socket_actual(struct env_set *es,$/;"	p	signature:(struct env_set *es, const char *name_prefix, const struct link_socket_actual *act, const unsigned int flags)
setenv_route	route.c	/^setenv_route(struct env_set *es, const struct route_ipv4 *r, int i)$/;"	f	file:	signature:(struct env_set *es, const struct route_ipv4 *r, int i)
setenv_route_addr	route.c	/^setenv_route_addr(struct env_set *es, const char *key, const in_addr_t addr, int i)$/;"	f	file:	signature:(struct env_set *es, const char *key, const in_addr_t addr, int i)
setenv_route_ipv6	route.c	/^setenv_route_ipv6(struct env_set *es, const struct route_ipv6 *r6, int i)$/;"	f	file:	signature:(struct env_set *es, const struct route_ipv6 *r6, int i)
setenv_routes	route.c	/^setenv_routes(struct env_set *es, const struct route_list *rl)$/;"	f	signature:(struct env_set *es, const struct route_list *rl)
setenv_routes	route.h	/^void setenv_routes(struct env_set *es, const struct route_list *rl);$/;"	p	signature:(struct env_set *es, const struct route_list *rl)
setenv_routes_ipv6	route.c	/^setenv_routes_ipv6(struct env_set *es, const struct route_ipv6_list *rl6)$/;"	f	signature:(struct env_set *es, const struct route_ipv6_list *rl6)
setenv_routes_ipv6	route.h	/^void setenv_routes_ipv6(struct env_set *es, const struct route_ipv6_list *rl6);$/;"	p	signature:(struct env_set *es, const struct route_ipv6_list *rl6)
setenv_settings	options.c	/^setenv_settings(struct env_set *es, const struct options *o)$/;"	f	signature:(struct env_set *es, const struct options *o)
setenv_settings	options.h	/^void setenv_settings(struct env_set *es, const struct options *o);$/;"	p	signature:(struct env_set *es, const struct options *o)
setenv_sockaddr	socket.c	/^setenv_sockaddr(struct env_set *es, const char *name_prefix, const struct openvpn_sockaddr *addr, const unsigned int flags)$/;"	f	signature:(struct env_set *es, const char *name_prefix, const struct openvpn_sockaddr *addr, const unsigned int flags)
setenv_sockaddr	socket.h	/^void setenv_sockaddr(struct env_set *es,$/;"	p	signature:(struct env_set *es, const char *name_prefix, const struct openvpn_sockaddr *addr, const unsigned int flags)
setenv_stats	multi.c	/^setenv_stats(struct context *c)$/;"	f	file:	signature:(struct context *c)
setenv_str	misc.c	/^setenv_str(struct env_set *es, const char *name, const char *value)$/;"	f	signature:(struct env_set *es, const char *name, const char *value)
setenv_str	misc.h	/^void setenv_str(struct env_set *es, const char *name, const char *value);$/;"	p	signature:(struct env_set *es, const char *name, const char *value)
setenv_str_ex	misc.c	/^setenv_str_ex(struct env_set *es,$/;"	f	signature:(struct env_set *es, const char *name, const char *value, const unsigned int name_include, const unsigned int name_exclude, const char name_replace, const unsigned int value_include, const unsigned int value_exclude, const char value_replace)
setenv_str_ex	misc.h	/^void setenv_str_ex(struct env_set *es,$/;"	p	signature:(struct env_set *es, const char *name, const char *value, const unsigned int name_include, const unsigned int name_exclude, const char name_replace, const unsigned int value_include, const unsigned int value_exclude, const char value_replace)
setenv_str_i	misc.c	/^setenv_str_i(struct env_set *es, const char *name, const char *value, const int i)$/;"	f	signature:(struct env_set *es, const char *name, const char *value, const int i)
setenv_str_i	misc.h	/^void setenv_str_i(struct env_set *es, const char *name, const char *value, const int i);$/;"	p	signature:(struct env_set *es, const char *name, const char *value, const int i)
setenv_str_incr	misc.c	/^setenv_str_incr(struct env_set *es, const char *name, const char *value)$/;"	f	signature:(struct env_set *es, const char *name, const char *value)
setenv_str_incr	misc.h	/^void setenv_str_incr(struct env_set *es, const char *name, const char *value);$/;"	p	signature:(struct env_set *es, const char *name, const char *value)
setenv_str_safe	misc.c	/^setenv_str_safe(struct env_set *es, const char *name, const char *value)$/;"	f	signature:(struct env_set *es, const char *name, const char *value)
setenv_str_safe	misc.h	/^void setenv_str_safe(struct env_set *es, const char *name, const char *value);$/;"	p	signature:(struct env_set *es, const char *name, const char *value)
setenv_trusted	socket.c	/^setenv_trusted(struct env_set *es, const struct link_socket_info *info)$/;"	f	signature:(struct env_set *es, const struct link_socket_info *info)
setenv_trusted	socket.h	/^void setenv_trusted(struct env_set *es, const struct link_socket_info *info);$/;"	p	signature:(struct env_set *es, const struct link_socket_info *info)
setenv_unsigned	misc.c	/^setenv_unsigned(struct env_set *es, const char *name, unsigned int value)$/;"	f	signature:(struct env_set *es, const char *name, unsigned int value)
setenv_unsigned	misc.h	/^void setenv_unsigned(struct env_set *es, const char *name, unsigned int value);$/;"	p	signature:(struct env_set *es, const char *name, unsigned int value)
setenv_untrusted	ssl_verify.c	/^setenv_untrusted(struct tls_session *session)$/;"	f	file:	signature:(struct tls_session *session)
settings	manage.h	/^    struct man_settings settings;$/;"	m	struct:management	typeref:struct:management::man_settings	access:public
setup_engine	crypto_openssl.c	/^setup_engine(const char *engine)$/;"	f	file:	signature:(const char *engine)
sf2gaf	socket.c	/^sf2gaf(const unsigned int getaddr_flags,$/;"	f	file:	signature:(const unsigned int getaddr_flags, const unsigned int sockflags)
sha256_digest	crypto.h	/^struct sha256_digest {$/;"	s
sha256_digest::digest	crypto.h	/^    uint8_t digest[SHA256_DIGEST_LENGTH];$/;"	m	struct:sha256_digest	access:public
sha256_hash	ssl_verify.h	/^    unsigned char sha256_hash[256\/8];$/;"	m	struct:cert_hash	access:public
shaper	openvpn.h	/^    struct shaper shaper;$/;"	m	struct:context_2	typeref:struct:context_2::shaper	access:public
shaper	options.h	/^    int shaper;$/;"	m	struct:options	access:public
shaper	shaper.h	/^struct shaper$/;"	s
shaper::bytes_per_second	shaper.h	/^    int bytes_per_second;$/;"	m	struct:shaper	access:public
shaper::factor	shaper.h	/^    double factor;$/;"	m	struct:shaper	access:public
shaper::factor	shaper.h	/^    int factor;$/;"	m	struct:shaper	access:public
shaper::wakeup	shaper.h	/^    struct timeval wakeup;$/;"	m	struct:shaper	typeref:struct:shaper::timeval	access:public
shaper_current_bandwidth	shaper.h	/^shaper_current_bandwidth(struct shaper *s)$/;"	f	signature:(struct shaper *s)
shaper_delay	shaper.h	/^shaper_delay(struct shaper *s)$/;"	f	signature:(struct shaper *s)
shaper_init	shaper.h	/^shaper_init(struct shaper *s, int bytes_per_second)$/;"	f	signature:(struct shaper *s, int bytes_per_second)
shaper_msg	shaper.c	/^shaper_msg(struct shaper *s)$/;"	f	signature:(struct shaper *s)
shaper_msg	shaper.h	/^void shaper_msg(struct shaper *s);$/;"	p	signature:(struct shaper *s)
shaper_reset	shaper.h	/^shaper_reset(struct shaper *s, int bytes_per_second)$/;"	f	signature:(struct shaper *s, int bytes_per_second)
shaper_reset_wakeup	shaper.c	/^shaper_reset_wakeup(struct shaper *s)$/;"	f	signature:(struct shaper *s)
shaper_reset_wakeup	shaper.h	/^void shaper_reset_wakeup(struct shaper *s);$/;"	p	signature:(struct shaper *s)
shaper_soonest_event	shaper.c	/^shaper_soonest_event(struct timeval *tv, int delay)$/;"	f	signature:(struct timeval *tv, int delay)
shaper_soonest_event	shaper.h	/^bool shaper_soonest_event(struct timeval *tv, int delay);$/;"	p	signature:(struct timeval *tv, int delay)
shaper_wrote_bytes	shaper.h	/^shaper_wrote_bytes(struct shaper *s, int nbytes)$/;"	f	signature:(struct shaper *s, int nbytes)
shared_secret_file	options.h	/^    const char *shared_secret_file;$/;"	m	struct:options	access:public
shared_secret_file_inline	options.h	/^    const char *shared_secret_file_inline;$/;"	m	struct:options	access:public
short_form	socket.c	/^    const char *short_form;$/;"	m	struct:proto_names	file:	access:public
short_form	tun.c	/^    const char *short_form;$/;"	m	struct:ipset_names	file:	access:public
show_adapter	tun.c	/^show_adapter(int msglev, const IP_ADAPTER_INFO *a, struct gc_arena *gc)$/;"	f	file:	signature:(int msglev, const IP_ADAPTER_INFO *a, struct gc_arena *gc)
show_adapters	tun.c	/^show_adapters(int msglev)$/;"	f	signature:(int msglev)
show_adapters	tun.h	/^void show_adapters(int msglev);$/;"	p	signature:(int msglev)
show_available_ciphers	crypto_backend.h	/^void show_available_ciphers(void);$/;"	p	signature:(void)
show_available_ciphers	crypto_mbedtls.c	/^show_available_ciphers(void)$/;"	f	signature:(void)
show_available_ciphers	crypto_openssl.c	/^show_available_ciphers(void)$/;"	f	signature:(void)
show_available_curves	ssl_backend.h	/^void show_available_curves(void);$/;"	p	signature:(void)
show_available_curves	ssl_mbedtls.c	/^show_available_curves(void)$/;"	f	signature:(void)
show_available_curves	ssl_openssl.c	/^show_available_curves(void)$/;"	f	signature:(void)
show_available_digests	crypto_backend.h	/^void show_available_digests(void);$/;"	p	signature:(void)
show_available_digests	crypto_mbedtls.c	/^show_available_digests(void)$/;"	f	signature:(void)
show_available_digests	crypto_openssl.c	/^show_available_digests(void)$/;"	f	signature:(void)
show_available_engines	crypto_backend.h	/^void show_available_engines(void);$/;"	p	signature:(void)
show_available_engines	crypto_mbedtls.c	/^show_available_engines(void)$/;"	f	signature:(void)
show_available_engines	crypto_openssl.c	/^show_available_engines(void)$/;"	f	signature:(void)
show_available_tls_ciphers	ssl.c	/^show_available_tls_ciphers(const char *cipher_list,$/;"	f	signature:(const char *cipher_list, const char *cipher_list_tls13, const char *tls_cert_profile)
show_available_tls_ciphers	ssl.h	/^show_available_tls_ciphers(const char *cipher_list,$/;"	p	signature:(const char *cipher_list, const char *cipher_list_tls13, const char *tls_cert_profile)
show_available_tls_ciphers_list	ssl_backend.h	/^show_available_tls_ciphers_list(const char *cipher_list,$/;"	p	signature:(const char *cipher_list, const char *tls_cert_profile, bool tls13)
show_available_tls_ciphers_list	ssl_mbedtls.c	/^show_available_tls_ciphers_list(const char *cipher_list,$/;"	f	signature:(const char *cipher_list, const char *tls_cert_profile, bool tls13)
show_available_tls_ciphers_list	ssl_openssl.c	/^show_available_tls_ciphers_list(const char *cipher_list,$/;"	f	signature:(const char *cipher_list, const char *tls_cert_profile, const bool tls13)
show_ciphers	options.h	/^    bool show_ciphers;$/;"	m	struct:options	access:public
show_connection_entries	options.c	/^show_connection_entries(const struct options *o)$/;"	f	file:	signature:(const struct options *o)
show_connection_entry	options.c	/^show_connection_entry(const struct connection_entry *o)$/;"	f	file:	signature:(const struct connection_entry *o)
show_curves	options.h	/^    bool show_curves;$/;"	m	struct:options	access:public
show_dhcp_option_addrs	options.c	/^show_dhcp_option_addrs(const char *name, const in_addr_t *array, int len)$/;"	f	file:	signature:(const char *name, const in_addr_t *array, int len)
show_digests	options.h	/^    bool show_digests;$/;"	m	struct:options	access:public
show_engines	options.h	/^    bool show_engines;$/;"	m	struct:options	access:public
show_http_proxy_options	options.c	/^show_http_proxy_options(const struct http_proxy_options *o)$/;"	f	file:	signature:(const struct http_proxy_options *o)
show_library_versions	options.c	/^show_library_versions(const unsigned int flags)$/;"	f	signature:(const unsigned int flags)
show_library_versions	options.h	/^void show_library_versions(const unsigned int flags);$/;"	p	signature:(const unsigned int flags)
show_net	manage.h	/^    void (*show_net) (void *arg, const int msglevel);$/;"	m	struct:management_callback	access:public
show_net_up	options.h	/^    bool show_net_up;$/;"	m	struct:options	access:public
show_opt	route.c	/^show_opt(const char *option)$/;"	f	file:	signature:(const char *option)
show_p2mp_parms	options.c	/^show_p2mp_parms(const struct options *o)$/;"	f	file:	signature:(const struct options *o)
show_pkcs11_ids	pkcs11.c	/^show_pkcs11_ids($/;"	f	signature:( const char *const provider, bool cert_private )
show_pkcs11_ids	pkcs11.h	/^show_pkcs11_ids($/;"	p	signature:( const char *const provider, bool cert_private )
show_pull_filter_list	options.c	/^show_pull_filter_list(const struct pull_filter_list *l)$/;"	f	file:	signature:(const struct pull_filter_list *l)
show_routes	route.c	/^show_routes(int msglev)$/;"	f	signature:(int msglev)
show_routes	route.h	/^void show_routes(int msglev);$/;"	p	signature:(int msglev)
show_settings	options.c	/^show_settings(const struct options *o)$/;"	f	signature:(const struct options *o)
show_settings	options.h	/^void show_settings(const struct options *o);$/;"	p	signature:(const struct options *o)
show_tap_win_adapters	tun.c	/^show_tap_win_adapters(int msglev, int warnlev)$/;"	f	signature:(int msglev, int warnlev)
show_tap_win_adapters	tun.h	/^void show_tap_win_adapters(int msglev, int warnlev);$/;"	p	signature:(int msglev, int warnlev)
show_tls_ciphers	options.h	/^    bool show_tls_ciphers;$/;"	m	struct:options	access:public
show_tls_performance_stats	ssl.c	/^show_tls_performance_stats(void)$/;"	f	signature:(void)
show_tls_performance_stats	ssl.h	/^void show_tls_performance_stats(void);$/;"	p	signature:(void)
show_tuntap_options	options.c	/^show_tuntap_options(const struct tuntap_options *o)$/;"	f	file:	signature:(const struct tuntap_options *o)
show_valid_win32_tun_subnets	tun.c	/^show_valid_win32_tun_subnets(void)$/;"	f	signature:(void)
show_valid_win32_tun_subnets	tun.h	/^void show_valid_win32_tun_subnets(void);$/;"	p	signature:(void)
show_wait_status	forward.c	/^show_wait_status(struct context *c)$/;"	f	signature:(struct context *c)
show_wait_status	forward.h	/^void show_wait_status(struct context *c);$/;"	p	signature:(struct context *c)
show_windows_version	options.c	/^show_windows_version(const unsigned int flags)$/;"	f	signature:(const unsigned int flags)
show_windows_version	options.h	/^void show_windows_version(const unsigned int flags);$/;"	p	signature:(const unsigned int flags)
siaddr	dhcp.h	/^    uint32_t siaddr;   \/* server IP address *\/$/;"	m	struct:dhcp	access:public
sig	openvpn.h	/^    struct signal_info *sig;    \/**< Internal error signaling object. *\/$/;"	m	struct:context	typeref:struct:context::signal_info	access:public
siginfo_static	sig.c	/^struct signal_info siginfo_static; \/* GLOBAL *\/$/;"	v	typeref:struct:signal_info
signal_description	sig.c	/^signal_description(const int signum, const char *sigtext)$/;"	f	signature:(const int signum, const char *sigtext)
signal_description	sig.h	/^const char *signal_description(const int signum, const char *sigtext);$/;"	p	signature:(const int signum, const char *sigtext)
signal_handler	sig.c	/^signal_handler(const int signum)$/;"	f	file:	signature:(const int signum)
signal_info	sig.h	/^struct signal_info$/;"	s
signal_info::signal_received	sig.h	/^    volatile int signal_received;$/;"	m	struct:signal_info	access:public
signal_info::signal_text	sig.h	/^    const char *signal_text;$/;"	m	struct:signal_info	access:public
signal_info::source	sig.h	/^    volatile int source;$/;"	m	struct:signal_info	access:public
signal_mode	sig.c	/^static int signal_mode; \/* GLOBAL *\/$/;"	v	file:
signal_name	sig.c	/^signal_name(const int sig, const bool upper)$/;"	f	signature:(const int sig, const bool upper)
signal_name	sig.h	/^const char *signal_name(const int sig, const bool upper);$/;"	p	signature:(const int sig, const bool upper)
signal_received	multi.h	/^    int signal_received;$/;"	m	struct:deferred_signal_schedule_entry	access:public
signal_received	sig.h	/^    volatile int signal_received;$/;"	m	struct:signal_info	access:public
signal_reset	sig.c	/^signal_reset(struct signal_info *si)$/;"	f	file:	signature:(struct signal_info *si)
signal_restart_status	sig.c	/^signal_restart_status(const struct signal_info *si)$/;"	f	signature:(const struct signal_info *si)
signal_restart_status	sig.h	/^void signal_restart_status(const struct signal_info *si);$/;"	p	signature:(const struct signal_info *si)
signal_text	sig.h	/^    const char *signal_text;$/;"	m	struct:signal_info	access:public
signame	sig.c	/^struct signame {$/;"	s	file:
signame::lower	sig.c	/^    const char *lower;$/;"	m	struct:signame	file:	access:public
signame::upper	sig.c	/^    const char *upper;$/;"	m	struct:signame	file:	access:public
signame::value	sig.c	/^    int value;$/;"	m	struct:signame	file:	access:public
signames	sig.c	/^static const struct signame signames[] = {$/;"	v	typeref:struct:signame	file:
signature_length	ssl_mbedtls.c	/^    size_t signature_length;$/;"	m	struct:external_context	file:	access:public
single_session	options.h	/^    bool single_session;$/;"	m	struct:options	access:public
single_session	ssl_common.h	/^    bool single_session;$/;"	m	struct:tls_options	access:public
size	buffer.h	/^    int size;                \/* current number of entries *\/$/;"	m	struct:buffer_list	access:public
size	manage.h	/^    int size;$/;"	m	struct:log_history	access:public
size	options.c	/^    int size;$/;"	m	struct:pull_filter	file:	access:public
size	pool.h	/^    int size;$/;"	m	struct:ifconfig_pool	access:public
size	reliable.h	/^    int size;$/;"	m	struct:reliable	access:public
size	win32.h	/^    DWORD size;$/;"	m	struct:overlapped_io	access:public
size_ipv6	pool.h	/^    unsigned int size_ipv6;$/;"	m	struct:ifconfig_pool	access:public
sk_x509_name_cmp	ssl_openssl.c	/^sk_x509_name_cmp(const X509_NAME *const *a, const X509_NAME *const *b)$/;"	f	file:	signature:(const X509_NAME *const *a, const X509_NAME *const *b)
skip_leading_whitespace	buffer.c	/^skip_leading_whitespace(const char *str)$/;"	f	signature:(const char *str)
skip_leading_whitespace	buffer.h	/^const char *skip_leading_whitespace(const char *str);$/;"	p	signature:(const char *str)
sleep	syshead.h	42;"	d
sname	dhcp.h	/^    uint8_t sname[64]; \/* optional server host name *\/$/;"	m	struct:dhcp	access:public
sndbuf	options.h	/^    int sndbuf;$/;"	m	struct:options	access:public
sndbuf	socket.h	/^    int sndbuf;$/;"	m	struct:socket_buffer_size	access:public
sns	pf.h	/^    struct pf_subnet_set sns;$/;"	m	struct:pf_set	typeref:struct:pf_set::pf_subnet_set	access:public
so_pathname	plugin.h	/^    const char *so_pathname;$/;"	m	struct:plugin	access:public
so_pathname	plugin.h	/^    const char *so_pathname;$/;"	m	struct:plugin_option	access:public
sock	mtcp.c	/^    unsigned int sock;$/;"	m	struct:ta_iow_flags	file:	access:public
sockaddr_unix_init	socket.c	/^sockaddr_unix_init(struct sockaddr_un *local, const char *path)$/;"	f	signature:(struct sockaddr_un *local, const char *path)
sockaddr_unix_init	socket.h	/^void sockaddr_unix_init(struct sockaddr_un *local, const char *path);$/;"	p	signature:(struct sockaddr_un *local, const char *path)
sockaddr_unix_name	socket.c	/^sockaddr_unix_name(const struct sockaddr_un *local, const char *null)$/;"	f	signature:(const struct sockaddr_un *local, const char *null)
sockaddr_unix_name	socket.h	/^const char *sockaddr_unix_name(const struct sockaddr_un *local, const char *null);$/;"	p	signature:(const struct sockaddr_un *local, const char *null)
socket_accept_unix	socket.c	/^socket_accept_unix(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, struct sockaddr_un *remote)
socket_accept_unix	socket.h	/^socket_descriptor_t socket_accept_unix(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, struct sockaddr_un *remote)
socket_adjust_frame_parameters	socket.c	/^socket_adjust_frame_parameters(struct frame *frame, int proto)$/;"	f	signature:(struct frame *frame, int proto)
socket_adjust_frame_parameters	socket.h	/^void socket_adjust_frame_parameters(struct frame *frame, int proto);$/;"	p	signature:(struct frame *frame, int proto)
socket_bind	socket.c	/^socket_bind(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, struct addrinfo *local, int ai_family, const char *prefix, bool ipv6only)
socket_bind	socket.h	/^void socket_bind(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, struct addrinfo *local, int af_family, const char *prefix, bool ipv6only)
socket_bind_unix	socket.c	/^socket_bind_unix(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, struct sockaddr_un *local, const char *prefix)
socket_bind_unix	socket.h	/^void socket_bind_unix(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, struct sockaddr_un *local, const char *prefix)
socket_buffer_size	socket.h	/^struct socket_buffer_size$/;"	s
socket_buffer_size::rcvbuf	socket.h	/^    int rcvbuf;$/;"	m	struct:socket_buffer_size	access:public
socket_buffer_size::sndbuf	socket.h	/^    int sndbuf;$/;"	m	struct:socket_buffer_size	access:public
socket_buffer_sizes	socket.h	/^    struct socket_buffer_size socket_buffer_sizes;$/;"	m	struct:link_socket	typeref:struct:link_socket::socket_buffer_size	access:public
socket_connect	socket.c	/^socket_connect(socket_descriptor_t *sd,$/;"	f	file:	signature:(socket_descriptor_t *sd, const struct sockaddr *dest, const int connect_timeout, struct signal_info *sig_info)
socket_connect_unix	socket.c	/^socket_connect_unix(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, struct sockaddr_un *remote)
socket_connect_unix	socket.h	/^int socket_connect_unix(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, struct sockaddr_un *remote)
socket_connection_reset	socket.h	/^socket_connection_reset(const struct link_socket *sock, int status)$/;"	f	signature:(const struct link_socket *sock, int status)
socket_defined	syshead.h	/^socket_defined(const socket_descriptor_t sd)$/;"	f	signature:(const socket_descriptor_t sd)
socket_delete_unix	socket.c	/^socket_delete_unix(const struct sockaddr_un *local)$/;"	f	signature:(const struct sockaddr_un *local)
socket_delete_unix	socket.h	/^void socket_delete_unix(const struct sockaddr_un *local);$/;"	p	signature:(const struct sockaddr_un *local)
socket_descriptor_t	syshead.h	/^typedef SOCKET socket_descriptor_t;$/;"	t
socket_descriptor_t	syshead.h	/^typedef int socket_descriptor_t;$/;"	t
socket_do_accept	socket.c	/^socket_do_accept(socket_descriptor_t sd,$/;"	f	signature:(socket_descriptor_t sd, struct link_socket_actual *act, const bool nowait)
socket_do_accept	socket.h	/^socket_descriptor_t socket_do_accept(socket_descriptor_t sd,$/;"	p	signature:(socket_descriptor_t sd, struct link_socket_actual *act, const bool nowait)
socket_do_listen	socket.c	/^socket_do_listen(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, const struct addrinfo *local, bool do_listen, bool do_set_nonblock)
socket_event_handle	socket.h	/^socket_event_handle(const struct link_socket *s)$/;"	f	signature:(const struct link_socket *s)
socket_finalize	socket.c	/^socket_finalize(SOCKET s,$/;"	f	signature:(SOCKET s, struct overlapped_io *io, struct buffer *buf, struct link_socket_actual *from)
socket_finalize	socket.h	/^int socket_finalize($/;"	p	signature:( SOCKET s, struct overlapped_io *io, struct buffer *buf, struct link_socket_actual *from)
socket_foreign_protocol_detected	socket.h	/^socket_foreign_protocol_detected(const struct link_socket *sock)$/;"	f	signature:(const struct link_socket *sock)
socket_foreign_protocol_head	socket.h	/^socket_foreign_protocol_head(const struct link_socket *sock)$/;"	f	signature:(const struct link_socket *sock)
socket_foreign_protocol_sd	socket.h	/^socket_foreign_protocol_sd(const struct link_socket *sock)$/;"	f	signature:(const struct link_socket *sock)
socket_frame_init	socket.c	/^socket_frame_init(const struct frame *frame, struct link_socket *sock)$/;"	f	file:	signature:(const struct frame *frame, struct link_socket *sock)
socket_get_rcvbuf	socket.c	/^socket_get_rcvbuf(int sd)$/;"	f	file:	signature:(int sd)
socket_get_sndbuf	socket.c	/^socket_get_sndbuf(int sd)$/;"	f	file:	signature:(int sd)
socket_listen_accept	socket.c	/^socket_listen_accept(socket_descriptor_t sd,$/;"	f	file:	signature:(socket_descriptor_t sd, struct link_socket_actual *act, const char *remote_dynamic, const struct addrinfo *local, bool do_listen, bool nowait, volatile int *signal_received)
socket_listen_event_handle	socket.c	/^socket_listen_event_handle(struct link_socket *s)$/;"	f	signature:(struct link_socket *s)
socket_listen_event_handle	socket.h	/^event_t socket_listen_event_handle(struct link_socket *s);$/;"	p	signature:(struct link_socket *s)
socket_read_residual	socket.h	/^socket_read_residual(const struct link_socket *s)$/;"	f	signature:(const struct link_socket *s)
socket_recv_queue	socket.c	/^socket_recv_queue(struct link_socket *sock, int maxsize)$/;"	f	signature:(struct link_socket *sock, int maxsize)
socket_recv_queue	socket.h	/^int socket_recv_queue(struct link_socket *sock, int maxsize);$/;"	p	signature:(struct link_socket *sock, int maxsize)
socket_reset_listen_persistent	socket.h	/^socket_reset_listen_persistent(struct link_socket *s)$/;"	f	signature:(struct link_socket *s)
socket_restart_pause	init.c	/^socket_restart_pause(struct context *c)$/;"	f	file:	signature:(struct context *c)
socket_send_queue	socket.c	/^socket_send_queue(struct link_socket *sock, struct buffer *buf, const struct link_socket_actual *to)$/;"	f	signature:(struct link_socket *sock, struct buffer *buf, const struct link_socket_actual *to)
socket_send_queue	socket.h	/^int socket_send_queue(struct link_socket *sock,$/;"	p	signature:(struct link_socket *sock, struct buffer *buf, const struct link_socket_actual *to)
socket_set	socket.c	/^socket_set(struct link_socket *s,$/;"	f	signature:(struct link_socket *s, struct event_set *es, unsigned int rwflags, void *arg, unsigned int *persistent)
socket_set	socket.h	/^socket_set(struct link_socket *s,$/;"	p	signature:(struct link_socket *s, struct event_set *es, unsigned int rwflags, void *arg, unsigned int *persistent)
socket_set_buffers	socket.c	/^socket_set_buffers(int fd, const struct socket_buffer_size *sbs)$/;"	f	file:	signature:(int fd, const struct socket_buffer_size *sbs)
socket_set_called	multi.h	/^    bool socket_set_called;$/;"	m	struct:multi_instance	access:public
socket_set_flags	socket.c	/^socket_set_flags(int sd, unsigned int sockflags)$/;"	f	file:	signature:(int sd, unsigned int sockflags)
socket_set_listen_persistent	socket.h	/^socket_set_listen_persistent(struct link_socket *s,$/;"	f	signature:(struct link_socket *s, struct event_set *es, void *arg)
socket_set_mark	socket.c	/^socket_set_mark(int sd, int mark)$/;"	f	file:	signature:(int sd, int mark)
socket_set_rcvbuf	socket.c	/^socket_set_rcvbuf(int sd, int size)$/;"	f	file:	signature:(int sd, int size)
socket_set_sndbuf	socket.c	/^socket_set_sndbuf(int sd, int size)$/;"	f	file:	signature:(int sd, int size)
socket_set_tcp_nodelay	socket.c	/^socket_set_tcp_nodelay(int sd, int state)$/;"	f	file:	signature:(int sd, int state)
socket_stat	socket.c	/^socket_stat(const struct link_socket *s, unsigned int rwflags, struct gc_arena *gc)$/;"	f	signature:(const struct link_socket *s, unsigned int rwflags, struct gc_arena *gc)
socket_stat	socket.h	/^const char *socket_stat(const struct link_socket *s, unsigned int rwflags, struct gc_arena *gc);$/;"	p	signature:(const struct link_socket *s, unsigned int rwflags, struct gc_arena *gc)
sockflags	options.h	/^    unsigned int sockflags;$/;"	m	struct:options	access:public
sockflags	socket.h	/^    unsigned int sockflags;$/;"	m	struct:link_socket	access:public
socks_adjust_frame_parameters	socks.c	/^socks_adjust_frame_parameters(struct frame *frame, int proto)$/;"	f	signature:(struct frame *frame, int proto)
socks_adjust_frame_parameters	socks.h	/^void socks_adjust_frame_parameters(struct frame *frame, int proto);$/;"	p	signature:(struct frame *frame, int proto)
socks_handshake	socks.c	/^socks_handshake(struct socks_proxy_info *p,$/;"	f	file:	signature:(struct socks_proxy_info *p, socket_descriptor_t sd, volatile int *signal_received)
socks_postprocess_incoming_link	forward.c	/^socks_postprocess_incoming_link(struct context *c)$/;"	f	file:	signature:(struct context *c)
socks_preprocess_outgoing_link	forward.c	/^socks_preprocess_outgoing_link(struct context *c,$/;"	f	file:	signature:(struct context *c, struct link_socket_actual **to_addr, int *size_delta)
socks_process_incoming_udp	socks.c	/^socks_process_incoming_udp(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, struct link_socket_actual *from)
socks_process_incoming_udp	socks.h	/^void socks_process_incoming_udp(struct buffer *buf,$/;"	p	signature:(struct buffer *buf, struct link_socket_actual *from)
socks_process_outgoing_udp	socks.c	/^socks_process_outgoing_udp(struct buffer *buf,$/;"	f	signature:(struct buffer *buf, const struct link_socket_actual *to)
socks_process_outgoing_udp	socks.h	/^int socks_process_outgoing_udp(struct buffer *buf,$/;"	p	signature:(struct buffer *buf, const struct link_socket_actual *to)
socks_proxy	openvpn.h	/^    struct socks_proxy_info *socks_proxy;$/;"	m	struct:context_1	typeref:struct:context_1::socks_proxy_info	access:public
socks_proxy	socket.h	/^    struct socks_proxy_info *socks_proxy;$/;"	m	struct:link_socket	typeref:struct:link_socket::socks_proxy_info	access:public
socks_proxy_authfile	options.h	/^    const char *socks_proxy_authfile;$/;"	m	struct:connection_entry	access:public
socks_proxy_close	socks.c	/^socks_proxy_close(struct socks_proxy_info *sp)$/;"	f	signature:(struct socks_proxy_info *sp)
socks_proxy_close	socks.h	/^void socks_proxy_close(struct socks_proxy_info *sp);$/;"	p	signature:(struct socks_proxy_info *sp)
socks_proxy_info	socks.h	/^struct socks_proxy_info {$/;"	s
socks_proxy_info::authfile	socks.h	/^    char authfile[256];$/;"	m	struct:socks_proxy_info	access:public
socks_proxy_info::defined	socks.h	/^    bool defined;$/;"	m	struct:socks_proxy_info	access:public
socks_proxy_info::port	socks.h	/^    const char *port;$/;"	m	struct:socks_proxy_info	access:public
socks_proxy_info::server	socks.h	/^    char server[128];$/;"	m	struct:socks_proxy_info	access:public
socks_proxy_new	socks.c	/^socks_proxy_new(const char *server,$/;"	f	signature:(const char *server, const char *port, const char *authfile)
socks_proxy_new	socks.h	/^struct socks_proxy_info *socks_proxy_new(const char *server,$/;"	p	signature:(const char *server, const char *port, const char *authfile)
socks_proxy_owned	openvpn.h	/^    bool socks_proxy_owned;$/;"	m	struct:context_1	access:public
socks_proxy_port	options.h	/^    const char *socks_proxy_port;$/;"	m	struct:connection_entry	access:public
socks_proxy_server	options.h	/^    const char *socks_proxy_server;$/;"	m	struct:connection_entry	access:public
socks_relay	socket.h	/^    struct link_socket_actual socks_relay; \/* Socks UDP relay address *\/$/;"	m	struct:link_socket	typeref:struct:link_socket::link_socket_actual	access:public
socks_username_password_auth	socks.c	/^socks_username_password_auth(struct socks_proxy_info *p,$/;"	f	file:	signature:(struct socks_proxy_info *p, socket_descriptor_t sd, volatile int *signal_received)
sofar	perf.c	/^    double sofar;$/;"	m	struct:perf	file:	access:public
solaris_close_tun	tun.c	/^solaris_close_tun(struct tuntap *tt)$/;"	f	file:	signature:(struct tuntap *tt)
solaris_error_close	tun.c	/^solaris_error_close(struct tuntap *tt, const struct env_set *es,$/;"	f	file:	signature:(struct tuntap *tt, const struct env_set *es, const char *actual, bool unplumb_inet6 )
solaris_error_close	tun.c	/^static void solaris_error_close(struct tuntap *tt, const struct env_set *es, const char *actual, bool unplumb_inet6);$/;"	p	file:	signature:(struct tuntap *tt, const struct env_set *es, const char *actual, bool unplumb_inet6)
source	proto.h	/^    uint16_t source;       \/* source port *\/$/;"	m	struct:openvpn_tcphdr	access:public
source	proto.h	/^    uint16_t source;$/;"	m	struct:openvpn_udphdr	access:public
source	proto.h	/^    uint8_t source[OPENVPN_ETH_ALEN]; \/* source ethernet addr   *\/$/;"	m	struct:openvpn_ethhdr	access:public
source	sig.h	/^    volatile int source;$/;"	m	struct:signal_info	access:public
space	options.c	/^space(unsigned char c)$/;"	f	file:	signature:(unsigned char c)
spec	route.h	/^    struct route_special_addr spec;$/;"	m	struct:route_list	typeref:struct:route_list::route_special_addr	access:public
spec_flags	route.h	/^    unsigned int spec_flags;            \/* RTSA_ flags, route_special_addr *\/$/;"	m	struct:route_ipv6_list	access:public
special_state_msg	manage.h	/^    const char *special_state_msg;$/;"	m	struct:man_persist	access:public
srandom	syshead.h	44;"	d
sru	schedule.c	/^    int sru;$/;"	m	struct:status	file:	access:public
ssl	ssl_openssl.h	/^    SSL *ssl;                   \/* SSL object -- new obj created for each new key *\/$/;"	m	struct:key_state_ssl	access:public
ssl_bio	ssl_openssl.h	/^    BIO *ssl_bio;                       \/* read\/write plaintext from here *\/$/;"	m	struct:key_state_ssl	access:public
ssl_bio_read	ssl_mbedtls.c	/^ssl_bio_read( void *ctx, unsigned char *out, size_t out_len)$/;"	f	file:	signature:( void *ctx, unsigned char *out, size_t out_len)
ssl_bio_write	ssl_mbedtls.c	/^ssl_bio_write( void *ctx, const unsigned char *in, size_t in_len)$/;"	f	file:	signature:( void *ctx, const unsigned char *in, size_t in_len)
ssl_clean_auth_token	ssl.c	/^ssl_clean_auth_token (void)$/;"	f	signature:(void)
ssl_clean_auth_token	ssl.h	/^bool ssl_clean_auth_token(void);$/;"	p	signature:(void)
ssl_config	ssl_mbedtls.h	/^    mbedtls_ssl_config ssl_config;      \/**< mbedTLS global ssl config *\/$/;"	m	struct:key_state_ssl	access:public
ssl_ctx	openvpn.h	/^    struct tls_root_ctx ssl_ctx;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::tls_root_ctx	access:public
ssl_ctx	ssl_common.h	/^    struct tls_root_ctx ssl_ctx;$/;"	m	struct:tls_options	typeref:struct:tls_options::tls_root_ctx	access:public
ssl_default_options_string	ssl.c	/^static const char ssl_default_options_string[] = "V0 UNDEF";$/;"	v	file:
ssl_flags	options.h	/^    unsigned int ssl_flags; \/* set to SSLF_x flags from ssl.h *\/$/;"	m	struct:options	access:public
ssl_flags	ssl_common.h	/^    unsigned int ssl_flags;$/;"	m	struct:tls_options	access:public
ssl_purge_auth	ssl.c	/^ssl_purge_auth(const bool auth_user_pass_only)$/;"	f	signature:(const bool auth_user_pass_only)
ssl_purge_auth	ssl.h	/^void ssl_purge_auth(const bool auth_user_pass_only);$/;"	p	signature:(const bool auth_user_pass_only)
ssl_purge_auth_challenge	ssl.c	/^ssl_purge_auth_challenge(void)$/;"	f	signature:(void)
ssl_purge_auth_challenge	ssl.h	/^void ssl_purge_auth_challenge(void);$/;"	p	signature:(void)
ssl_put_auth_challenge	ssl.c	/^ssl_put_auth_challenge(const char *cr_str)$/;"	f	signature:(const char *cr_str)
ssl_put_auth_challenge	ssl.h	/^void ssl_put_auth_challenge(const char *cr_str);$/;"	p	signature:(const char *cr_str)
ssl_set_auth_nocache	ssl.c	/^ssl_set_auth_nocache(void)$/;"	f	signature:(void)
ssl_set_auth_nocache	ssl.h	/^void ssl_set_auth_nocache(void);$/;"	p	signature:(void)
ssl_set_auth_token	ssl.c	/^ssl_set_auth_token(const char *token)$/;"	f	signature:(const char *token)
ssl_set_auth_token	ssl.h	/^void ssl_set_auth_token(const char *token);$/;"	p	signature:(const char *token)
stack	perf.c	/^    int stack[STACK_N];$/;"	m	struct:perf_set	file:	access:public
stack_len	perf.c	/^    int stack_len;$/;"	m	struct:perf_set	file:	access:public
stale_route_check_trigger	multi.c	/^stale_route_check_trigger(struct multi_context *m)$/;"	f	file:	signature:(struct multi_context *m)
stale_routes_ageing_time	options.h	/^    int stale_routes_ageing_time;$/;"	m	struct:options	access:public
stale_routes_check_et	multi.h	/^    struct event_timeout stale_routes_check_et;$/;"	m	struct:multi_context	typeref:struct:multi_context::event_timeout	access:public
stale_routes_check_interval	options.h	/^    int stale_routes_check_interval;$/;"	m	struct:options	access:public
standalone_disabled	manage.h	/^    bool standalone_disabled;$/;"	m	struct:man_persist	access:public
standby_iter	tun.h	/^    int standby_iter;$/;"	m	struct:tuntap	access:public
start	interval.h	/^    struct timeval start;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval	access:public
start	perf.c	/^    struct timeval start;$/;"	m	struct:perf	typeref:struct:perf::timeval	file:	access:public
state	manage.h	/^    int state;$/;"	m	struct:man_connection	access:public
state	manage.h	/^    int state;$/;"	m	union:log_entry_union	access:public
state	manage.h	/^    struct log_history *state;$/;"	m	struct:man_persist	typeref:struct:man_persist::log_history	access:public
state	mstats.h	/^    int state;$/;"	m	struct:mmap_stats	access:public
state	perf.c	/^    int state;$/;"	m	struct:perf	file:	access:public
state	ssl_common.h	/^    int state;$/;"	m	struct:key_state	access:public
state_buffer_size	manage.h	/^    int state_buffer_size;$/;"	m	struct:man_settings	access:public
state_id	misc.h	/^    const char *state_id;$/;"	m	struct:auth_challenge_info	access:public
state_must_be	perf.c	/^state_must_be(const struct perf *p, const int wanted)$/;"	f	file:	signature:(const struct perf *p, const int wanted)
state_name	ssl.c	/^state_name(int state)$/;"	f	file:	signature:(int state)
state_realtime	manage.h	/^    bool state_realtime;$/;"	m	struct:man_connection	access:public
static_assert	error.h	232;"	d
static_challenge_info	misc.h	/^struct static_challenge_info {$/;"	s
static_challenge_info	misc.h	/^struct static_challenge_info {};$/;"	s
static_challenge_info::challenge_text	misc.h	/^    const char *challenge_text;$/;"	m	struct:static_challenge_info	access:public
static_challenge_info::flags	misc.h	/^    unsigned int flags;$/;"	m	struct:static_challenge_info	access:public
static_context	init.c	/^static struct context *static_context; \/* GLOBAL *\/$/;"	v	typeref:struct:context	file:
static_key	openvpn.h	/^    struct key_ctx_bi static_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi	access:public
static_key_foot	crypto.c	/^static const char static_key_foot[] = "-----END OpenVPN Static key V1-----";$/;"	v	file:
static_key_head	crypto.c	/^static const char static_key_head[] = "-----BEGIN OpenVPN Static key V1-----";$/;"	v	file:
static_plugin_common	plugin.c	/^static struct plugin_common *static_plugin_common = NULL; \/* GLOBAL *\/$/;"	v	typeref:struct:plugin_common	file:
static_proxy_user_pass	proxy.c	/^static struct user_pass static_proxy_user_pass;$/;"	v	typeref:struct:user_pass	file:
status	manage.h	/^    void (*status) (void *arg, const int version, struct status_output *so);$/;"	m	struct:management_callback	access:public
status	schedule.c	/^struct status$/;"	s	file:
status	win32.h	/^    int status;$/;"	m	struct:overlapped_io	access:public
status::coll	schedule.c	/^    int coll;$/;"	m	struct:status	file:	access:public
status::ins	schedule.c	/^    int ins;$/;"	m	struct:status	file:	access:public
status::lsteps	schedule.c	/^    int lsteps;$/;"	m	struct:status	file:	access:public
status::sru	schedule.c	/^    int sru;$/;"	m	struct:status	file:	access:public
status_close	status.c	/^status_close(struct status_output *so)$/;"	f	signature:(struct status_output *so)
status_close	status.h	/^bool status_close(struct status_output *so);$/;"	p	signature:(struct status_output *so)
status_file	options.h	/^    const char *status_file;$/;"	m	struct:options	access:public
status_file_update_freq	options.h	/^    int status_file_update_freq;$/;"	m	struct:options	access:public
status_file_version	multi.h	/^    int status_file_version;$/;"	m	struct:multi_context	access:public
status_file_version	options.h	/^    int status_file_version;$/;"	m	struct:options	access:public
status_flush	status.c	/^status_flush(struct status_output *so)$/;"	f	signature:(struct status_output *so)
status_flush	status.h	/^void status_flush(struct status_output *so);$/;"	p	signature:(struct status_output *so)
status_open	status.c	/^status_open(const char *filename,$/;"	f	signature:(const char *filename, const int refresh_freq, const int msglevel, const struct virtual_output *vout, const unsigned int flags)
status_open	status.h	/^struct status_output *status_open(const char *filename,$/;"	p	signature:(const char *filename, const int refresh_freq, const int msglevel, const struct virtual_output *vout, const unsigned int flags)
status_output	openvpn.h	/^    struct status_output *status_output;$/;"	m	struct:context_1	typeref:struct:context_1::status_output	access:public
status_output	status.h	/^struct status_output$/;"	s
status_output::errors	status.h	/^    bool errors;$/;"	m	struct:status_output	access:public
status_output::et	status.h	/^    struct event_timeout et;$/;"	m	struct:status_output	typeref:struct:status_output::event_timeout	access:public
status_output::fd	status.h	/^    int fd;$/;"	m	struct:status_output	access:public
status_output::filename	status.h	/^    char *filename;$/;"	m	struct:status_output	access:public
status_output::flags	status.h	/^    unsigned int flags;$/;"	m	struct:status_output	access:public
status_output::msglevel	status.h	/^    int msglevel;$/;"	m	struct:status_output	access:public
status_output::read_buf	status.h	/^    struct buffer read_buf;$/;"	m	struct:status_output	typeref:struct:status_output::buffer	access:public
status_output::vout	status.h	/^    const struct virtual_output *vout;$/;"	m	struct:status_output	typeref:struct:status_output::virtual_output	access:public
status_output_owned	openvpn.h	/^    bool status_output_owned;$/;"	m	struct:context_1	access:public
status_printf	status.c	/^status_printf(struct status_output *so, const char *format, ...)$/;"	f	signature:(struct status_output *so, const char *format, ...)
status_printf	status.h	/^void status_printf(struct status_output *so, const char *format, ...)$/;"	p	signature:(struct status_output *so, const char *format, ...)
status_read	status.c	/^status_read(struct status_output *so, struct buffer *buf)$/;"	f	signature:(struct status_output *so, struct buffer *buf)
status_read	status.h	/^bool status_read(struct status_output *so, struct buffer *buf);$/;"	p	signature:(struct status_output *so, struct buffer *buf)
status_reset	status.c	/^status_reset(struct status_output *so)$/;"	f	signature:(struct status_output *so)
status_reset	status.h	/^void status_reset(struct status_output *so);$/;"	p	signature:(struct status_output *so)
status_rw_flags	status.h	/^status_rw_flags(const struct status_output *so)$/;"	f	signature:(const struct status_output *so)
status_trigger	status.c	/^status_trigger(struct status_output *so)$/;"	f	signature:(struct status_output *so)
status_trigger	status.h	/^bool status_trigger(struct status_output *so);$/;"	p	signature:(struct status_output *so)
status_trigger_tv	status.c	/^status_trigger_tv(struct status_output *so, struct timeval *tv)$/;"	f	signature:(struct status_output *so, struct timeval *tv)
status_trigger_tv	status.h	/^bool status_trigger_tv(struct status_output *so, struct timeval *tv);$/;"	p	signature:(struct status_output *so, struct timeval *tv)
std_redir	error.c	/^static bool std_redir;      \/* GLOBAL *\/$/;"	v	file:
store_proxy_authenticate	proxy.c	/^store_proxy_authenticate(struct http_proxy_info *p, char *data)$/;"	f	file:	signature:(struct http_proxy_info *p, char *data)
stream_buf	socket.h	/^    struct stream_buf stream_buf;$/;"	m	struct:link_socket	typeref:struct:link_socket::stream_buf	access:public
stream_buf	socket.h	/^struct stream_buf$/;"	s
stream_buf::buf	socket.h	/^    struct buffer buf;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
stream_buf::buf_init	socket.h	/^    struct buffer buf_init;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
stream_buf::error	socket.h	/^    bool error; \/* if true, fatal TCP error has occurred,$/;"	m	struct:stream_buf	access:public
stream_buf::len	socket.h	/^    int len;   \/* -1 if not yet known *\/$/;"	m	struct:stream_buf	access:public
stream_buf::maxlen	socket.h	/^    int maxlen;$/;"	m	struct:stream_buf	access:public
stream_buf::next	socket.h	/^    struct buffer next;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
stream_buf::port_share_state	socket.h	/^    int port_share_state;$/;"	m	struct:stream_buf	access:public
stream_buf::residual	socket.h	/^    struct buffer residual;$/;"	m	struct:stream_buf	typeref:struct:stream_buf::buffer	access:public
stream_buf::residual_fully_formed	socket.h	/^    bool residual_fully_formed;$/;"	m	struct:stream_buf	access:public
stream_buf_added	socket.c	/^stream_buf_added(struct stream_buf *sb,$/;"	f	signature:(struct stream_buf *sb, int length_added)
stream_buf_added	socket.h	/^bool stream_buf_added(struct stream_buf *sb, int length_added);$/;"	p	signature:(struct stream_buf *sb, int length_added)
stream_buf_close	socket.c	/^stream_buf_close(struct stream_buf *sb)$/;"	f	signature:(struct stream_buf *sb)
stream_buf_close	socket.h	/^void stream_buf_close(struct stream_buf *sb);$/;"	p	signature:(struct stream_buf *sb)
stream_buf_data	socket.h	/^    struct buffer stream_buf_data;$/;"	m	struct:link_socket	typeref:struct:link_socket::buffer	access:public
stream_buf_get_final	socket.c	/^stream_buf_get_final(struct stream_buf *sb, struct buffer *buf)$/;"	f	file:	signature:(struct stream_buf *sb, struct buffer *buf)
stream_buf_get_next	socket.c	/^stream_buf_get_next(struct stream_buf *sb, struct buffer *buf)$/;"	f	file:	signature:(struct stream_buf *sb, struct buffer *buf)
stream_buf_init	socket.c	/^stream_buf_init(struct stream_buf *sb,$/;"	f	signature:(struct stream_buf *sb, struct buffer *buf, const unsigned int sockflags, const int proto)
stream_buf_init	socket.h	/^void stream_buf_init(struct stream_buf *sb,$/;"	p	signature:(struct stream_buf *sb, struct buffer *buf, const unsigned int sockflags, const int proto)
stream_buf_read_setup	socket.h	/^stream_buf_read_setup(struct link_socket *sock)$/;"	f	signature:(struct link_socket *sock)
stream_buf_read_setup_dowork	socket.c	/^stream_buf_read_setup_dowork(struct link_socket *sock)$/;"	f	signature:(struct link_socket *sock)
stream_buf_reset	socket.c	/^stream_buf_reset(struct stream_buf *sb)$/;"	f	file:	signature:(struct stream_buf *sb)
stream_buf_set_next	socket.c	/^stream_buf_set_next(struct stream_buf *sb)$/;"	f	file:	signature:(struct stream_buf *sb)
stream_reset	socket.h	/^    bool stream_reset;$/;"	m	struct:link_socket	access:public
streq	options.h	616;"	d
streqnull	socket.c	/^streqnull(const char *a, const char *b)$/;"	f	file:	signature:(const char *a, const char *b)
strerror_win32	error.c	/^strerror_win32(DWORD errnum, struct gc_arena *gc)$/;"	f	signature:(DWORD errnum, struct gc_arena *gc)
strerror_win32	error.h	/^const char *strerror_win32(DWORD errnum, struct gc_arena *gc);$/;"	p	signature:(DWORD errnum, struct gc_arena *gc)
string	manage.h	/^    const char *string;$/;"	m	struct:log_entry	access:public
string	misc.h	/^    char *string;$/;"	m	struct:env_item	access:public
string_alloc	buffer.h	/^char *string_alloc(const char *str, struct gc_arena *gc);$/;"	p	signature:(const char *str, struct gc_arena *gc)
string_alloc	buffer.h	159;"	d
string_alloc_buf	buffer.h	/^struct buffer string_alloc_buf(const char *str, struct gc_arena *gc);$/;"	p	signature:(const char *str, struct gc_arena *gc)
string_alloc_buf	buffer.h	160;"	d
string_alloc_buf_debug	buffer.c	/^string_alloc_buf_debug(const char *str, struct gc_arena *gc, const char *file, int line)$/;"	f	signature:(const char *str, struct gc_arena *gc, const char *file, int line)
string_alloc_buf_debug	buffer.h	/^struct buffer string_alloc_buf_debug(const char *str, struct gc_arena *gc, const char *file, int line);$/;"	p	signature:(const char *str, struct gc_arena *gc, const char *file, int line)
string_alloc_debug	buffer.c	/^string_alloc_debug(const char *str, struct gc_arena *gc, const char *file, int line)$/;"	f	signature:(const char *str, struct gc_arena *gc, const char *file, int line)
string_alloc_debug	buffer.h	/^char *string_alloc_debug(const char *str, struct gc_arena *gc, const char *file, int line);$/;"	p	signature:(const char *str, struct gc_arena *gc, const char *file, int line)
string_array_len	buffer.c	/^string_array_len(const char **array)$/;"	f	signature:(const char **array)
string_array_len	buffer.h	/^int string_array_len(const char **array);$/;"	p	signature:(const char **array)
string_class	buffer.c	/^string_class(const char *str, const unsigned int inclusive, const unsigned int exclusive)$/;"	f	signature:(const char *str, const unsigned int inclusive, const unsigned int exclusive)
string_class	buffer.h	/^bool string_class(const char *str, const unsigned int inclusive, const unsigned int exclusive);$/;"	p	signature:(const char *str, const unsigned int inclusive, const unsigned int exclusive)
string_clear	buffer.c	/^string_clear(char *str)$/;"	f	signature:(char *str)
string_clear	buffer.h	/^void string_clear(char *str);$/;"	p	signature:(char *str)
string_defined_equal	options.c	/^string_defined_equal(const char *s1, const char *s2)$/;"	f	signature:(const char *s1, const char *s2)
string_defined_equal	options.h	/^bool string_defined_equal(const char *s1, const char *s2);$/;"	p	signature:(const char *s1, const char *s2)
string_mod	buffer.c	/^string_mod(char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace)$/;"	f	signature:(char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace)
string_mod	buffer.h	/^bool string_mod(char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace);$/;"	p	signature:(char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace)
string_mod_const	buffer.c	/^string_mod_const(const char *str,$/;"	f	signature:(const char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace, struct gc_arena *gc)
string_mod_const	buffer.h	/^const char *string_mod_const(const char *str,$/;"	p	signature:(const char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace, struct gc_arena *gc)
string_mod_remap_name	ssl_verify.c	/^string_mod_remap_name(char *str, const unsigned int restrictive_flags)$/;"	f	file:	signature:(char *str, const unsigned int restrictive_flags)
string_null_terminate	buffer.c	/^string_null_terminate(char *str, int len, int capacity)$/;"	f	signature:(char *str, int len, int capacity)
string_null_terminate	buffer.h	/^void string_null_terminate(char *str, int len, int capacity);$/;"	p	signature:(char *str, int len, int capacity)
string_replace_leading	buffer.c	/^string_replace_leading(char *str, const char match, const char replace)$/;"	f	signature:(char *str, const char match, const char replace)
string_replace_leading	buffer.h	/^void string_replace_leading(char *str, const char match, const char replace);$/;"	p	signature:(char *str, const char match, const char replace)
string_substitute	options.c	/^string_substitute(const char *src, int from, int to, struct gc_arena *gc)$/;"	f	file:	signature:(const char *src, int from, int to, struct gc_arena *gc)
strncpynt	buffer.h	/^strncpynt(char *dest, const char *src, size_t maxlen)$/;"	f	signature:(char *dest, const char *src, size_t maxlen)
strprefix	buffer.h	/^strprefix(const char *str, const char *prefix)$/;"	f	signature:(const char *str, const char *prefix)
stub_compress	compstub.c	/^stub_compress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
stub_compress_init	compstub.c	/^stub_compress_init(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
stub_compress_uninit	compstub.c	/^stub_compress_uninit(struct compress_context *compctx)$/;"	f	file:	signature:(struct compress_context *compctx)
stub_decompress	compstub.c	/^stub_decompress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
stubv2_compress	compstub.c	/^stubv2_compress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
stubv2_decompress	compstub.c	/^stubv2_decompress(struct buffer *buf, struct buffer work,$/;"	f	file:	signature:(struct buffer *buf, struct buffer work, struct compress_context *compctx, const struct frame *frame)
sum	perf.c	/^    double sum;$/;"	m	struct:perf	file:	access:public
suppress_timestamps	error.c	/^static bool suppress_timestamps; \/* GLOBAL *\/$/;"	v	file:
suppress_timestamps	options.h	/^    bool suppress_timestamps;$/;"	m	struct:options	access:public
swap_hmac	ssl.c	/^swap_hmac(struct buffer *buf, const struct crypto_options *co, bool incoming)$/;"	f	file:	signature:(struct buffer *buf, const struct crypto_options *co, bool incoming)
system_error_message	misc.c	/^system_error_message(int stat, struct gc_arena *gc)$/;"	f	signature:(int stat, struct gc_arena *gc)
system_error_message	misc.h	/^const char *system_error_message(int, struct gc_arena *gc);$/;"	p	signature:(int, struct gc_arena *gc)
ta_iow_flags	mtcp.c	/^struct ta_iow_flags$/;"	s	file:
ta_iow_flags::flags	mtcp.c	/^    unsigned int flags;$/;"	m	struct:ta_iow_flags	file:	access:public
ta_iow_flags::ret	mtcp.c	/^    unsigned int ret;$/;"	m	struct:ta_iow_flags	file:	access:public
ta_iow_flags::sock	mtcp.c	/^    unsigned int sock;$/;"	m	struct:ta_iow_flags	file:	access:public
ta_iow_flags::tun	mtcp.c	/^    unsigned int tun;$/;"	m	struct:ta_iow_flags	file:	access:public
tail	buffer.h	/^    struct buffer_entry *tail; \/* last item pushed *\/$/;"	m	struct:buffer_list	typeref:struct:buffer_list::buffer_entry	access:public
tail	options.c	/^    struct pull_filter *tail;$/;"	m	struct:pull_filter_list	typeref:struct:pull_filter_list::pull_filter	file:	access:public
tail	pushlist.h	/^    struct push_entry *tail;$/;"	m	struct:push_list	typeref:struct:push_list::push_entry	access:public
tap_allow_nonadmin_access	tun.c	/^tap_allow_nonadmin_access(const char *dev_node)$/;"	f	signature:(const char *dev_node)
tap_allow_nonadmin_access	tun.h	/^void tap_allow_nonadmin_access(const char *dev_node);$/;"	p	signature:(const char *dev_node)
tap_allow_nonadmin_access_handle	tun.c	/^tap_allow_nonadmin_access_handle(const char *device_path, HANDLE hand)$/;"	f	file:	signature:(const char *device_path, HANDLE hand)
tap_metric_v4	win32.c	/^static int tap_metric_v4 = -1; \/* GLOBAL *\/$/;"	v	file:
tap_metric_v6	win32.c	/^static int tap_metric_v6 = -1; \/* GLOBAL *\/$/;"	v	file:
tap_reg	tun.h	/^struct tap_reg$/;"	s
tap_reg::guid	tun.h	/^    const char *guid;$/;"	m	struct:tap_reg	access:public
tap_reg::next	tun.h	/^    struct tap_reg *next;$/;"	m	struct:tap_reg	typeref:struct:tap_reg::tap_reg	access:public
tap_sleep	tun.h	/^    int tap_sleep;$/;"	m	struct:tuntap_options	access:public
tap_win_getinfo	tun.c	/^tap_win_getinfo(const struct tuntap *tt, struct gc_arena *gc)$/;"	f	signature:(const struct tuntap *tt, struct gc_arena *gc)
tap_win_getinfo	tun.h	/^const char *tap_win_getinfo(const struct tuntap *tt, struct gc_arena *gc);$/;"	p	signature:(const struct tuntap *tt, struct gc_arena *gc)
tas_last	ssl_common.h	/^    time_t tas_last;$/;"	m	struct:tls_multi	access:public
tcp	proto.h	/^        struct openvpn_tcphdr tcp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_tcphdr	access:public
tcp_connection_established	socket.c	/^tcp_connection_established(const struct link_socket_actual *act)$/;"	f	file:	signature:(const struct link_socket_actual *act)
tcp_link_out_deferred	multi.h	/^    struct mbuf_set *tcp_link_out_deferred;$/;"	m	struct:multi_instance	typeref:struct:multi_instance::mbuf_set	access:public
tcp_mode	ssl_common.h	/^    bool tcp_mode;$/;"	m	struct:tls_options	access:public
tcp_queue_limit	multi.h	/^    int tcp_queue_limit;$/;"	m	struct:multi_context	access:public
tcp_queue_limit	options.h	/^    int tcp_queue_limit;$/;"	m	struct:options	access:public
tcp_rwflags	multi.h	/^    unsigned int tcp_rwflags;$/;"	m	struct:multi_instance	access:public
test_adapter_ip_netmask	tun.c	/^test_adapter_ip_netmask(const IP_ADAPTER_INFO *ai, const in_addr_t ip, const in_addr_t netmask)$/;"	f	file:	signature:(const IP_ADAPTER_INFO *ai, const in_addr_t ip, const in_addr_t netmask)
test_crypto	crypto.c	/^test_crypto(struct crypto_options *co, struct frame *frame)$/;"	f	signature:(struct crypto_options *co, struct frame *frame)
test_crypto	crypto.h	/^void test_crypto(struct crypto_options *co, struct frame *f);$/;"	p	signature:(struct crypto_options *co, struct frame *f)
test_crypto	options.h	/^    bool test_crypto;$/;"	m	struct:options	access:public
test_crypto_thread	init.c	/^test_crypto_thread(void *arg)$/;"	f	file:	signature:(void *arg)
test_file	misc.c	/^test_file(const char *filename)$/;"	f	signature:(const char *filename)
test_file	misc.h	/^bool test_file(const char *filename);$/;"	p	signature:(const char *filename)
test_local_addr	route.c	/^test_local_addr(const in_addr_t addr, const struct route_gateway_info *rgi)  \/* PLATFORM-SPECIFIC *\/$/;"	f	signature:(const in_addr_t addr, const struct route_gateway_info *rgi)
test_local_addr	route.c	/^test_local_addr(const in_addr_t addr, const struct route_gateway_info *rgi)$/;"	f	signature:(const in_addr_t addr, const struct route_gateway_info *rgi)
test_local_addr	route.h	/^int test_local_addr(const in_addr_t addr, const struct route_gateway_info *rgi);$/;"	p	signature:(const in_addr_t addr, const struct route_gateway_info *rgi)
test_route	route.c	/^test_route(const IP_ADAPTER_INFO *adapters,$/;"	f	file:	signature:(const IP_ADAPTER_INFO *adapters, const in_addr_t gateway, DWORD *index)
test_route_helper	route.c	/^test_route_helper(bool *ret,$/;"	f	file:	signature:(bool *ret, int *count, int *good, int *ambig, const IP_ADAPTER_INFO *adapters, const in_addr_t gateway)
test_routes	route.c	/^test_routes(const struct route_list *rl, const struct tuntap *tt)$/;"	f	signature:(const struct route_list *rl, const struct tuntap *tt)
test_routes	route.h	/^bool test_routes(const struct route_list *rl, const struct tuntap *tt);$/;"	p	signature:(const struct route_list *rl, const struct tuntap *tt)
test_routes	route.h	/^test_routes(const struct route_list *rl, const struct tuntap *tt)$/;"	f	signature:(const struct route_list *rl, const struct tuntap *tt)
thread_mode	multi.h	/^    int thread_mode;$/;"	m	struct:multi_context	access:public
throw_signal	sig.c	/^throw_signal(const int signum)$/;"	f	signature:(const int signum)
throw_signal	sig.h	/^void throw_signal(const int signum);$/;"	p	signature:(const int signum)
throw_signal_soft	sig.c	/^throw_signal_soft(const int signum, const char *signal_text)$/;"	f	signature:(const int signum, const char *signal_text)
throw_signal_soft	sig.h	/^void throw_signal_soft(const int signum, const char *signal_text);$/;"	p	signature:(const int signum, const char *signal_text)
time	packet_id.h	/^    time_t time;              \/* highest time stamp received *\/$/;"	m	struct:packet_id_rec	access:public
time	packet_id.h	/^    time_t time;           \/* time stamp *\/$/;"	m	struct:packet_id_persist	access:public
time	packet_id.h	/^    time_t time;           \/* time stamp *\/$/;"	m	struct:packet_id_persist_file_image	access:public
time	packet_id.h	/^    time_t time; \/* converted to net_time_t before transmission *\/$/;"	m	struct:packet_id_net	access:public
time	packet_id.h	/^    time_t time;$/;"	m	struct:packet_id_send	access:public
time_backtrack	packet_id.h	/^    int time_backtrack;       \/* set from --replay-window *\/$/;"	m	struct:packet_id_rec	access:public
time_format	common.h	60;"	d
time_last_written	packet_id.h	/^    time_t time_last_written;$/;"	m	struct:packet_id_persist	access:public
time_string	otime.c	/^time_string(time_t t, int usec, bool show_usec, struct gc_arena *gc)$/;"	f	signature:(time_t t, int usec, bool show_usec, struct gc_arena *gc)
time_string	otime.h	/^const char *time_string(time_t t, int usec, bool show_usec, struct gc_arena *gc);$/;"	p	signature:(time_t t, int usec, bool show_usec, struct gc_arena *gc)
time_test	otime.c	/^time_test(void)$/;"	f	signature:(void)
time_test	otime.h	/^void time_test(void);$/;"	p	signature:(void)
time_type	common.h	/^typedef unsigned long time_type;$/;"	t
timeout	reliable.h	/^    interval_t timeout;$/;"	m	struct:reliable_entry	access:public
timeout_random_component	openvpn.h	/^    struct timeval timeout_random_component;$/;"	m	struct:context_2	typeref:struct:context_2::timeval	access:public
timestamp	fragment.h	/^    time_t timestamp;           \/**< Timestamp for time-to-live purposes. *\/$/;"	m	struct:fragment	access:public
timestamp	manage.h	/^    time_t timestamp;$/;"	m	struct:log_entry	access:public
timeval	openvpn.h	/^    struct timeval timeval;$/;"	m	struct:context_2	typeref:struct:context_2::timeval	access:public
title_string	options.c	/^const char title_string[] =$/;"	v
tls1_PRF	ssl.c	/^tls1_PRF(const uint8_t *label,$/;"	f	file:	signature:(const uint8_t *label, int label_len, const uint8_t *sec, int slen, uint8_t *out1, int olen)
tls1_P_hash	ssl.c	/^tls1_P_hash(const md_kt_t *md_kt,$/;"	f	file:	signature:(const md_kt_t *md_kt, const uint8_t *sec, int sec_len, const uint8_t *seed, int seed_len, uint8_t *out, int olen)
tls_adjust_frame_parameters	ssl.c	/^tls_adjust_frame_parameters(struct frame *frame)$/;"	f	signature:(struct frame *frame)
tls_adjust_frame_parameters	ssl.h	/^void tls_adjust_frame_parameters(struct frame *frame);$/;"	p	signature:(struct frame *frame)
tls_auth_file	options.h	/^    const char *tls_auth_file;$/;"	m	struct:options	access:public
tls_auth_file_inline	options.h	/^    const char *tls_auth_file_inline;$/;"	m	struct:options	access:public
tls_auth_key_type	openvpn.h	/^    struct key_type tls_auth_key_type;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_type	access:public
tls_auth_standalone	openvpn.h	/^    struct tls_auth_standalone *tls_auth_standalone;$/;"	m	struct:context_2	typeref:struct:context_2::tls_auth_standalone	access:public
tls_auth_standalone	ssl.h	/^struct tls_auth_standalone$/;"	s
tls_auth_standalone::frame	ssl.h	/^    struct frame frame;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::frame	access:public
tls_auth_standalone::tls_wrap	ssl.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::tls_wrap_ctx	access:public
tls_auth_standalone_finalize	ssl.c	/^tls_auth_standalone_finalize(struct tls_auth_standalone *tas,$/;"	f	signature:(struct tls_auth_standalone *tas, const struct frame *frame)
tls_auth_standalone_finalize	ssl.h	/^void tls_auth_standalone_finalize(struct tls_auth_standalone *tas,$/;"	p	signature:(struct tls_auth_standalone *tas, const struct frame *frame)
tls_auth_standalone_init	ssl.c	/^tls_auth_standalone_init(struct tls_options *tls_options,$/;"	f	signature:(struct tls_options *tls_options, struct gc_arena *gc)
tls_auth_standalone_init	ssl.h	/^struct tls_auth_standalone *tls_auth_standalone_init(struct tls_options *tls_options,$/;"	p	signature:(struct tls_options *tls_options, struct gc_arena *gc)
tls_authenticate_key	ssl_verify.c	/^tls_authenticate_key(struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason)$/;"	f	signature:(struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason)
tls_authenticate_key	ssl_verify.h	/^bool tls_authenticate_key(struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason);$/;"	p	signature:(struct tls_multi *multi, const unsigned int mda_key_id, const bool auth, const char *client_reason)
tls_authentication_status	ssl_verify.c	/^tls_authentication_status(struct tls_multi *multi, const int latency)$/;"	f	signature:(struct tls_multi *multi, const int latency)
tls_authentication_status	ssl_verify.h	/^int tls_authentication_status(struct tls_multi *multi, const int latency);$/;"	p	signature:(struct tls_multi *multi, const int latency)
tls_cert_profile	options.h	/^    const char *tls_cert_profile;$/;"	m	struct:options	access:public
tls_check_ncp_cipher_list	ssl.c	/^tls_check_ncp_cipher_list(const char *list)$/;"	f	signature:(const char *list)
tls_check_ncp_cipher_list	ssl.h	/^bool tls_check_ncp_cipher_list(const char *list);$/;"	p	signature:(const char *list)
tls_cipher_name_pair	ssl_backend.h	/^typedef struct { const char *openssl_name; const char *iana_name; } tls_cipher_name_pair;$/;"	t	typeref:struct:__anon8
tls_cipher_name_translation_table	ssl.c	/^static const tls_cipher_name_pair tls_cipher_name_translation_table[] = {$/;"	v	file:
tls_clear_error	ssl_backend.h	/^void tls_clear_error(void);$/;"	p	signature:(void)
tls_clear_error	ssl_mbedtls.c	/^tls_clear_error(void)$/;"	f	signature:(void)
tls_clear_error	ssl_openssl.c	/^tls_clear_error(void)$/;"	f	signature:(void)
tls_client	options.h	/^    bool tls_client;$/;"	m	struct:options	access:public
tls_client_reason	ssl_verify.h	/^tls_client_reason(struct tls_multi *multi)$/;"	f	signature:(struct tls_multi *multi)
tls_common_name	ssl_verify.c	/^tls_common_name(const struct tls_multi *multi, const bool null)$/;"	f	signature:(const struct tls_multi *multi, const bool null)
tls_common_name	ssl_verify.h	/^const char *tls_common_name(const struct tls_multi *multi, const bool null);$/;"	p	signature:(const struct tls_multi *multi, const bool null)
tls_common_name_hash	ssl_verify.h	/^tls_common_name_hash(const struct tls_multi *multi, const char **cn, uint32_t *cn_hash)$/;"	f	signature:(const struct tls_multi *multi, const char **cn, uint32_t *cn_hash)
tls_crypt_adjust_frame_parameters	tls_crypt.c	/^tls_crypt_adjust_frame_parameters(struct frame *frame)$/;"	f	signature:(struct frame *frame)
tls_crypt_adjust_frame_parameters	tls_crypt.h	/^void tls_crypt_adjust_frame_parameters(struct frame *frame);$/;"	p	signature:(struct frame *frame)
tls_crypt_buf_overhead	tls_crypt.c	/^tls_crypt_buf_overhead(void)$/;"	f	signature:(void)
tls_crypt_buf_overhead	tls_crypt.h	/^int tls_crypt_buf_overhead(void);$/;"	p	signature:(void)
tls_crypt_file	options.h	/^    const char *tls_crypt_file;$/;"	m	struct:options	access:public
tls_crypt_init_key	tls_crypt.c	/^tls_crypt_init_key(struct key_ctx_bi *key, const char *key_file,$/;"	f	signature:(struct key_ctx_bi *key, const char *key_file, const char *key_inline, bool tls_server)
tls_crypt_init_key	tls_crypt.h	/^void tls_crypt_init_key(struct key_ctx_bi *key, const char *key_file,$/;"	p	signature:(struct key_ctx_bi *key, const char *key_file, const char *key_inline, bool tls_server)
tls_crypt_inline	options.h	/^    const char *tls_crypt_inline;$/;"	m	struct:options	access:public
tls_crypt_kt	tls_crypt.c	/^tls_crypt_kt(void)$/;"	f	file:	signature:(void)
tls_crypt_unwrap	tls_crypt.c	/^tls_crypt_unwrap(const struct buffer *src, struct buffer *dst,$/;"	f	signature:(const struct buffer *src, struct buffer *dst, struct crypto_options *opt)
tls_crypt_unwrap	tls_crypt.h	/^bool tls_crypt_unwrap(const struct buffer *src, struct buffer *dst,$/;"	p	signature:(const struct buffer *src, struct buffer *dst, struct crypto_options *opt)
tls_crypt_wrap	tls_crypt.c	/^tls_crypt_wrap(const struct buffer *src, struct buffer *dst,$/;"	f	signature:(const struct buffer *src, struct buffer *dst, struct crypto_options *opt)
tls_crypt_wrap	tls_crypt.h	/^bool tls_crypt_wrap(const struct buffer *src, struct buffer *dst,$/;"	p	signature:(const struct buffer *src, struct buffer *dst, struct crypto_options *opt)
tls_ctx_add_extra_certs	ssl_openssl.c	/^tls_ctx_add_extra_certs(struct tls_root_ctx *ctx, BIO *bio)$/;"	f	file:	signature:(struct tls_root_ctx *ctx, BIO *bio)
tls_ctx_check_cert_time	ssl_backend.h	/^void tls_ctx_check_cert_time(const struct tls_root_ctx *ctx);$/;"	p	signature:(const struct tls_root_ctx *ctx)
tls_ctx_check_cert_time	ssl_mbedtls.c	/^tls_ctx_check_cert_time(const struct tls_root_ctx *ctx)$/;"	f	signature:(const struct tls_root_ctx *ctx)
tls_ctx_check_cert_time	ssl_openssl.c	/^tls_ctx_check_cert_time(const struct tls_root_ctx *ctx)$/;"	f	signature:(const struct tls_root_ctx *ctx)
tls_ctx_client_new	ssl_backend.h	/^void tls_ctx_client_new(struct tls_root_ctx *ctx);$/;"	p	signature:(struct tls_root_ctx *ctx)
tls_ctx_client_new	ssl_mbedtls.c	/^tls_ctx_client_new(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_client_new	ssl_openssl.c	/^tls_ctx_client_new(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_free	ssl_backend.h	/^void tls_ctx_free(struct tls_root_ctx *ctx);$/;"	p	signature:(struct tls_root_ctx *ctx)
tls_ctx_free	ssl_mbedtls.c	/^tls_ctx_free(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_free	ssl_openssl.c	/^tls_ctx_free(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_initialised	ssl_backend.h	/^bool tls_ctx_initialised(struct tls_root_ctx *ctx);$/;"	p	signature:(struct tls_root_ctx *ctx)
tls_ctx_initialised	ssl_mbedtls.c	/^tls_ctx_initialised(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_initialised	ssl_openssl.c	/^tls_ctx_initialised(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_load_ca	ssl_backend.h	/^void tls_ctx_load_ca(struct tls_root_ctx *ctx, const char *ca_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *ca_file, const char *ca_file_inline, const char *ca_path, bool tls_server )
tls_ctx_load_ca	ssl_mbedtls.c	/^tls_ctx_load_ca(struct tls_root_ctx *ctx, const char *ca_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ca_file, const char *ca_inline, const char *ca_path, bool tls_server )
tls_ctx_load_ca	ssl_openssl.c	/^tls_ctx_load_ca(struct tls_root_ctx *ctx, const char *ca_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ca_file, const char *ca_file_inline, const char *ca_path, bool tls_server )
tls_ctx_load_cert_file	ssl_backend.h	/^void tls_ctx_load_cert_file(struct tls_root_ctx *ctx, const char *cert_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline)
tls_ctx_load_cert_file	ssl_mbedtls.c	/^tls_ctx_load_cert_file(struct tls_root_ctx *ctx, const char *cert_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_inline )
tls_ctx_load_cert_file	ssl_openssl.c	/^tls_ctx_load_cert_file(struct tls_root_ctx *ctx, const char *cert_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline)
tls_ctx_load_cert_file_and_copy	ssl_openssl.c	/^tls_ctx_load_cert_file_and_copy(struct tls_root_ctx *ctx,$/;"	f	file:	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline, X509 **x509 )
tls_ctx_load_cryptoapi	ssl_backend.h	/^void tls_ctx_load_cryptoapi(struct tls_root_ctx *ctx, const char *cryptoapi_cert);$/;"	p	signature:(struct tls_root_ctx *ctx, const char *cryptoapi_cert)
tls_ctx_load_cryptoapi	ssl_mbedtls.c	/^tls_ctx_load_cryptoapi(struct tls_root_ctx *ctx, const char *cryptoapi_cert)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cryptoapi_cert)
tls_ctx_load_cryptoapi	ssl_openssl.c	/^tls_ctx_load_cryptoapi(struct tls_root_ctx *ctx, const char *cryptoapi_cert)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cryptoapi_cert)
tls_ctx_load_dh_params	ssl_backend.h	/^void tls_ctx_load_dh_params(struct tls_root_ctx *ctx, const char *dh_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *dh_file, const char *dh_file_inline)
tls_ctx_load_dh_params	ssl_mbedtls.c	/^tls_ctx_load_dh_params(struct tls_root_ctx *ctx, const char *dh_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *dh_file, const char *dh_inline )
tls_ctx_load_dh_params	ssl_openssl.c	/^tls_ctx_load_dh_params(struct tls_root_ctx *ctx, const char *dh_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *dh_file, const char *dh_file_inline )
tls_ctx_load_ecdh_params	ssl_backend.h	/^void tls_ctx_load_ecdh_params(struct tls_root_ctx *ctx, const char *curve_name$/;"	p	signature:(struct tls_root_ctx *ctx, const char *curve_name )
tls_ctx_load_ecdh_params	ssl_mbedtls.c	/^tls_ctx_load_ecdh_params(struct tls_root_ctx *ctx, const char *curve_name$/;"	f	signature:(struct tls_root_ctx *ctx, const char *curve_name )
tls_ctx_load_ecdh_params	ssl_openssl.c	/^tls_ctx_load_ecdh_params(struct tls_root_ctx *ctx, const char *curve_name$/;"	f	signature:(struct tls_root_ctx *ctx, const char *curve_name )
tls_ctx_load_extra_certs	ssl_backend.h	/^void tls_ctx_load_extra_certs(struct tls_root_ctx *ctx, const char *extra_certs_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *extra_certs_file, const char *extra_certs_file_inline )
tls_ctx_load_extra_certs	ssl_mbedtls.c	/^tls_ctx_load_extra_certs(struct tls_root_ctx *ctx, const char *extra_certs_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *extra_certs_file, const char *extra_certs_inline )
tls_ctx_load_extra_certs	ssl_openssl.c	/^tls_ctx_load_extra_certs(struct tls_root_ctx *ctx, const char *extra_certs_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *extra_certs_file, const char *extra_certs_file_inline )
tls_ctx_load_pkcs12	ssl_backend.h	/^int tls_ctx_load_pkcs12(struct tls_root_ctx *ctx, const char *pkcs12_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *pkcs12_file, const char *pkcs12_file_inline, bool load_ca_file )
tls_ctx_load_pkcs12	ssl_mbedtls.c	/^tls_ctx_load_pkcs12(struct tls_root_ctx *ctx, const char *pkcs12_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *pkcs12_file, const char *pkcs12_file_inline, bool load_ca_file )
tls_ctx_load_pkcs12	ssl_openssl.c	/^tls_ctx_load_pkcs12(struct tls_root_ctx *ctx, const char *pkcs12_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *pkcs12_file, const char *pkcs12_file_inline, bool load_ca_file )
tls_ctx_load_priv_file	ssl_backend.h	/^int tls_ctx_load_priv_file(struct tls_root_ctx *ctx, const char *priv_key_file,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *priv_key_file, const char *priv_key_file_inline )
tls_ctx_load_priv_file	ssl_mbedtls.c	/^tls_ctx_load_priv_file(struct tls_root_ctx *ctx, const char *priv_key_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *priv_key_file, const char *priv_key_inline )
tls_ctx_load_priv_file	ssl_openssl.c	/^tls_ctx_load_priv_file(struct tls_root_ctx *ctx, const char *priv_key_file,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *priv_key_file, const char *priv_key_file_inline )
tls_ctx_personalise_random	ssl_backend.h	/^void tls_ctx_personalise_random(struct tls_root_ctx *ctx);$/;"	p	signature:(struct tls_root_ctx *ctx)
tls_ctx_personalise_random	ssl_mbedtls.c	/^tls_ctx_personalise_random(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_reload_crl	ssl.c	/^tls_ctx_reload_crl(struct tls_root_ctx *ssl_ctx, const char *crl_file,$/;"	f	file:	signature:(struct tls_root_ctx *ssl_ctx, const char *crl_file, const char *crl_file_inline)
tls_ctx_restrict_ciphers	ssl_backend.h	/^void tls_ctx_restrict_ciphers(struct tls_root_ctx *ctx, const char *ciphers);$/;"	p	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_restrict_ciphers	ssl_mbedtls.c	/^tls_ctx_restrict_ciphers(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_restrict_ciphers	ssl_openssl.c	/^tls_ctx_restrict_ciphers(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_restrict_ciphers_tls13	ssl_backend.h	/^void tls_ctx_restrict_ciphers_tls13(struct tls_root_ctx *ctx, const char *ciphers);$/;"	p	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_restrict_ciphers_tls13	ssl_mbedtls.c	/^tls_ctx_restrict_ciphers_tls13(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_restrict_ciphers_tls13	ssl_openssl.c	/^tls_ctx_restrict_ciphers_tls13(struct tls_root_ctx *ctx, const char *ciphers)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *ciphers)
tls_ctx_server_new	ssl_backend.h	/^void tls_ctx_server_new(struct tls_root_ctx *ctx);$/;"	p	signature:(struct tls_root_ctx *ctx)
tls_ctx_server_new	ssl_mbedtls.c	/^tls_ctx_server_new(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_server_new	ssl_openssl.c	/^tls_ctx_server_new(struct tls_root_ctx *ctx)$/;"	f	signature:(struct tls_root_ctx *ctx)
tls_ctx_set_cert_profile	ssl_backend.h	/^void tls_ctx_set_cert_profile(struct tls_root_ctx *ctx, const char *profile);$/;"	p	signature:(struct tls_root_ctx *ctx, const char *profile)
tls_ctx_set_cert_profile	ssl_mbedtls.c	/^tls_ctx_set_cert_profile(struct tls_root_ctx *ctx, const char *profile)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *profile)
tls_ctx_set_cert_profile	ssl_openssl.c	/^tls_ctx_set_cert_profile(struct tls_root_ctx *ctx, const char *profile)$/;"	f	signature:(struct tls_root_ctx *ctx, const char *profile)
tls_ctx_set_options	ssl_backend.h	/^bool tls_ctx_set_options(struct tls_root_ctx *ctx, unsigned int ssl_flags);$/;"	p	signature:(struct tls_root_ctx *ctx, unsigned int ssl_flags)
tls_ctx_set_options	ssl_mbedtls.c	/^tls_ctx_set_options(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f	signature:(struct tls_root_ctx *ctx, unsigned int ssl_flags)
tls_ctx_set_options	ssl_openssl.c	/^tls_ctx_set_options(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f	signature:(struct tls_root_ctx *ctx, unsigned int ssl_flags)
tls_ctx_set_tls_versions	ssl_openssl.c	/^tls_ctx_set_tls_versions(struct tls_root_ctx *ctx, unsigned int ssl_flags)$/;"	f	file:	signature:(struct tls_root_ctx *ctx, unsigned int ssl_flags)
tls_ctx_use_external_private_key	ssl_backend.h	/^int tls_ctx_use_external_private_key(struct tls_root_ctx *ctx,$/;"	p	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline)
tls_ctx_use_external_private_key	ssl_mbedtls.c	/^tls_ctx_use_external_private_key(struct tls_root_ctx *ctx,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline)
tls_ctx_use_external_private_key	ssl_openssl.c	/^tls_ctx_use_external_private_key(struct tls_root_ctx *ctx,$/;"	f	signature:(struct tls_root_ctx *ctx, const char *cert_file, const char *cert_file_inline)
tls_ctx_use_pkcs11	pkcs11.c	/^tls_ctx_use_pkcs11($/;"	f	signature:( struct tls_root_ctx *const ssl_ctx, bool pkcs11_id_management, const char *const pkcs11_id )
tls_ctx_use_pkcs11	pkcs11.h	/^tls_ctx_use_pkcs11($/;"	p	signature:( struct tls_root_ctx *const ssl_ctx, bool pkcs11_id_management, const char *const pkcs11_id )
tls_deauthenticate	ssl_verify.c	/^tls_deauthenticate(struct tls_multi *multi)$/;"	f	file:	signature:(struct tls_multi *multi)
tls_exit	options.h	/^    bool tls_exit;$/;"	m	struct:options	access:public
tls_exit_signal	openvpn.h	/^    int tls_exit_signal;$/;"	m	struct:context_2	access:public
tls_export_cert	options.h	/^    const char *tls_export_cert;$/;"	m	struct:options	access:public
tls_free_lib	ssl_backend.h	/^void tls_free_lib(void);$/;"	p	signature:(void)
tls_free_lib	ssl_mbedtls.c	/^tls_free_lib(void)$/;"	f	signature:(void)
tls_free_lib	ssl_openssl.c	/^tls_free_lib(void)$/;"	f	signature:(void)
tls_get_cipher_name_pair	ssl.c	/^tls_get_cipher_name_pair(const char *cipher_name, size_t len)$/;"	f	signature:(const char *cipher_name, size_t len)
tls_get_cipher_name_pair	ssl_backend.h	/^const tls_cipher_name_pair *tls_get_cipher_name_pair(const char *cipher_name, size_t len);$/;"	p	signature:(const char *cipher_name, size_t len)
tls_get_peer_info	ssl.h	/^tls_get_peer_info(const struct tls_multi *multi)$/;"	f	signature:(const struct tls_multi *multi)
tls_handshake_error	ssl.c	/^static int tls_handshake_error;   \/* GLOBAL *\/$/;"	v	file:
tls_handshake_success	ssl.c	/^static int tls_handshake_success; \/* GLOBAL *\/$/;"	v	file:
tls_init_control_channel_frame_parameters	ssl.c	/^tls_init_control_channel_frame_parameters(const struct frame *data_channel_frame,$/;"	f	file:	signature:(const struct frame *data_channel_frame, struct frame *frame)
tls_init_lib	ssl_backend.h	/^void tls_init_lib(void);$/;"	p	signature:(void)
tls_init_lib	ssl_mbedtls.c	/^tls_init_lib(void)$/;"	f	signature:(void)
tls_init_lib	ssl_openssl.c	/^tls_init_lib(void)$/;"	f	signature:(void)
tls_initial_packet_received	ssl.h	/^tls_initial_packet_received(const struct tls_multi *multi)$/;"	f	signature:(const struct tls_multi *multi)
tls_item_in_cipher_list	ssl.c	/^tls_item_in_cipher_list(const char *item, const char *list)$/;"	f	signature:(const char *item, const char *list)
tls_item_in_cipher_list	ssl.h	/^bool tls_item_in_cipher_list(const char *item, const char *list);$/;"	p	signature:(const char *item, const char *list)
tls_limit_reneg_bytes	ssl.c	/^tls_limit_reneg_bytes(const cipher_kt_t *cipher, int *reneg_bytes)$/;"	f	file:	signature:(const cipher_kt_t *cipher, int *reneg_bytes)
tls_lock_cert_hash_set	ssl_verify.c	/^tls_lock_cert_hash_set(struct tls_multi *multi)$/;"	f	signature:(struct tls_multi *multi)
tls_lock_cert_hash_set	ssl_verify.h	/^void tls_lock_cert_hash_set(struct tls_multi *multi);$/;"	p	signature:(struct tls_multi *multi)
tls_lock_common_name	ssl_verify.c	/^tls_lock_common_name(struct tls_multi *multi)$/;"	f	signature:(struct tls_multi *multi)
tls_lock_common_name	ssl_verify.h	/^void tls_lock_common_name(struct tls_multi *multi);$/;"	p	signature:(struct tls_multi *multi)
tls_lock_username	ssl_verify.c	/^tls_lock_username(struct tls_multi *multi, const char *username)$/;"	f	file:	signature:(struct tls_multi *multi, const char *username)
tls_multi	openvpn.h	/^    struct tls_multi *tls_multi; \/**< TLS state structure for this VPN$/;"	m	struct:context_2	typeref:struct:context_2::tls_multi	access:public
tls_multi	ssl_common.h	/^struct tls_multi$/;"	s
tls_multi::auth_token	ssl_common.h	/^    char *auth_token;    \/**< If server sends a generated auth-token,$/;"	m	struct:tls_multi	access:public
tls_multi::auth_token_sent	ssl_common.h	/^    bool auth_token_sent; \/**< If server uses --auth-gen-token and$/;"	m	struct:tls_multi	access:public
tls_multi::auth_token_tstamp	ssl_common.h	/^    time_t auth_token_tstamp; \/**< timestamp of the generated token *\/$/;"	m	struct:tls_multi	access:public
tls_multi::client_reason	ssl_common.h	/^    char *client_reason;$/;"	m	struct:tls_multi	access:public
tls_multi::key_scan	ssl_common.h	/^    struct key_state *key_scan[KEY_SCAN_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state	access:public
tls_multi::locked_cert_hash_set	ssl_common.h	/^    struct cert_hash_set *locked_cert_hash_set;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::cert_hash_set	access:public
tls_multi::locked_cn	ssl_common.h	/^    char *locked_cn;$/;"	m	struct:tls_multi	access:public
tls_multi::locked_username	ssl_common.h	/^    char *locked_username;$/;"	m	struct:tls_multi	access:public
tls_multi::n_hard_errors	ssl_common.h	/^    int n_hard_errors; \/* errors due to TLS negotiation failure *\/$/;"	m	struct:tls_multi	access:public
tls_multi::n_sessions	ssl_common.h	/^    int n_sessions;             \/**< Number of sessions negotiated thus$/;"	m	struct:tls_multi	access:public
tls_multi::n_soft_errors	ssl_common.h	/^    int n_soft_errors; \/* errors due to unrecognized or failed-to-authenticate incoming packets *\/$/;"	m	struct:tls_multi	access:public
tls_multi::opt	ssl_common.h	/^    struct tls_options opt;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_options	access:public
tls_multi::peer_id	ssl_common.h	/^    uint32_t peer_id;$/;"	m	struct:tls_multi	access:public
tls_multi::peer_info	ssl_common.h	/^    char *peer_info;$/;"	m	struct:tls_multi	access:public
tls_multi::remote_ciphername	ssl_common.h	/^    char *remote_ciphername;    \/**< cipher specified in peer's config file *\/$/;"	m	struct:tls_multi	access:public
tls_multi::save_ks	ssl_common.h	/^    struct key_state *save_ks;  \/* temporary pointer used between pre\/post routines *\/$/;"	m	struct:tls_multi	typeref:struct:tls_multi::key_state	access:public
tls_multi::session	ssl_common.h	/^    struct tls_session session[TM_SIZE];$/;"	m	struct:tls_multi	typeref:struct:tls_multi::tls_session	access:public
tls_multi::tas_last	ssl_common.h	/^    time_t tas_last;$/;"	m	struct:tls_multi	access:public
tls_multi::to_link_addr	ssl_common.h	/^    struct link_socket_actual to_link_addr;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::link_socket_actual	access:public
tls_multi::use_peer_id	ssl_common.h	/^    bool use_peer_id;$/;"	m	struct:tls_multi	access:public
tls_multi_free	ssl.c	/^tls_multi_free(struct tls_multi *multi, bool clear)$/;"	f	signature:(struct tls_multi *multi, bool clear)
tls_multi_free	ssl.h	/^void tls_multi_free(struct tls_multi *multi, bool clear);$/;"	p	signature:(struct tls_multi *multi, bool clear)
tls_multi_init	ssl.c	/^tls_multi_init(struct tls_options *tls_options)$/;"	f	signature:(struct tls_options *tls_options)
tls_multi_init	ssl.h	/^struct tls_multi *tls_multi_init(struct tls_options *tls_options);$/;"	p	signature:(struct tls_options *tls_options)
tls_multi_init_finalize	ssl.c	/^tls_multi_init_finalize(struct tls_multi *multi, const struct frame *frame)$/;"	f	signature:(struct tls_multi *multi, const struct frame *frame)
tls_multi_init_finalize	ssl.h	/^void tls_multi_init_finalize(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, const struct frame *frame)
tls_multi_init_set_options	ssl.c	/^tls_multi_init_set_options(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, const char *local, const char *remote)
tls_multi_init_set_options	ssl.h	/^void tls_multi_init_set_options(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, const char *local, const char *remote)
tls_multi_process	ssl.c	/^tls_multi_process(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, struct buffer *to_link, struct link_socket_actual **to_link_addr, struct link_socket_info *to_link_socket_info, interval_t *wakeup)
tls_multi_process	ssl.h	/^int tls_multi_process(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, struct buffer *to_link, struct link_socket_actual **to_link_addr, struct link_socket_info *to_link_socket_info, interval_t *wakeup)
tls_options	ssl_common.h	/^struct tls_options$/;"	s
tls_options::auth_token_generate	ssl_common.h	/^    bool auth_token_generate;   \/**< Generate auth-tokens on successful user\/pass auth,$/;"	m	struct:tls_options	access:public
tls_options::auth_token_lifetime	ssl_common.h	/^    unsigned int auth_token_lifetime;$/;"	m	struct:tls_options	access:public
tls_options::auth_user_pass_file	ssl_common.h	/^    const char *auth_user_pass_file;$/;"	m	struct:tls_options	access:public
tls_options::auth_user_pass_verify_script	ssl_common.h	/^    const char *auth_user_pass_verify_script;$/;"	m	struct:tls_options	access:public
tls_options::auth_user_pass_verify_script_via_file	ssl_common.h	/^    bool auth_user_pass_verify_script_via_file;$/;"	m	struct:tls_options	access:public
tls_options::client_config_dir_exclusive	ssl_common.h	/^    const char *client_config_dir_exclusive;$/;"	m	struct:tls_options	access:public
tls_options::comp_options	ssl_common.h	/^    struct compress_options comp_options;$/;"	m	struct:tls_options	typeref:struct:tls_options::compress_options	access:public
tls_options::config_authname	ssl_common.h	/^    const char *config_authname;$/;"	m	struct:tls_options	access:public
tls_options::config_ciphername	ssl_common.h	/^    const char *config_ciphername;$/;"	m	struct:tls_options	access:public
tls_options::crl_file	ssl_common.h	/^    const char *crl_file;$/;"	m	struct:tls_options	access:public
tls_options::crl_file_inline	ssl_common.h	/^    const char *crl_file_inline;$/;"	m	struct:tls_options	access:public
tls_options::crypto_flags	ssl_common.h	/^    unsigned int crypto_flags;$/;"	m	struct:tls_options	access:public
tls_options::disable_occ	ssl_common.h	/^    bool disable_occ;$/;"	m	struct:tls_options	access:public
tls_options::ekm_label	ssl_common.h	/^    const char *ekm_label;$/;"	m	struct:tls_options	access:public
tls_options::ekm_label_size	ssl_common.h	/^    size_t ekm_label_size;$/;"	m	struct:tls_options	access:public
tls_options::ekm_size	ssl_common.h	/^    size_t ekm_size;$/;"	m	struct:tls_options	access:public
tls_options::es	ssl_common.h	/^    struct env_set *es;$/;"	m	struct:tls_options	typeref:struct:tls_options::env_set	access:public
tls_options::frame	ssl_common.h	/^    struct frame frame;$/;"	m	struct:tls_options	typeref:struct:tls_options::frame	access:public
tls_options::gremlin	ssl_common.h	/^    int gremlin;$/;"	m	struct:tls_options	access:public
tls_options::handshake_window	ssl_common.h	/^    int handshake_window;$/;"	m	struct:tls_options	access:public
tls_options::key_method	ssl_common.h	/^    int key_method;$/;"	m	struct:tls_options	access:public
tls_options::key_type	ssl_common.h	/^    struct key_type key_type;$/;"	m	struct:tls_options	typeref:struct:tls_options::key_type	access:public
tls_options::local_options	ssl_common.h	/^    const char *local_options;$/;"	m	struct:tls_options	access:public
tls_options::mda_context	ssl_common.h	/^    struct man_def_auth_context *mda_context;$/;"	m	struct:tls_options	typeref:struct:tls_options::man_def_auth_context	access:public
tls_options::mode	ssl_common.h	/^    int mode;$/;"	m	struct:tls_options	access:public
tls_options::ncp_enabled	ssl_common.h	/^    bool ncp_enabled;$/;"	m	struct:tls_options	access:public
tls_options::ns_cert_type	ssl_common.h	/^    int ns_cert_type;$/;"	m	struct:tls_options	access:public
tls_options::packet_timeout	ssl_common.h	/^    interval_t packet_timeout;$/;"	m	struct:tls_options	access:public
tls_options::pass_config_info	ssl_common.h	/^    bool pass_config_info;$/;"	m	struct:tls_options	access:public
tls_options::plugins	ssl_common.h	/^    const struct plugin_list *plugins;$/;"	m	struct:tls_options	typeref:struct:tls_options::plugin_list	access:public
tls_options::pull	ssl_common.h	/^    bool pull;$/;"	m	struct:tls_options	access:public
tls_options::push_peer_info_detail	ssl_common.h	/^    int push_peer_info_detail;$/;"	m	struct:tls_options	access:public
tls_options::remote_cert_eku	ssl_common.h	/^    const char *remote_cert_eku;$/;"	m	struct:tls_options	access:public
tls_options::remote_cert_ku	ssl_common.h	/^    unsigned remote_cert_ku[MAX_PARMS];$/;"	m	struct:tls_options	access:public
tls_options::remote_options	ssl_common.h	/^    const char *remote_options;$/;"	m	struct:tls_options	access:public
tls_options::renegotiate_bytes	ssl_common.h	/^    int renegotiate_bytes;$/;"	m	struct:tls_options	access:public
tls_options::renegotiate_packets	ssl_common.h	/^    int renegotiate_packets;$/;"	m	struct:tls_options	access:public
tls_options::renegotiate_seconds	ssl_common.h	/^    interval_t renegotiate_seconds;$/;"	m	struct:tls_options	access:public
tls_options::replay	ssl_common.h	/^    bool replay;$/;"	m	struct:tls_options	access:public
tls_options::replay_time	ssl_common.h	/^    int replay_time;                   \/* --replay-window parm *\/$/;"	m	struct:tls_options	access:public
tls_options::replay_window	ssl_common.h	/^    int replay_window;                 \/* --replay-window parm *\/$/;"	m	struct:tls_options	access:public
tls_options::sci	ssl_common.h	/^    const struct static_challenge_info *sci;$/;"	m	struct:tls_options	typeref:struct:tls_options::static_challenge_info	access:public
tls_options::server	ssl_common.h	/^    bool server;$/;"	m	struct:tls_options	access:public
tls_options::single_session	ssl_common.h	/^    bool single_session;$/;"	m	struct:tls_options	access:public
tls_options::ssl_ctx	ssl_common.h	/^    struct tls_root_ctx ssl_ctx;$/;"	m	struct:tls_options	typeref:struct:tls_options::tls_root_ctx	access:public
tls_options::ssl_flags	ssl_common.h	/^    unsigned int ssl_flags;$/;"	m	struct:tls_options	access:public
tls_options::tcp_mode	ssl_common.h	/^    bool tcp_mode;$/;"	m	struct:tls_options	access:public
tls_options::tls_wrap	ssl_common.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_options	typeref:struct:tls_options::tls_wrap_ctx	access:public
tls_options::tmp_dir	ssl_common.h	/^    const char *tmp_dir;$/;"	m	struct:tls_options	access:public
tls_options::transition_window	ssl_common.h	/^    int transition_window;$/;"	m	struct:tls_options	access:public
tls_options::verify_command	ssl_common.h	/^    const char *verify_command;$/;"	m	struct:tls_options	access:public
tls_options::verify_export_cert	ssl_common.h	/^    const char *verify_export_cert;$/;"	m	struct:tls_options	access:public
tls_options::verify_hash	ssl_common.h	/^    uint8_t *verify_hash;$/;"	m	struct:tls_options	access:public
tls_options::verify_hash_algo	ssl_common.h	/^    hash_algo_type verify_hash_algo;$/;"	m	struct:tls_options	access:public
tls_options::verify_x509_name	ssl_common.h	/^    const char *verify_x509_name;$/;"	m	struct:tls_options	access:public
tls_options::verify_x509_type	ssl_common.h	/^    int verify_x509_type;$/;"	m	struct:tls_options	access:public
tls_options::x509_track	ssl_common.h	/^    const struct x509_track *x509_track;$/;"	m	struct:tls_options	typeref:struct:tls_options::x509_track	access:public
tls_options::x509_username_field	ssl_common.h	/^    char *x509_username_field;$/;"	m	struct:tls_options	access:public
tls_options::xmit_hold	ssl_common.h	/^    bool xmit_hold;$/;"	m	struct:tls_options	access:public
tls_packets_generated	ssl.c	/^static int tls_packets_generated; \/* GLOBAL *\/$/;"	v	file:
tls_packets_sent	ssl.c	/^static int tls_packets_sent;      \/* GLOBAL *\/$/;"	v	file:
tls_peer_info_ncp_ver	ssl.c	/^tls_peer_info_ncp_ver(const char *peer_info)$/;"	f	signature:(const char *peer_info)
tls_peer_info_ncp_ver	ssl.h	/^int tls_peer_info_ncp_ver(const char *peer_info);$/;"	p	signature:(const char *peer_info)
tls_poor_mans_ncp	ssl.c	/^tls_poor_mans_ncp(struct options *o, const char *remote_ciphername)$/;"	f	signature:(struct options *o, const char *remote_ciphername)
tls_poor_mans_ncp	ssl.h	/^void tls_poor_mans_ncp(struct options *o, const char *remote_ciphername);$/;"	p	signature:(struct options *o, const char *remote_ciphername)
tls_post_encrypt	ssl.c	/^tls_post_encrypt(struct tls_multi *multi, struct buffer *buf)$/;"	f	signature:(struct tls_multi *multi, struct buffer *buf)
tls_post_encrypt	ssl.h	/^void tls_post_encrypt(struct tls_multi *multi, struct buffer *buf);$/;"	p	signature:(struct tls_multi *multi, struct buffer *buf)
tls_pre_decrypt	ssl.c	/^tls_pre_decrypt(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, const struct link_socket_actual *from, struct buffer *buf, struct crypto_options **opt, bool floated, const uint8_t **ad_start)
tls_pre_decrypt	ssl.h	/^bool tls_pre_decrypt(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, const struct link_socket_actual *from, struct buffer *buf, struct crypto_options **opt, bool floated, const uint8_t **ad_start)
tls_pre_decrypt_lite	ssl.c	/^tls_pre_decrypt_lite(const struct tls_auth_standalone *tas,$/;"	f	signature:(const struct tls_auth_standalone *tas, const struct link_socket_actual *from, const struct buffer *buf)
tls_pre_decrypt_lite	ssl.h	/^bool tls_pre_decrypt_lite(const struct tls_auth_standalone *tas,$/;"	p	signature:(const struct tls_auth_standalone *tas, const struct link_socket_actual *from, const struct buffer *buf)
tls_pre_encrypt	ssl.c	/^tls_pre_encrypt(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, struct buffer *buf, struct crypto_options **opt)
tls_pre_encrypt	ssl.h	/^void tls_pre_encrypt(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, struct buffer *buf, struct crypto_options **opt)
tls_prepend_opcode_v1	ssl.c	/^tls_prepend_opcode_v1(const struct tls_multi *multi, struct buffer *buf)$/;"	f	signature:(const struct tls_multi *multi, struct buffer *buf)
tls_prepend_opcode_v1	ssl.h	/^tls_prepend_opcode_v1(const struct tls_multi *multi, struct buffer *buf);$/;"	p	signature:(const struct tls_multi *multi, struct buffer *buf)
tls_prepend_opcode_v2	ssl.c	/^tls_prepend_opcode_v2(const struct tls_multi *multi, struct buffer *buf)$/;"	f	signature:(const struct tls_multi *multi, struct buffer *buf)
tls_prepend_opcode_v2	ssl.h	/^tls_prepend_opcode_v2(const struct tls_multi *multi, struct buffer *buf);$/;"	p	signature:(const struct tls_multi *multi, struct buffer *buf)
tls_process	ssl.c	/^tls_process(struct tls_multi *multi,$/;"	f	file:	signature:(struct tls_multi *multi, struct tls_session *session, struct buffer *to_link, struct link_socket_actual **to_link_addr, struct link_socket_info *to_link_socket_info, interval_t *wakeup)
tls_rec_payload	ssl.c	/^tls_rec_payload(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, struct buffer *buf)
tls_rec_payload	ssl.h	/^bool tls_rec_payload(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, struct buffer *buf)
tls_root_ctx	ssl_mbedtls.h	/^struct tls_root_ctx {$/;"	s
tls_root_ctx	ssl_openssl.h	/^struct tls_root_ctx {$/;"	s
tls_root_ctx::allowed_ciphers	ssl_mbedtls.h	/^    int *allowed_ciphers;       \/**< List of allowed ciphers for this connection *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::ca_chain	ssl_mbedtls.h	/^    mbedtls_x509_crt *ca_chain;         \/**< CA chain for remote verification *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::cert_profile	ssl_mbedtls.h	/^    mbedtls_x509_crt_profile cert_profile; \/**< Allowed certificate types *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crl	ssl_mbedtls.h	/^    mbedtls_x509_crl *crl;              \/**< Certificate Revocation List *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crl_last_mtime	ssl_mbedtls.h	/^    time_t crl_last_mtime;              \/**< CRL last modification time *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crl_last_mtime	ssl_openssl.h	/^    time_t crl_last_mtime;$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crl_last_size	ssl_mbedtls.h	/^    off_t crl_last_size;                \/**< size of last loaded CRL *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crl_last_size	ssl_openssl.h	/^    off_t crl_last_size;$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::crt_chain	ssl_mbedtls.h	/^    mbedtls_x509_crt *crt_chain;        \/**< Local Certificate chain *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::ctx	ssl_openssl.h	/^    SSL_CTX *ctx;$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::dhm_ctx	ssl_mbedtls.h	/^    mbedtls_dhm_context *dhm_ctx;       \/**< Diffie-Helmann-Merkle context *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::endpoint	ssl_mbedtls.h	/^    int endpoint;               \/**< Whether or not this is a server or a client *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::external_key	ssl_mbedtls.h	/^    struct external_context *external_key; \/**< Management external key *\/$/;"	m	struct:tls_root_ctx	typeref:struct:tls_root_ctx::external_context	access:public
tls_root_ctx::initialised	ssl_mbedtls.h	/^    bool initialised;           \/**< True if the context has been initialised *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::priv_key	ssl_mbedtls.h	/^    mbedtls_pk_context *priv_key;       \/**< Local private key *\/$/;"	m	struct:tls_root_ctx	access:public
tls_root_ctx::priv_key_pkcs11	ssl_mbedtls.h	/^    mbedtls_pkcs11_context *priv_key_pkcs11;    \/**< PKCS11 private key *\/$/;"	m	struct:tls_root_ctx	access:public
tls_send_payload	ssl.c	/^tls_send_payload(struct tls_multi *multi,$/;"	f	signature:(struct tls_multi *multi, const uint8_t *data, int size)
tls_send_payload	ssl.h	/^bool tls_send_payload(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, const uint8_t *data, int size)
tls_server	options.h	/^    bool tls_server;$/;"	m	struct:options	access:public
tls_session	ssl_common.h	/^struct tls_session$/;"	s
tls_session::burst	ssl_common.h	/^    bool burst;$/;"	m	struct:tls_session	access:public
tls_session::cert_hash_set	ssl_common.h	/^    struct cert_hash_set *cert_hash_set;$/;"	m	struct:tls_session	typeref:struct:tls_session::cert_hash_set	access:public
tls_session::common_name	ssl_common.h	/^    char *common_name;$/;"	m	struct:tls_session	access:public
tls_session::common_name_hashval	ssl_common.h	/^    uint32_t common_name_hashval;$/;"	m	struct:tls_session	access:public
tls_session::initial_opcode	ssl_common.h	/^    int initial_opcode;         \/* our initial P_ opcode *\/$/;"	m	struct:tls_session	access:public
tls_session::key	ssl_common.h	/^    struct key_state key[KS_SIZE];$/;"	m	struct:tls_session	typeref:struct:tls_session::key_state	access:public
tls_session::key_id	ssl_common.h	/^    int key_id;$/;"	m	struct:tls_session	access:public
tls_session::limit_next	ssl_common.h	/^    int limit_next;             \/* used for traffic shaping on the control channel *\/$/;"	m	struct:tls_session	access:public
tls_session::opt	ssl_common.h	/^    struct tls_options *opt;$/;"	m	struct:tls_session	typeref:struct:tls_session::tls_options	access:public
tls_session::session_id	ssl_common.h	/^    struct session_id session_id; \/* our random session ID *\/$/;"	m	struct:tls_session	typeref:struct:tls_session::session_id	access:public
tls_session::tls_wrap	ssl_common.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_session	typeref:struct:tls_session::tls_wrap_ctx	access:public
tls_session::untrusted_addr	ssl_common.h	/^    struct link_socket_actual untrusted_addr;$/;"	m	struct:tls_session	typeref:struct:tls_session::link_socket_actual	access:public
tls_session::verified	ssl_common.h	/^    bool verified;              \/* true if peer certificate was verified against CA *\/$/;"	m	struct:tls_session	access:public
tls_session::verify_maxlevel	ssl_common.h	/^    int verify_maxlevel;$/;"	m	struct:tls_session	access:public
tls_session_free	ssl.c	/^tls_session_free(struct tls_session *session, bool clear)$/;"	f	file:	signature:(struct tls_session *session, bool clear)
tls_session_generate_data_channel_keys	ssl.c	/^tls_session_generate_data_channel_keys(struct tls_session *session)$/;"	f	file:	signature:(struct tls_session *session)
tls_session_init	ssl.c	/^tls_session_init(struct tls_multi *multi, struct tls_session *session)$/;"	f	file:	signature:(struct tls_multi *multi, struct tls_session *session)
tls_session_update_crypto_params	ssl.c	/^tls_session_update_crypto_params(struct tls_session *session,$/;"	f	signature:(struct tls_session *session, struct options *options, struct frame *frame)
tls_session_update_crypto_params	ssl.h	/^bool tls_session_update_crypto_params(struct tls_session *session,$/;"	p	signature:(struct tls_session *session, struct options *options, struct frame *frame)
tls_session_user_pass_enabled	ssl.c	/^tls_session_user_pass_enabled(struct tls_session *session)$/;"	f	file:	signature:(struct tls_session *session)
tls_set_single_session	ssl.h	/^tls_set_single_session(struct tls_multi *multi)$/;"	f	signature:(struct tls_multi *multi)
tls_test_auth_deferred_interval	ssl.h	/^tls_test_auth_deferred_interval(const struct tls_multi *multi)$/;"	f	signature:(const struct tls_multi *multi)
tls_test_payload_len	ssl.h	/^tls_test_payload_len(const struct tls_multi *multi)$/;"	f	signature:(const struct tls_multi *multi)
tls_timeout	options.h	/^    int tls_timeout;$/;"	m	struct:options	access:public
tls_translate_cipher_name	ssl_mbedtls.c	/^tls_translate_cipher_name(const char *cipher_name)$/;"	f	file:	signature:(const char *cipher_name)
tls_update_remote_addr	ssl.c	/^tls_update_remote_addr(struct tls_multi *multi, const struct link_socket_actual *addr)$/;"	f	signature:(struct tls_multi *multi, const struct link_socket_actual *addr)
tls_update_remote_addr	ssl.h	/^void tls_update_remote_addr(struct tls_multi *multi,$/;"	p	signature:(struct tls_multi *multi, const struct link_socket_actual *addr)
tls_username	ssl_verify.c	/^tls_username(const struct tls_multi *multi, const bool null)$/;"	f	signature:(const struct tls_multi *multi, const bool null)
tls_username	ssl_verify.h	/^const char *tls_username(const struct tls_multi *multi, const bool null);$/;"	p	signature:(const struct tls_multi *multi, const bool null)
tls_verify	options.h	/^    const char *tls_verify;$/;"	m	struct:options	access:public
tls_verify_crl_missing	ssl_verify_backend.h	/^bool tls_verify_crl_missing(const struct tls_options *opt);$/;"	p	signature:(const struct tls_options *opt)
tls_verify_crl_missing	ssl_verify_mbedtls.c	/^tls_verify_crl_missing(const struct tls_options *opt)$/;"	f	signature:(const struct tls_options *opt)
tls_verify_crl_missing	ssl_verify_openssl.c	/^tls_verify_crl_missing(const struct tls_options *opt)$/;"	f	signature:(const struct tls_options *opt)
tls_version_max	ssl_backend.h	/^int tls_version_max(void);$/;"	p	signature:(void)
tls_version_max	ssl_mbedtls.c	/^tls_version_max(void)$/;"	f	signature:(void)
tls_version_max	ssl_openssl.c	/^tls_version_max(void)$/;"	f	signature:(void)
tls_version_parse	ssl.c	/^tls_version_parse(const char *vstr, const char *extra)$/;"	f	signature:(const char *vstr, const char *extra)
tls_version_parse	ssl_backend.h	/^int tls_version_parse(const char *vstr, const char *extra);$/;"	p	signature:(const char *vstr, const char *extra)
tls_version_to_major_minor	ssl_mbedtls.c	/^tls_version_to_major_minor(int tls_ver, int *major, int *minor)$/;"	f	file:	signature:(int tls_ver, int *major, int *minor)
tls_wrap	ssl.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_auth_standalone	typeref:struct:tls_auth_standalone::tls_wrap_ctx	access:public
tls_wrap	ssl_common.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_options	typeref:struct:tls_options::tls_wrap_ctx	access:public
tls_wrap	ssl_common.h	/^    struct tls_wrap_ctx tls_wrap;$/;"	m	struct:tls_session	typeref:struct:tls_session::tls_wrap_ctx	access:public
tls_wrap_ctx	ssl_common.h	/^struct tls_wrap_ctx$/;"	s
tls_wrap_ctx::TLS_WRAP_AUTH	ssl_common.h	/^        TLS_WRAP_AUTH,  \/**< Control channel authentication *\/$/;"	e	enum:tls_wrap_ctx::__anon2
tls_wrap_ctx::TLS_WRAP_CRYPT	ssl_common.h	/^        TLS_WRAP_CRYPT, \/**< Control channel encryption and authentication *\/$/;"	e	enum:tls_wrap_ctx::__anon2
tls_wrap_ctx::TLS_WRAP_NONE	ssl_common.h	/^        TLS_WRAP_NONE = 0, \/**< No control channel wrapping *\/$/;"	e	enum:tls_wrap_ctx::__anon2
tls_wrap_ctx::mode	ssl_common.h	/^    } mode;                     \/**< Control channel wrapping mode *\/$/;"	m	struct:tls_wrap_ctx	typeref:enum:tls_wrap_ctx::__anon2	access:public
tls_wrap_ctx::opt	ssl_common.h	/^    struct crypto_options opt;  \/**< Crypto state *\/$/;"	m	struct:tls_wrap_ctx	typeref:struct:tls_wrap_ctx::crypto_options	access:public
tls_wrap_ctx::work	ssl_common.h	/^    struct buffer work;         \/**< Work buffer (only for --tls-crypt) *\/$/;"	m	struct:tls_wrap_ctx	typeref:struct:tls_wrap_ctx::buffer	access:public
tls_wrap_key	openvpn.h	/^    struct key_ctx_bi tls_wrap_key;$/;"	m	struct:key_schedule	typeref:struct:key_schedule::key_ctx_bi	access:public
tls_x509_clear_env	ssl_verify.c	/^tls_x509_clear_env(struct env_set *es)$/;"	f	signature:(struct env_set *es)
tls_x509_clear_env	ssl_verify.h	/^void tls_x509_clear_env(struct env_set *es);$/;"	p	signature:(struct env_set *es)
tmp_dir	options.h	/^    const char *tmp_dir;$/;"	m	struct:options	access:public
tmp_dir	ssl_common.h	/^    const char *tmp_dir;$/;"	m	struct:tls_options	access:public
tmp_int	openvpn.h	/^    struct interval tmp_int;$/;"	m	struct:context_2	typeref:struct:context_2::interval	access:public
to_link	openvpn.h	/^    struct buffer to_link;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
to_link_addr	openvpn.h	/^    struct link_socket_actual *to_link_addr;    \/* IP address of remote *\/$/;"	m	struct:context_2	typeref:struct:context_2::link_socket_actual	access:public
to_link_addr	ssl_common.h	/^    struct link_socket_actual to_link_addr;$/;"	m	struct:tls_multi	typeref:struct:tls_multi::link_socket_actual	access:public
to_tun	openvpn.h	/^    struct buffer to_tun;$/;"	m	struct:context_2	typeref:struct:context_2::buffer	access:public
token_decode	base64.c	/^token_decode(const char *token)$/;"	f	file:	signature:(const char *token)
top	multi.h	/^    struct context top;         \/**< Storage structure for process-wide$/;"	m	struct:multi_context	typeref:struct:multi_context::context	access:public
topology	options.h	/^    int topology; \/* one of the TOP_x values from proto.h *\/$/;"	m	struct:options	access:public
topology	tun.h	/^    int topology; \/* one of the TOP_x values *\/$/;"	m	struct:tuntap	access:public
tos	proto.h	/^    uint8_t tos;$/;"	m	struct:openvpn_iphdr	access:public
tot_len	proto.h	/^    uint16_t tot_len;$/;"	m	struct:openvpn_iphdr	access:public
transition_window	options.h	/^    int transition_window;$/;"	m	struct:options	access:public
transition_window	ssl_common.h	/^    int transition_window;$/;"	m	struct:tls_options	access:public
translate_cipher_name_from_openvpn	crypto.c	/^translate_cipher_name_from_openvpn(const char *cipher_name)$/;"	f	signature:(const char *cipher_name)
translate_cipher_name_from_openvpn	crypto_backend.h	/^const char *translate_cipher_name_from_openvpn(const char *cipher_name);$/;"	p	signature:(const char *cipher_name)
translate_cipher_name_to_openvpn	crypto.c	/^translate_cipher_name_to_openvpn(const char *cipher_name)$/;"	f	signature:(const char *cipher_name)
translate_cipher_name_to_openvpn	crypto_backend.h	/^const char *translate_cipher_name_to_openvpn(const char *cipher_name);$/;"	p	signature:(const char *cipher_name)
translate_mtu_discover_type_name	mtu.c	/^translate_mtu_discover_type_name(const char *name)$/;"	f	signature:(const char *name)
translate_mtu_discover_type_name	mtu.h	/^int translate_mtu_discover_type_name(const char *name);$/;"	p	signature:(const char *name)
try_load_engine	crypto_openssl.c	/^try_load_engine(const char *engine)$/;"	f	file:	signature:(const char *engine)
ttl	mtu.c	/^    uint32_t ttl;$/;"	m	struct:probehdr	file:	access:public
ttl	proto.h	/^    uint8_t ttl;$/;"	m	struct:openvpn_iphdr	access:public
tun	mtcp.c	/^    unsigned int tun;$/;"	m	struct:ta_iow_flags	file:	access:public
tun_abort	init.c	/^tun_abort(void)$/;"	f	signature:(void)
tun_adjust_frame_parameters	tun.h	/^tun_adjust_frame_parameters(struct frame *frame, int size)$/;"	f	signature:(struct frame *frame, int size)
tun_event_handle	tun.h	/^tun_event_handle(const struct tuntap *tt)$/;"	f	signature:(const struct tuntap *tt)
tun_finalize	tun.c	/^tun_finalize($/;"	f	signature:( HANDLE h, struct overlapped_io *io, struct buffer *buf)
tun_finalize	tun.h	/^int tun_finalize(HANDLE h, struct overlapped_io *io, struct buffer *buf);$/;"	p	signature:(HANDLE h, struct overlapped_io *io, struct buffer *buf)
tun_mtu	options.h	/^    int tun_mtu;         \/* MTU of tun device *\/$/;"	m	struct:connection_entry	access:public
tun_mtu_defined	options.h	/^    bool tun_mtu_defined; \/* true if user overriding parm with command line option *\/$/;"	m	struct:connection_entry	access:public
tun_mtu_extra	options.h	/^    int tun_mtu_extra;$/;"	m	struct:connection_entry	access:public
tun_mtu_extra_defined	options.h	/^    bool tun_mtu_extra_defined;$/;"	m	struct:connection_entry	access:public
tun_read_bytes	openvpn.h	/^    counter_type tun_read_bytes;$/;"	m	struct:context_2	access:public
tun_read_queue	tun.c	/^tun_read_queue(struct tuntap *tt, int maxsize)$/;"	f	signature:(struct tuntap *tt, int maxsize)
tun_read_queue	tun.h	/^int tun_read_queue(struct tuntap *tt, int maxsize);$/;"	p	signature:(struct tuntap *tt, int maxsize)
tun_rwflags	mtcp.h	/^    unsigned int tun_rwflags;$/;"	m	struct:multi_tcp	access:public
tun_set	tun.h	/^tun_set(struct tuntap *tt,$/;"	f	signature:(struct tuntap *tt, struct event_set *es, unsigned int rwflags, void *arg, unsigned int *persistent)
tun_show_debug	tun.c	/^tun_show_debug(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
tun_show_debug	tun.h	/^void tun_show_debug(struct tuntap *tt);$/;"	p	signature:(struct tuntap *tt)
tun_standby	tun.c	/^tun_standby(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
tun_standby	tun.h	/^bool tun_standby(struct tuntap *tt);$/;"	p	signature:(struct tuntap *tt)
tun_standby	tun.h	/^tun_standby(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
tun_standby_init	tun.c	/^tun_standby_init(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
tun_standby_init	tun.h	/^tun_standby_init(struct tuntap *tt)$/;"	f	signature:(struct tuntap *tt)
tun_standby_init	tun.h	/^void tun_standby_init(struct tuntap *tt);$/;"	p	signature:(struct tuntap *tt)
tun_stat	tun.c	/^tun_stat(const struct tuntap *tt, unsigned int rwflags, struct gc_arena *gc)$/;"	f	signature:(const struct tuntap *tt, unsigned int rwflags, struct gc_arena *gc)
tun_stat	tun.h	/^const char *tun_stat(const struct tuntap *tt, unsigned int rwflags, struct gc_arena *gc);$/;"	p	signature:(const struct tuntap *tt, unsigned int rwflags, struct gc_arena *gc)
tun_write_bytes	openvpn.h	/^    counter_type tun_write_bytes;$/;"	m	struct:context_2	access:public
tun_write_queue	tun.c	/^tun_write_queue(struct tuntap *tt, struct buffer *buf)$/;"	f	signature:(struct tuntap *tt, struct buffer *buf)
tun_write_queue	tun.h	/^int tun_write_queue(struct tuntap *tt, struct buffer *buf);$/;"	p	signature:(struct tuntap *tt, struct buffer *buf)
tun_write_win32	tun.h	/^tun_write_win32(struct tuntap *tt, struct buffer *buf)$/;"	f	signature:(struct tuntap *tt, struct buffer *buf)
tuncfg	tun.c	/^tuncfg(const char *dev, const char *dev_type, const char *dev_node, int persist_mode, const char *username, const char *groupname, const struct tuntap_options *options)$/;"	f	signature:(const char *dev, const char *dev_type, const char *dev_node, int persist_mode, const char *username, const char *groupname, const struct tuntap_options *options)
tuncfg	tun.h	/^void tuncfg(const char *dev, const char *dev_type, const char *dev_node,$/;"	p	signature:(const char *dev, const char *dev_type, const char *dev_node, int persist_mode, const char *username, const char *groupname, const struct tuntap_options *options)
tunnel_point_to_point	openvpn.c	/^tunnel_point_to_point(struct context *c)$/;"	f	file:	signature:(struct context *c)
tunnel_server	multi.c	/^tunnel_server(struct context *top)$/;"	f	signature:(struct context *top)
tunnel_server	multi.h	/^void tunnel_server(struct context *top);$/;"	p	signature:(struct context *top)
tunnel_server_tcp	mtcp.c	/^tunnel_server_tcp(struct context *top)$/;"	f	signature:(struct context *top)
tunnel_server_tcp	mtcp.h	/^void tunnel_server_tcp(struct context *top);$/;"	p	signature:(struct context *top)
tunnel_server_udp	mudp.c	/^tunnel_server_udp(struct context *top)$/;"	f	signature:(struct context *top)
tunnel_server_udp	mudp.h	/^void tunnel_server_udp(struct context *top);$/;"	p	signature:(struct context *top)
tunnel_server_udp_single_threaded	mudp.c	/^tunnel_server_udp_single_threaded(struct context *top)$/;"	f	file:	signature:(struct context *top)
tuntap	openvpn.h	/^    struct tuntap *tuntap;      \/**< Tun\/tap virtual network interface. *\/$/;"	m	struct:context_1	typeref:struct:context_1::tuntap	access:public
tuntap	tun.h	/^struct tuntap$/;"	s
tuntap::actual_name	tun.h	/^    char *actual_name; \/* actual name of TUN\/TAP dev, usually including unit number *\/$/;"	m	struct:tuntap	access:public
tuntap::adapter_index	tun.h	/^    DWORD adapter_index;$/;"	m	struct:tuntap	access:public
tuntap::adapter_netmask	tun.h	/^    in_addr_t adapter_netmask;$/;"	m	struct:tuntap	access:public
tuntap::broadcast	tun.h	/^    in_addr_t broadcast;$/;"	m	struct:tuntap	access:public
tuntap::did_ifconfig	tun.h	/^    bool did_ifconfig;$/;"	m	struct:tuntap	access:public
tuntap::did_ifconfig_ipv6_setup	tun.h	/^    bool did_ifconfig_ipv6_setup;$/;"	m	struct:tuntap	access:public
tuntap::did_ifconfig_setup	tun.h	/^    bool did_ifconfig_setup;$/;"	m	struct:tuntap	access:public
tuntap::fd	tun.h	/^    int fd; \/* file descriptor for TUN\/TAP dev *\/$/;"	m	struct:tuntap	access:public
tuntap::hand	tun.h	/^    HANDLE hand;$/;"	m	struct:tuntap	access:public
tuntap::ip_fd	tun.h	/^    int ip_fd;$/;"	m	struct:tuntap	access:public
tuntap::ipapi_context	tun.h	/^    ULONG ipapi_context;$/;"	m	struct:tuntap	access:public
tuntap::ipapi_context_defined	tun.h	/^    bool ipapi_context_defined;$/;"	m	struct:tuntap	access:public
tuntap::ipapi_instance	tun.h	/^    ULONG ipapi_instance;$/;"	m	struct:tuntap	access:public
tuntap::is_utun	tun.h	/^    bool is_utun;$/;"	m	struct:tuntap	access:public
tuntap::local	tun.h	/^    in_addr_t local;$/;"	m	struct:tuntap	access:public
tuntap::local_ipv6	tun.h	/^    struct in6_addr local_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr	access:public
tuntap::netbits_ipv6	tun.h	/^    int netbits_ipv6;$/;"	m	struct:tuntap	access:public
tuntap::options	tun.h	/^    struct tuntap_options options; \/* options set on command line *\/$/;"	m	struct:tuntap	typeref:struct:tuntap::tuntap_options	access:public
tuntap::persistent_if	tun.h	/^    bool persistent_if;         \/* if existed before, keep on program end *\/$/;"	m	struct:tuntap	access:public
tuntap::post_open_mtu	tun.h	/^    int post_open_mtu;$/;"	m	struct:tuntap	access:public
tuntap::reads	tun.h	/^    struct overlapped_io reads;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io	access:public
tuntap::remote_ipv6	tun.h	/^    struct in6_addr remote_ipv6;$/;"	m	struct:tuntap	typeref:struct:tuntap::in6_addr	access:public
tuntap::remote_netmask	tun.h	/^    in_addr_t remote_netmask;$/;"	m	struct:tuntap	access:public
tuntap::rw_handle	tun.h	/^    struct rw_handle rw_handle;$/;"	m	struct:tuntap	typeref:struct:tuntap::rw_handle	access:public
tuntap::rwflags_debug	tun.h	/^    unsigned int rwflags_debug;$/;"	m	struct:tuntap	access:public
tuntap::standby_iter	tun.h	/^    int standby_iter;$/;"	m	struct:tuntap	access:public
tuntap::topology	tun.h	/^    int topology; \/* one of the TOP_x values *\/$/;"	m	struct:tuntap	access:public
tuntap::txqueuelen	tun.h	/^    int txqueuelen;$/;"	m	struct:tuntap	access:public
tuntap::type	tun.h	/^    int type; \/* DEV_TYPE_x as defined in proto.h *\/$/;"	m	struct:tuntap	access:public
tuntap::writes	tun.h	/^    struct overlapped_io writes;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io	access:public
tuntap_abort	tun.h	/^tuntap_abort(int status)$/;"	f	signature:(int status)
tuntap_defined	tun.h	/^tuntap_defined(const struct tuntap *tt)$/;"	f	signature:(const struct tuntap *tt)
tuntap_options	options.h	/^    struct tuntap_options tuntap_options;$/;"	m	struct:options	typeref:struct:options::tuntap_options	access:public
tuntap_options	options.h	/^    struct tuntap_options tuntap_options;$/;"	m	struct:options_pre_pull	typeref:struct:options_pre_pull::tuntap_options	access:public
tuntap_options	tun.h	/^struct tuntap_options {$/;"	s
tuntap_options::dhcp_lease_time	tun.h	/^    int dhcp_lease_time;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dhcp_masq_custom_offset	tun.h	/^    bool dhcp_masq_custom_offset;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dhcp_masq_offset	tun.h	/^    int dhcp_masq_offset;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dhcp_options	tun.h	/^    bool dhcp_options;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dhcp_pre_release	tun.h	/^    bool dhcp_pre_release;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dhcp_renew	tun.h	/^    bool dhcp_renew;$/;"	m	struct:tuntap_options	access:public
tuntap_options::disable_nbt	tun.h	/^    bool disable_nbt;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dns	tun.h	/^    in_addr_t dns[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
tuntap_options::dns6	tun.h	/^    struct in6_addr dns6[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	typeref:struct:tuntap_options::in6_addr	access:public
tuntap_options::dns6_len	tun.h	/^    int dns6_len;$/;"	m	struct:tuntap_options	access:public
tuntap_options::dns_len	tun.h	/^    int dns_len;$/;"	m	struct:tuntap_options	access:public
tuntap_options::domain	tun.h	/^    const char *domain;      \/* DOMAIN (15) *\/$/;"	m	struct:tuntap_options	access:public
tuntap_options::dummy	tun.h	/^    int dummy; \/* not used *\/$/;"	m	struct:tuntap_options	access:public
tuntap_options::ip_win32_defined	tun.h	/^    bool ip_win32_defined;$/;"	m	struct:tuntap_options	access:public
tuntap_options::ip_win32_type	tun.h	/^    int ip_win32_type;$/;"	m	struct:tuntap_options	access:public
tuntap_options::msg_channel	tun.h	/^    HANDLE msg_channel;$/;"	m	struct:tuntap_options	access:public
tuntap_options::nbdd	tun.h	/^    in_addr_t nbdd[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
tuntap_options::nbdd_len	tun.h	/^    int nbdd_len;$/;"	m	struct:tuntap_options	access:public
tuntap_options::netbios_node_type	tun.h	/^    int netbios_node_type;   \/* NBT 1,2,4,8 (46) *\/$/;"	m	struct:tuntap_options	access:public
tuntap_options::netbios_scope	tun.h	/^    const char *netbios_scope; \/* NBS (47) *\/$/;"	m	struct:tuntap_options	access:public
tuntap_options::ntp	tun.h	/^    in_addr_t ntp[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
tuntap_options::ntp_len	tun.h	/^    int ntp_len;$/;"	m	struct:tuntap_options	access:public
tuntap_options::register_dns	tun.h	/^    bool register_dns;$/;"	m	struct:tuntap_options	access:public
tuntap_options::tap_sleep	tun.h	/^    int tap_sleep;$/;"	m	struct:tuntap_options	access:public
tuntap_options::txqueuelen	tun.h	/^    int txqueuelen;$/;"	m	struct:tuntap_options	access:public
tuntap_options::wins	tun.h	/^    in_addr_t wins[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
tuntap_options::wins_len	tun.h	/^    int wins_len;$/;"	m	struct:tuntap_options	access:public
tuntap_options_defined	options.h	/^    bool tuntap_options_defined;$/;"	m	struct:options_pre_pull	access:public
tuntap_owned	openvpn.h	/^    bool tuntap_owned;          \/**< Whether the tun\/tap interface should$/;"	m	struct:context_1	access:public
tuntap_stop	tun.h	/^tuntap_stop(int status)$/;"	f	signature:(int status)
tv	mtu.c	/^    struct timeval tv;$/;"	m	struct:probehdr	typeref:struct:probehdr::timeval	file:	access:public
tv	schedule.h	/^    struct timeval tv;           \/* wakeup time *\/$/;"	m	struct:schedule_entry	typeref:struct:schedule_entry::timeval	access:public
tv_add	otime.h	/^tv_add(struct timeval *dest, const struct timeval *src)$/;"	f	signature:(struct timeval *dest, const struct timeval *src)
tv_clear	otime.h	/^tv_clear(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
tv_defined	otime.h	/^tv_defined(const struct timeval *tv)$/;"	f	signature:(const struct timeval *tv)
tv_delta	otime.h	/^tv_delta(struct timeval *dest, const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(struct timeval *dest, const struct timeval *t1, const struct timeval *t2)
tv_eq	otime.h	/^tv_eq(const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2)
tv_ge	otime.h	/^tv_ge(const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2)
tv_gt	otime.h	/^tv_gt(const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2)
tv_le	otime.h	/^tv_le(const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2)
tv_lt	otime.h	/^tv_lt(const struct timeval *t1, const struct timeval *t2)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2)
tv_randomize	schedule.c	/^tv_randomize(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
tv_string	otime.c	/^tv_string(const struct timeval *tv, struct gc_arena *gc)$/;"	f	signature:(const struct timeval *tv, struct gc_arena *gc)
tv_string	otime.h	/^const char *tv_string(const struct timeval *tv, struct gc_arena *gc);$/;"	p	signature:(const struct timeval *tv, struct gc_arena *gc)
tv_string_abs	otime.c	/^tv_string_abs(const struct timeval *tv, struct gc_arena *gc)$/;"	f	signature:(const struct timeval *tv, struct gc_arena *gc)
tv_string_abs	otime.h	/^const char *tv_string_abs(const struct timeval *tv, struct gc_arena *gc);$/;"	p	signature:(const struct timeval *tv, struct gc_arena *gc)
tv_subtract	otime.h	/^tv_subtract(const struct timeval *tv1, const struct timeval *tv2, const unsigned int max_seconds)$/;"	f	signature:(const struct timeval *tv1, const struct timeval *tv2, const unsigned int max_seconds)
tv_to_ms_timeout	event.c	/^tv_to_ms_timeout(const struct timeval *tv)$/;"	f	file:	signature:(const struct timeval *tv)
tv_within_sigma	otime.h	/^tv_within_sigma(const struct timeval *t1, const struct timeval *t2, unsigned int sigma)$/;"	f	signature:(const struct timeval *t1, const struct timeval *t2, unsigned int sigma)
txqueuelen	tun.h	/^    int txqueuelen;$/;"	m	struct:tuntap	access:public
txqueuelen	tun.h	/^    int txqueuelen;$/;"	m	struct:tuntap_options	access:public
type	clinat.h	/^    int type;$/;"	m	struct:client_nat_entry	access:public
type	mroute.h	/^    uint8_t type;   \/* MR_ADDR\/MR_WITH flags *\/$/;"	m	struct:mroute_addr	access:public
type	options.c	/^    int type;$/;"	m	struct:in_src	file:	access:public
type	options.c	/^    int type;$/;"	m	struct:pull_filter	file:	access:public
type	pool.h	/^    int type;$/;"	m	struct:ifconfig_pool	access:public
type	tun.h	/^    int type; \/* DEV_TYPE_x as defined in proto.h *\/$/;"	m	struct:tuntap	access:public
u	manage.h	/^    union log_entry_union u;$/;"	m	struct:log_entry	typeref:union:log_entry::log_entry_union	access:public
u	options.c	/^    } u;$/;"	m	struct:in_src	typeref:union:in_src::__anon3	file:	access:public
u	proto.h	/^    } u;$/;"	m	struct:ip_tcp_udp_hdr	typeref:union:ip_tcp_udp_hdr::__anon1	access:public
udp	dhcp.h	/^    struct openvpn_udphdr udp;$/;"	m	struct:dhcp_full	typeref:struct:dhcp_full::openvpn_udphdr	access:public
udp	proto.h	/^        struct openvpn_udphdr udp;$/;"	m	union:ip_tcp_udp_hdr::__anon1	typeref:struct:ip_tcp_udp_hdr::__anon1::openvpn_udphdr	access:public
udp_checksum	dhcp.c	/^udp_checksum(const uint8_t *buf,$/;"	f	file:	signature:(const uint8_t *buf, const int len_udp, const uint8_t *src_addr, const uint8_t *dest_addr)
uid_gid_chroot_set	openvpn.h	/^    bool uid_gid_chroot_set;$/;"	m	struct:context_0	access:public
uid_gid_specified	openvpn.h	/^    bool uid_gid_specified;$/;"	m	struct:context_0	access:public
undo_redirect_default_route_to_vpn	route.c	/^undo_redirect_default_route_to_vpn(struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)$/;"	f	file:	signature:(struct route_list *rl, const struct tuntap *tt, unsigned int flags, const struct env_set *es)
ungenerate_prefix	multi.c	/^ungenerate_prefix(struct multi_instance *mi)$/;"	f	signature:(struct multi_instance *mi)
ungenerate_prefix	multi.h	/^ungenerate_prefix(struct multi_instance *mi);$/;"	p	signature:(struct multi_instance *mi)
unicodize	ntlm.c	/^unicodize(char *dst, const char *src)$/;"	f	file:	signature:(char *dst, const char *src)
uninit_management_callback	init.c	/^uninit_management_callback(void)$/;"	f	signature:(void)
uninit_management_callback	init.h	/^void uninit_management_callback(void);$/;"	p	signature:(void)
uninit_management_callback_multi	multi.c	/^uninit_management_callback_multi(struct multi_context *m)$/;"	f	signature:(struct multi_context *m)
uninit_management_callback_multi	multi.h	/^void uninit_management_callback_multi(struct multi_context *m);$/;"	p	signature:(struct multi_context *m)
uninit_options	options.c	/^uninit_options(struct options *o)$/;"	f	signature:(struct options *o)
uninit_options	options.h	/^void uninit_options(struct options *o);$/;"	p	signature:(struct options *o)
uninit_proxy	init.c	/^uninit_proxy(struct context *c)$/;"	f	file:	signature:(struct context *c)
uninit_proxy_dowork	init.c	/^uninit_proxy_dowork(struct context *c)$/;"	f	file:	signature:(struct context *c)
uninit_static	init.c	/^uninit_static(void)$/;"	f	signature:(void)
uninit_static	init.h	/^void uninit_static(void);$/;"	p	signature:(void)
uninit_win32	win32.c	/^uninit_win32(void)$/;"	f	signature:(void)
uninit_win32	win32.h	/^void uninit_win32(void);$/;"	p	signature:(void)
unit	packet_id.h	/^    int unit;$/;"	m	struct:packet_id_rec	access:public
unix_socket_get_peer_uid_gid	socket.c	/^unix_socket_get_peer_uid_gid(const socket_descriptor_t sd, int *uid, int *gid)$/;"	f	signature:(const socket_descriptor_t sd, int *uid, int *gid)
unix_socket_get_peer_uid_gid	socket.h	/^bool unix_socket_get_peer_uid_gid(const socket_descriptor_t sd, int *uid, int *gid);$/;"	p	signature:(const socket_descriptor_t sd, int *uid, int *gid)
unlikely	syshead.h	33;"	d
unlikely	syshead.h	36;"	d
unprintable_char_fmt	crypto.c	/^static const char unprintable_char_fmt[] =$/;"	v	file:
unsuccessful_attempts	options.h	/^    unsigned int unsuccessful_attempts;$/;"	m	struct:options	access:public
untrusted_addr	ssl_common.h	/^    struct link_socket_actual untrusted_addr;$/;"	m	struct:tls_session	typeref:struct:tls_session::link_socket_actual	access:public
unused	mroute.h	/^    uint8_t unused;$/;"	m	struct:mroute_addr	access:public
up	gremlin.c	/^static bool up;          \/* GLOBAL *\/$/;"	v	file:
up	manage.h	/^    struct user_pass up;$/;"	m	struct:man_settings	typeref:struct:man_settings::user_pass	access:public
up	proxy.h	/^    struct user_pass up;$/;"	m	struct:http_proxy_info	typeref:struct:http_proxy_info::user_pass	access:public
up_delay	options.h	/^    bool up_delay;$/;"	m	struct:options	access:public
up_high	gremlin.c	/^static const int up_high[] = { 600, 60, 10 };$/;"	v	file:
up_low	gremlin.c	/^static const int up_low[] =  {  60, 10,  5 };$/;"	v	file:
up_query	manage.h	/^    struct user_pass up_query;$/;"	m	struct:man_connection	typeref:struct:man_connection::user_pass	access:public
up_query_mode	manage.h	/^    int up_query_mode;$/;"	m	struct:man_connection	access:public
up_query_type	manage.h	/^    const char *up_query_type;$/;"	m	struct:man_connection	access:public
up_restart	options.h	/^    bool up_restart;$/;"	m	struct:options	access:public
up_script	options.h	/^    const char *up_script;$/;"	m	struct:options	access:public
update_mstat_n_clients	multi.c	/^update_mstat_n_clients(const int n_clients)$/;"	f	file:	signature:(const int n_clients)
update_now	otime.c	/^update_now(const time_t system_time)$/;"	f	signature:(const time_t system_time)
update_now	otime.h	/^void update_now(const time_t system_time);$/;"	p	signature:(const time_t system_time)
update_now_usec	otime.c	/^update_now_usec(struct timeval *tv)$/;"	f	signature:(struct timeval *tv)
update_now_usec	otime.h	/^void update_now_usec(struct timeval *tv);$/;"	p	signature:(struct timeval *tv)
update_options_ce_post	init.c	/^update_options_ce_post(struct options *options)$/;"	f	file:	signature:(struct options *options)
update_sofar	perf.c	/^update_sofar(struct perf *p)$/;"	f	file:	signature:(struct perf *p)
update_time	otime.h	/^update_time(void)$/;"	f	signature:(void)
update_timeout_random_component	openvpn.h	/^    time_t update_timeout_random_component;$/;"	m	struct:context_2	access:public
upper	sig.c	/^    const char *upper;$/;"	m	struct:signame	file:	access:public
urg_ptr	proto.h	/^    uint16_t urg_ptr;$/;"	m	struct:openvpn_tcphdr	access:public
usage	options.c	/^usage(void)$/;"	f	file:	signature:(void)
usage_message	options.c	/^static const char usage_message[] =$/;"	v	file:
usage_small	options.c	/^usage_small(void)$/;"	f	signature:(void)
usage_small	options.h	/^void usage_small(void);$/;"	p	signature:(void)
usage_version	options.c	/^usage_version(void)$/;"	f	file:	signature:(void)
use_iv	options.h	/^    bool use_iv;$/;"	m	struct:options	access:public
use_peer_id	options.h	/^    bool use_peer_id;$/;"	m	struct:options	access:public
use_peer_id	ssl_common.h	/^    bool use_peer_id;$/;"	m	struct:tls_multi	access:public
use_prediction_resistance	options.h	/^    bool use_prediction_resistance;$/;"	m	struct:options	access:public
use_syslog	error.c	/^static bool use_syslog;     \/* GLOBAL *\/$/;"	v	file:
usec_timer	interval.h	/^struct usec_timer {$/;"	s
usec_timer::end	interval.h	/^    struct timeval end;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval	access:public
usec_timer::start	interval.h	/^    struct timeval start;$/;"	m	struct:usec_timer	typeref:struct:usec_timer::timeval	access:public
usec_timer_end	interval.h	/^usec_timer_end(struct usec_timer *obj)$/;"	f	signature:(struct usec_timer *obj)
usec_timer_interval	interval.h	/^usec_timer_interval(struct usec_timer *obj)$/;"	f	signature:(struct usec_timer *obj)
usec_timer_interval_defined	interval.h	/^usec_timer_interval_defined(struct usec_timer *obj)$/;"	f	signature:(struct usec_timer *obj)
usec_timer_start	interval.h	/^usec_timer_start(struct usec_timer *obj)$/;"	f	signature:(struct usec_timer *obj)
user	misc.h	/^    const char *user;$/;"	m	struct:auth_challenge_info	access:public
user_agent	proxy.h	/^    const char *user_agent;$/;"	m	struct:http_proxy_options	access:public
user_pass	misc.h	/^struct user_pass$/;"	s
user_pass::defined	misc.h	/^    bool defined;$/;"	m	struct:user_pass	access:public
user_pass::nocache	misc.h	/^    bool nocache;$/;"	m	struct:user_pass	access:public
user_pass::password	misc.h	/^    char password[USER_PASS_LEN];$/;"	m	struct:user_pass	access:public
user_pass::username	misc.h	/^    char username[USER_PASS_LEN];$/;"	m	struct:user_pass	access:public
user_pass::wait_for_push	misc.h	/^    bool wait_for_push; \/* true if this object is waiting for a push-reply *\/$/;"	m	struct:user_pass	access:public
user_script_used	options.h	/^    bool user_script_used;$/;"	m	struct:options	access:public
username	misc.h	/^    char username[USER_PASS_LEN];$/;"	m	struct:user_pass	access:public
username	options.h	/^    const char *username;$/;"	m	struct:options	access:public
username	platform.h	/^    const char *username;$/;"	m	struct:platform_state_user	access:public
username_password_as_base64	proxy.c	/^username_password_as_base64(const struct http_proxy_info *p,$/;"	f	file:	signature:(const struct http_proxy_info *p, struct gc_arena *gc)
utun_open_helper	tun.c	/^utun_open_helper(struct ctl_info ctlInfo, int utunnum)$/;"	f	file:	signature:(struct ctl_info ctlInfo, int utunnum)
v4	mroute.h	/^        } v4;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon5	access:public
v4	mroute.h	104;"	d
v4mappedv6	mroute.h	/^        } v4mappedv6;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon7	access:public
v4mappedv6	mroute.h	106;"	d
v6	mroute.h	/^        } v6;$/;"	m	union:mroute_addr::__anon4	typeref:struct:mroute_addr::__anon4::__anon6	access:public
v6	mroute.h	105;"	d
vaddr_handle	multi.h	/^    ifconfig_pool_handle vaddr_handle;$/;"	m	struct:multi_instance	access:public
validate_peer_info_line	misc.c	/^validate_peer_info_line(char *line)$/;"	f	signature:(char *line)
validate_peer_info_line	misc.h	/^bool validate_peer_info_line(char *line);$/;"	p	signature:(char *line)
valign4	buffer.c	/^valign4(const struct buffer *buf, const char *file, const int line)$/;"	f	signature:(const struct buffer *buf, const char *file, const int line)
valign4	buffer.h	/^void valign4(const struct buffer *buf, const char *file, const int line);$/;"	p	signature:(const struct buffer *buf, const char *file, const int line)
value	list.h	/^    void *value;$/;"	m	struct:hash_element	access:public
value	sig.c	/^    int value;$/;"	m	struct:signame	file:	access:public
verbosity	options.h	/^    int verbosity;$/;"	m	struct:options	access:public
verified	ssl_common.h	/^    bool verified;              \/* true if peer certificate was verified against CA *\/$/;"	m	struct:tls_session	access:public
verify_255_255_255_252	tun.c	/^verify_255_255_255_252(in_addr_t local, in_addr_t remote)$/;"	f	signature:(in_addr_t local, in_addr_t remote)
verify_255_255_255_252	tun.h	/^void verify_255_255_255_252(in_addr_t local, in_addr_t remote);$/;"	p	signature:(in_addr_t local, in_addr_t remote)
verify_align_4	buffer.h	946;"	d
verify_align_4	buffer.h	948;"	d
verify_callback	ssl_verify_mbedtls.c	/^verify_callback(void *session_obj, mbedtls_x509_crt *cert, int cert_depth,$/;"	f	signature:(void *session_obj, mbedtls_x509_crt *cert, int cert_depth, uint32_t *flags)
verify_callback	ssl_verify_mbedtls.h	/^int verify_callback(void *session_obj, mbedtls_x509_crt *cert, int cert_depth,$/;"	p	signature:(void *session_obj, mbedtls_x509_crt *cert, int cert_depth, uint32_t *flags)
verify_callback	ssl_verify_openssl.c	/^verify_callback(int preverify_ok, X509_STORE_CTX *ctx)$/;"	f	signature:(int preverify_ok, X509_STORE_CTX *ctx)
verify_callback	ssl_verify_openssl.h	/^int verify_callback(int preverify_ok, X509_STORE_CTX *ctx);$/;"	p	signature:(int preverify_ok, X509_STORE_CTX *ctx)
verify_cert	ssl_verify.c	/^verify_cert(struct tls_session *session, openvpn_x509_cert_t *cert, int cert_depth)$/;"	f	signature:(struct tls_session *session, openvpn_x509_cert_t *cert, int cert_depth)
verify_cert	ssl_verify_backend.h	/^result_t verify_cert(struct tls_session *session, openvpn_x509_cert_t *cert, int cert_depth);$/;"	p	signature:(struct tls_session *session, openvpn_x509_cert_t *cert, int cert_depth)
verify_cert_call_command	ssl_verify.c	/^verify_cert_call_command(const char *verify_command, struct env_set *es,$/;"	f	file:	signature:(const char *verify_command, struct env_set *es, int cert_depth, openvpn_x509_cert_t *cert, char *subject, const char *verify_export_cert)
verify_cert_call_plugin	ssl_verify.c	/^verify_cert_call_plugin(const struct plugin_list *plugins, struct env_set *es,$/;"	f	file:	signature:(const struct plugin_list *plugins, struct env_set *es, int cert_depth, openvpn_x509_cert_t *cert, char *subject)
verify_cert_export_cert	ssl_verify.c	/^verify_cert_export_cert(openvpn_x509_cert_t *peercert, const char *tmp_dir, struct gc_arena *gc)$/;"	f	file:	signature:(openvpn_x509_cert_t *peercert, const char *tmp_dir, struct gc_arena *gc)
verify_cert_set_env	ssl_verify.c	/^verify_cert_set_env(struct env_set *es, openvpn_x509_cert_t *peer_cert, int cert_depth,$/;"	f	file:	signature:(struct env_set *es, openvpn_x509_cert_t *peer_cert, int cert_depth, const char *subject, const char *common_name, const struct x509_track *x509_track)
verify_check_crl_dir	ssl_verify.c	/^verify_check_crl_dir(const char *crl_dir, openvpn_x509_cert_t *cert)$/;"	f	file:	signature:(const char *crl_dir, openvpn_x509_cert_t *cert)
verify_command	ssl_common.h	/^    const char *verify_command;$/;"	m	struct:tls_options	access:public
verify_common_subnet	helper.c	/^verify_common_subnet(const char *opt, const in_addr_t a, const in_addr_t b, const in_addr_t subnet)$/;"	f	file:	signature:(const char *opt, const in_addr_t a, const in_addr_t b, const in_addr_t subnet)
verify_export_cert	ssl_common.h	/^    const char *verify_export_cert;$/;"	m	struct:tls_options	access:public
verify_final_auth_checks	ssl_verify.c	/^verify_final_auth_checks(struct tls_multi *multi, struct tls_session *session)$/;"	f	signature:(struct tls_multi *multi, struct tls_session *session)
verify_final_auth_checks	ssl_verify.h	/^void verify_final_auth_checks(struct tls_multi *multi, struct tls_session *session);$/;"	p	signature:(struct tls_multi *multi, struct tls_session *session)
verify_fix_key2	crypto.c	/^verify_fix_key2(struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)$/;"	f	signature:(struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)
verify_fix_key2	crypto.h	/^void verify_fix_key2(struct key2 *key2, const struct key_type *kt, const char *shared_secret_file);$/;"	p	signature:(struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)
verify_hash	options.h	/^    uint8_t *verify_hash;$/;"	m	struct:options	access:public
verify_hash	ssl_common.h	/^    uint8_t *verify_hash;$/;"	m	struct:tls_options	access:public
verify_hash_algo	options.h	/^    hash_algo_type verify_hash_algo;$/;"	m	struct:options	access:public
verify_hash_algo	ssl_common.h	/^    hash_algo_type verify_hash_algo;$/;"	m	struct:tls_options	access:public
verify_maxlevel	ssl_common.h	/^    int verify_maxlevel;$/;"	m	struct:tls_session	access:public
verify_peer_cert	ssl_verify.c	/^verify_peer_cert(const struct tls_options *opt, openvpn_x509_cert_t *peer_cert,$/;"	f	file:	signature:(const struct tls_options *opt, openvpn_x509_cert_t *peer_cert, const char *subject, const char *common_name)
verify_permission	options.c	/^verify_permission(const char *name,$/;"	f	file:	signature:(const char *name, const char *file, int line, const unsigned int type, const unsigned int allowed, unsigned int *found, const int msglevel, struct options *options)
verify_user_pass	ssl_verify.c	/^verify_user_pass(struct user_pass *up, struct tls_multi *multi,$/;"	f	signature:(struct user_pass *up, struct tls_multi *multi, struct tls_session *session)
verify_user_pass	ssl_verify.h	/^void verify_user_pass(struct user_pass *up, struct tls_multi *multi,$/;"	p	signature:(struct user_pass *up, struct tls_multi *multi, struct tls_session *session)
verify_user_pass_management	ssl_verify.c	/^verify_user_pass_management(struct tls_session *session, const struct user_pass *up, const char *raw_username)$/;"	f	file:	signature:(struct tls_session *session, const struct user_pass *up, const char *raw_username)
verify_user_pass_plugin	ssl_verify.c	/^verify_user_pass_plugin(struct tls_session *session, const struct user_pass *up, const char *raw_username)$/;"	f	file:	signature:(struct tls_session *session, const struct user_pass *up, const char *raw_username)
verify_user_pass_script	ssl_verify.c	/^verify_user_pass_script(struct tls_session *session, const struct user_pass *up)$/;"	f	file:	signature:(struct tls_session *session, const struct user_pass *up)
verify_x509_name	options.h	/^    const char *verify_x509_name;$/;"	m	struct:options	access:public
verify_x509_name	ssl_common.h	/^    const char *verify_x509_name;$/;"	m	struct:tls_options	access:public
verify_x509_type	options.h	/^    int verify_x509_type;$/;"	m	struct:options	access:public
verify_x509_type	ssl_common.h	/^    int verify_x509_type;$/;"	m	struct:tls_options	access:public
version_len	proto.h	/^    uint8_t version_len;$/;"	m	struct:openvpn_iphdr	access:public
version_prio	proto.h	/^    uint8_t version_prio;$/;"	m	struct:openvpn_ipv6hdr	access:public
vhash	multi.h	/^    struct hash *vhash;         \/**< VPN tunnel instances indexed by$/;"	m	struct:multi_context	typeref:struct:multi_context::hash	access:public
virtual_hash_size	options.h	/^    int virtual_hash_size;$/;"	m	struct:options	access:public
virtual_output	status.h	/^struct virtual_output {$/;"	s
virtual_output::arg	status.h	/^    void *arg;$/;"	m	struct:virtual_output	access:public
virtual_output::flags_default	status.h	/^    unsigned int flags_default;$/;"	m	struct:virtual_output	access:public
virtual_output::func	status.h	/^    void (*func) (void *arg, const unsigned int flags, const char *str);$/;"	m	struct:virtual_output	access:public
virtual_output_callback_func	manage.c	/^virtual_output_callback_func(void *arg, const unsigned int flags, const char *str)$/;"	f	file:	signature:(void *arg, const unsigned int flags, const char *str)
virtual_output_print	status.h	/^virtual_output_print(const struct virtual_output *vo, const unsigned int flags, const char *str)$/;"	f	signature:(const struct virtual_output *vo, const unsigned int flags, const char *str)
void_ptr_compare_function	list.c	/^void_ptr_compare_function(const void *key1, const void *key2)$/;"	f	signature:(const void *key1, const void *key2)
void_ptr_compare_function	list.h	/^bool void_ptr_compare_function(const void *key1, const void *key2);$/;"	p	signature:(const void *key1, const void *key2)
void_ptr_hash_function	list.c	/^void_ptr_hash_function(const void *key, uint32_t iv)$/;"	f	signature:(const void *key, uint32_t iv)
void_ptr_hash_function	list.h	/^uint32_t void_ptr_hash_function(const void *key, uint32_t iv);$/;"	p	signature:(const void *key, uint32_t iv)
vout	manage.h	/^    struct virtual_output vout;$/;"	m	struct:man_persist	typeref:struct:man_persist::virtual_output	access:public
vout	status.h	/^    const struct virtual_output *vout;$/;"	m	struct:status_output	typeref:struct:status_output::virtual_output	access:public
wait	event.h	/^    int (*wait)(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen);$/;"	m	struct:event_set_functions	access:public
wait_for_connect	openvpn.h	/^    struct event_timeout wait_for_connect;$/;"	m	struct:context_2	typeref:struct:context_2::event_timeout	access:public
wait_for_push	misc.h	/^    bool wait_for_push; \/* true if this object is waiting for a push-reply *\/$/;"	m	struct:user_pass	access:public
wait_signal	event.h	/^wait_signal(struct event_set *es, void *arg)$/;"	f	signature:(struct event_set *es, void *arg)
wait_status_string	forward.c	/^wait_status_string(struct context *c, struct gc_arena *gc)$/;"	f	signature:(struct context *c, struct gc_arena *gc)
wait_status_string	forward.h	/^const char *wait_status_string(struct context *c, struct gc_arena *gc);$/;"	p	signature:(struct context *c, struct gc_arena *gc)
wakeup	fragment.h	/^    struct event_timeout wakeup; \/**< Timeout structure used by the main$/;"	m	struct:fragment_master	typeref:struct:fragment_master::event_timeout	access:public
wakeup	multi.h	/^    struct timeval wakeup;     \/* absolute time *\/$/;"	m	struct:multi_instance	typeref:struct:multi_instance::timeval	access:public
wakeup	multi.h	/^    struct timeval wakeup;$/;"	m	struct:deferred_signal_schedule_entry	typeref:struct:deferred_signal_schedule_entry::timeval	access:public
wakeup	shaper.h	/^    struct timeval wakeup;$/;"	m	struct:shaper	typeref:struct:shaper::timeval	access:public
warn_on_use_of_common_subnets	tun.c	/^warn_on_use_of_common_subnets(void)$/;"	f	signature:(void)
warn_on_use_of_common_subnets	tun.h	/^void warn_on_use_of_common_subnets(void);$/;"	p	signature:(void)
we_append_event	event.c	/^we_append_event(struct we_set *wes, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct we_set *wes, event_t event, unsigned int rwflags, void *arg)
we_ctl	event.c	/^we_ctl(struct event_set *es, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct event_set *es, event_t event, unsigned int rwflags, void *arg)
we_del	event.c	/^we_del(struct event_set *es, event_t event)$/;"	f	file:	signature:(struct event_set *es, event_t event)
we_del_event	event.c	/^we_del_event(struct we_set *wes, event_t event)$/;"	f	file:	signature:(struct we_set *wes, event_t event)
we_del_index	event.c	/^we_del_index(struct we_set *wes, int index)$/;"	f	file:	signature:(struct we_set *wes, int index)
we_free	event.c	/^we_free(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
we_get_rw_indices	event.c	/^we_get_rw_indices(struct we_set *wes, event_t event, int *ri, int *wi)$/;"	f	file:	signature:(struct we_set *wes, event_t event, int *ri, int *wi)
we_init	event.c	/^we_init(int *maxevents, unsigned int flags)$/;"	f	file:	signature:(int *maxevents, unsigned int flags)
we_reset	event.c	/^we_reset(struct event_set *es)$/;"	f	file:	signature:(struct event_set *es)
we_set	event.c	/^struct we_set$/;"	s	file:
we_set::capacity	event.c	/^    int capacity;$/;"	m	struct:we_set	file:	access:public
we_set::esr	event.c	/^    struct event_set_return *esr;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_return	file:	access:public
we_set::events	event.c	/^    HANDLE *events;$/;"	m	struct:we_set	file:	access:public
we_set::fast	event.c	/^    bool fast;$/;"	m	struct:we_set	file:	access:public
we_set::func	event.c	/^    struct event_set_functions func;$/;"	m	struct:we_set	typeref:struct:we_set::event_set_functions	file:	access:public
we_set::n_events	event.c	/^    int n_events;$/;"	m	struct:we_set	file:	access:public
we_set_event	event.c	/^we_set_event(struct we_set *wes, int i, event_t event, unsigned int rwflags, void *arg)$/;"	f	file:	signature:(struct we_set *wes, int i, event_t event, unsigned int rwflags, void *arg)
we_wait	event.c	/^we_wait(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)$/;"	f	file:	signature:(struct event_set *es, const struct timeval *tv, struct event_set_return *out, int outlen)
wide_cmd_line	win32.c	/^wide_cmd_line(const struct argv *a, struct gc_arena *gc)$/;"	f	file:	signature:(const struct argv *a, struct gc_arena *gc)
wide_string	win32.c	/^wide_string(const char *utf8, struct gc_arena *gc)$/;"	f	signature:(const char *utf8, struct gc_arena *gc)
wide_string	win32.h	/^WCHAR *wide_string(const char *utf8, struct gc_arena *gc);$/;"	p	signature:(const char *utf8, struct gc_arena *gc)
win32_is_64bit	win32.c	/^win32_is_64bit(void)$/;"	f	signature:(void)
win32_keyboard_get	win32.c	/^win32_keyboard_get(struct win32_signal *ws)$/;"	f	file:	signature:(struct win32_signal *ws)
win32_pause	win32.c	/^win32_pause(struct win32_signal *ws)$/;"	f	signature:(struct win32_signal *ws)
win32_pause	win32.h	/^void win32_pause(struct win32_signal *ws);$/;"	p	signature:(struct win32_signal *ws)
win32_service_interrupt	win32.c	/^win32_service_interrupt(struct win32_signal *ws)$/;"	f	signature:(struct win32_signal *ws)
win32_service_interrupt	win32.h	/^bool win32_service_interrupt(struct win32_signal *ws);$/;"	p	signature:(struct win32_signal *ws)
win32_signal	win32.c	/^struct win32_signal win32_signal; \/* GLOBAL *\/$/;"	v	typeref:struct:win32_signal
win32_signal	win32.h	/^struct win32_signal {$/;"	s
win32_signal::console_mode_save	win32.h	/^    DWORD console_mode_save;$/;"	m	struct:win32_signal	access:public
win32_signal::console_mode_save_defined	win32.h	/^    bool console_mode_save_defined;$/;"	m	struct:win32_signal	access:public
win32_signal::in	win32.h	/^    struct rw_handle in;$/;"	m	struct:win32_signal	typeref:struct:win32_signal::rw_handle	access:public
win32_signal::mode	win32.h	/^    int mode;$/;"	m	struct:win32_signal	access:public
win32_signal_clear	win32.c	/^win32_signal_clear(struct win32_signal *ws)$/;"	f	signature:(struct win32_signal *ws)
win32_signal_clear	win32.h	/^void win32_signal_clear(struct win32_signal *ws);$/;"	p	signature:(struct win32_signal *ws)
win32_signal_close	win32.c	/^win32_signal_close(struct win32_signal *ws)$/;"	f	signature:(struct win32_signal *ws)
win32_signal_close	win32.h	/^void win32_signal_close(struct win32_signal *ws);$/;"	p	signature:(struct win32_signal *ws)
win32_signal_get	win32.c	/^win32_signal_get(struct win32_signal *ws)$/;"	f	signature:(struct win32_signal *ws)
win32_signal_get	win32.h	/^int win32_signal_get(struct win32_signal *ws);$/;"	p	signature:(struct win32_signal *ws)
win32_signal_open	win32.c	/^win32_signal_open(struct win32_signal *ws,$/;"	f	signature:(struct win32_signal *ws, int force, const char *exit_event_name, bool exit_event_initial_state)
win32_signal_open	win32.h	/^void win32_signal_open(struct win32_signal *ws,$/;"	p	signature:(struct win32_signal *ws, int force, const char *exit_event_name, bool exit_event_initial_state)
win32_version_info	win32.c	/^win32_version_info(void)$/;"	f	signature:(void)
win32_version_info	win32.h	/^int win32_version_info(void);$/;"	p	signature:(void)
win32_version_string	win32.c	/^win32_version_string(struct gc_arena *gc, bool add_name)$/;"	f	signature:(struct gc_arena *gc, bool add_name)
win32_version_string	win32.h	/^const char *win32_version_string(struct gc_arena *gc, bool add_name);$/;"	p	signature:(struct gc_arena *gc, bool add_name)
win_block_dns_service	win32.c	/^win_block_dns_service(bool add, int index, const HANDLE pipe)$/;"	f	file:	signature:(bool add, int index, const HANDLE pipe)
win_ctrl_handler	win32.c	/^win_ctrl_handler(DWORD signum)$/;"	f	file:	signature:(DWORD signum)
win_get_tempdir	win32.c	/^win_get_tempdir(void)$/;"	f	signature:(void)
win_get_tempdir	win32.h	/^const char *win_get_tempdir(void);$/;"	p	signature:(void)
win_safe_filename	win32.c	/^win_safe_filename(const char *fn)$/;"	f	signature:(const char *fn)
win_safe_filename	win32.h	/^bool win_safe_filename(const char *fn);$/;"	p	signature:(const char *fn)
win_sys_path	win32.c	/^static char *win_sys_path = NULL; \/* GLOBAL *\/$/;"	v	file:
win_trigger_event	win32.c	/^win_trigger_event(struct win32_signal *ws)$/;"	f	file:	signature:(struct win32_signal *ws)
win_wfp_block_dns	win32.c	/^win_wfp_block_dns(const NET_IFINDEX index, const HANDLE msg_channel)$/;"	f	signature:(const NET_IFINDEX index, const HANDLE msg_channel)
win_wfp_block_dns	win32.h	/^bool win_wfp_block_dns(const NET_IFINDEX index, const HANDLE msg_channel);$/;"	p	signature:(const NET_IFINDEX index, const HANDLE msg_channel)
win_wfp_uninit	win32.c	/^win_wfp_uninit(const NET_IFINDEX index, const HANDLE msg_channel)$/;"	f	signature:(const NET_IFINDEX index, const HANDLE msg_channel)
win_wfp_uninit	win32.h	/^bool win_wfp_uninit(const NET_IFINDEX index, const HANDLE msg_channel);$/;"	p	signature:(const NET_IFINDEX index, const HANDLE msg_channel)
window	proto.h	/^    uint16_t window;$/;"	m	struct:openvpn_tcphdr	access:public
window_title	win32.c	/^struct window_title window_title; \/* GLOBAL*\/$/;"	v	typeref:struct:window_title
window_title	win32.h	/^struct window_title$/;"	s
window_title::old_window_title	win32.h	/^    char old_window_title [256];$/;"	m	struct:window_title	access:public
window_title::saved	win32.h	/^    bool saved;$/;"	m	struct:window_title	access:public
window_title_clear	win32.c	/^window_title_clear(struct window_title *wt)$/;"	f	signature:(struct window_title *wt)
window_title_clear	win32.h	/^void window_title_clear(struct window_title *wt);$/;"	p	signature:(struct window_title *wt)
window_title_generate	win32.c	/^window_title_generate(const char *title)$/;"	f	signature:(const char *title)
window_title_generate	win32.h	/^void window_title_generate(const char *title);$/;"	p	signature:(const char *title)
window_title_restore	win32.c	/^window_title_restore(const struct window_title *wt)$/;"	f	signature:(const struct window_title *wt)
window_title_restore	win32.h	/^void window_title_restore(const struct window_title *wt);$/;"	p	signature:(const struct window_title *wt)
window_title_save	win32.c	/^window_title_save(struct window_title *wt)$/;"	f	signature:(struct window_title *wt)
window_title_save	win32.h	/^void window_title_save(struct window_title *wt);$/;"	p	signature:(struct window_title *wt)
windows_route_find_if_index	route.c	/^windows_route_find_if_index(const struct route_ipv4 *r, const struct tuntap *tt)$/;"	f	file:	signature:(const struct route_ipv4 *r, const struct tuntap *tt)
wins	tun.h	/^    in_addr_t wins[N_DHCP_ADDR];$/;"	m	struct:tuntap_options	access:public
wins_len	tun.h	/^    int wins_len;$/;"	m	struct:tuntap_options	access:public
wipe_auth_token	ssl_verify.c	/^wipe_auth_token(struct tls_multi *multi)$/;"	f	file:	signature:(struct tls_multi *multi)
wmain	openvpn.c	/^wmain(int argc, wchar_t *wargv[])$/;"	f	signature:(int argc, wchar_t *wargv[])
wmem	lzo.h	/^    lzo_voidp wmem;$/;"	m	struct:lzo_compress_workspace	access:public
wmem_size	lzo.h	/^    int wmem_size;$/;"	m	struct:lzo_compress_workspace	access:public
word	list.c	/^    const char *word;$/;"	m	struct:word	file:	access:public
word	list.c	/^struct word$/;"	s	file:
word::n	list.c	/^    int n;$/;"	m	struct:word	file:	access:public
word::word	list.c	/^    const char *word;$/;"	m	struct:word	file:	access:public
word_compare_function	list.c	/^word_compare_function(const void *key1, const void *key2)$/;"	f	file:	signature:(const void *key1, const void *key2)
word_hash_function	list.c	/^word_hash_function(const void *key, uint32_t iv)$/;"	f	file:	signature:(const void *key, uint32_t iv)
work	ssl_common.h	/^    struct buffer work;         \/**< Work buffer (only for --tls-crypt) *\/$/;"	m	struct:tls_wrap_ctx	typeref:struct:tls_wrap_ctx::buffer	access:public
write	win32.h	/^    HANDLE write;$/;"	m	struct:rw_handle	access:public
write_control_auth	ssl.c	/^write_control_auth(struct tls_session *session,$/;"	f	file:	signature:(struct tls_session *session, struct key_state *ks, struct buffer *buf, struct link_socket_actual **to_link_addr, int opcode, int max_ack, bool prepend_ack)
write_dhcp_str	tun.c	/^write_dhcp_str(struct buffer *buf, const int type, const char *str, bool *error)$/;"	f	file:	signature:(struct buffer *buf, const int type, const char *str, bool *error)
write_dhcp_u32_array	tun.c	/^write_dhcp_u32_array(struct buffer *buf, const int type, const uint32_t *data, const unsigned int len, bool *error)$/;"	f	file:	signature:(struct buffer *buf, const int type, const uint32_t *data, const unsigned int len, bool *error)
write_dhcp_u8	tun.c	/^write_dhcp_u8(struct buffer *buf, const int type, const int data, bool *error)$/;"	f	file:	signature:(struct buffer *buf, const int type, const int data, bool *error)
write_empty_string	ssl.c	/^write_empty_string(struct buffer *buf)$/;"	f	file:	signature:(struct buffer *buf)
write_key	crypto.c	/^write_key(const struct key *key, const struct key_type *kt,$/;"	f	signature:(const struct key *key, const struct key_type *kt, struct buffer *buf)
write_key	crypto.h	/^bool write_key(const struct key *key, const struct key_type *kt,$/;"	p	signature:(const struct key *key, const struct key_type *kt, struct buffer *buf)
write_key_file	crypto.c	/^write_key_file(const int nkeys, const char *filename)$/;"	f	signature:(const int nkeys, const char *filename)
write_key_file	crypto.h	/^int write_key_file(const int nkeys, const char *filename);$/;"	p	signature:(const int nkeys, const char *filename)
write_peer_info_file	manage.h	/^    char *write_peer_info_file;$/;"	m	struct:man_settings	access:public
write_pid	openvpn.c	/^write_pid(const char *filename)$/;"	f	file:	signature:(const char *filename)
write_string	ssl.c	/^write_string(struct buffer *buf, const char *str, const int maxlen)$/;"	f	file:	signature:(struct buffer *buf, const char *str, const int maxlen)
write_tun	tun.c	/^write_tun(struct tuntap *tt, uint8_t *buf, int len)$/;"	f	signature:(struct tuntap *tt, uint8_t *buf, int len)
write_tun	tun.h	/^int write_tun(struct tuntap *tt, uint8_t *buf, int len);$/;"	p	signature:(struct tuntap *tt, uint8_t *buf, int len)
write_tun_buffered	tun.h	/^write_tun_buffered(struct tuntap *tt, struct buffer *buf)$/;"	f	signature:(struct tuntap *tt, struct buffer *buf)
write_tun_header	tun.c	/^write_tun_header(struct tuntap *tt, uint8_t *buf, int len)$/;"	f	signature:(struct tuntap *tt, uint8_t *buf, int len)
writefds	event.c	/^    fd_set writefds;$/;"	m	struct:se_set	file:	access:public
writepid	options.h	/^    const char *writepid;$/;"	m	struct:options	access:public
writes	socket.h	/^    struct overlapped_io writes;$/;"	m	struct:link_socket	typeref:struct:link_socket::overlapped_io	access:public
writes	tun.h	/^    struct overlapped_io writes;$/;"	m	struct:tuntap	typeref:struct:tuntap::overlapped_io	access:public
wsa_state	win32.c	/^static struct WSAData wsa_state; \/* GLOBAL *\/$/;"	v	typeref:struct:WSAData	file:
wu	comp.h	/^    union compress_workspace_union wu;$/;"	m	struct:compress_context	typeref:union:compress_context::compress_workspace_union	access:public
x509_get_fingerprint	ssl_verify_mbedtls.c	/^x509_get_fingerprint(const mbedtls_md_info_t *md_info, mbedtls_x509_crt *cert,$/;"	f	file:	signature:(const mbedtls_md_info_t *md_info, mbedtls_x509_crt *cert, struct gc_arena *gc)
x509_get_sha1_fingerprint	ssl_verify_backend.h	/^struct buffer x509_get_sha1_fingerprint(openvpn_x509_cert_t *cert,$/;"	p	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
x509_get_sha1_fingerprint	ssl_verify_mbedtls.c	/^x509_get_sha1_fingerprint(mbedtls_x509_crt *cert, struct gc_arena *gc)$/;"	f	signature:(mbedtls_x509_crt *cert, struct gc_arena *gc)
x509_get_sha1_fingerprint	ssl_verify_openssl.c	/^x509_get_sha1_fingerprint(X509 *cert, struct gc_arena *gc)$/;"	f	signature:(X509 *cert, struct gc_arena *gc)
x509_get_sha256_fingerprint	ssl_verify_backend.h	/^struct buffer x509_get_sha256_fingerprint(openvpn_x509_cert_t *cert,$/;"	p	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
x509_get_sha256_fingerprint	ssl_verify_mbedtls.c	/^x509_get_sha256_fingerprint(mbedtls_x509_crt *cert, struct gc_arena *gc)$/;"	f	signature:(mbedtls_x509_crt *cert, struct gc_arena *gc)
x509_get_sha256_fingerprint	ssl_verify_openssl.c	/^x509_get_sha256_fingerprint(X509 *cert, struct gc_arena *gc)$/;"	f	signature:(X509 *cert, struct gc_arena *gc)
x509_get_subject	ssl_verify_backend.h	/^char *x509_get_subject(openvpn_x509_cert_t *cert, struct gc_arena *gc);$/;"	p	signature:(openvpn_x509_cert_t *cert, struct gc_arena *gc)
x509_get_subject	ssl_verify_mbedtls.c	/^x509_get_subject(mbedtls_x509_crt *cert, struct gc_arena *gc)$/;"	f	signature:(mbedtls_x509_crt *cert, struct gc_arena *gc)
x509_get_subject	ssl_verify_openssl.c	/^x509_get_subject(X509 *cert, struct gc_arena *gc)$/;"	f	signature:(X509 *cert, struct gc_arena *gc)
x509_setenv	ssl_verify_backend.h	/^void x509_setenv(struct env_set *es, int cert_depth, openvpn_x509_cert_t *cert);$/;"	p	signature:(struct env_set *es, int cert_depth, openvpn_x509_cert_t *cert)
x509_setenv	ssl_verify_mbedtls.c	/^x509_setenv(struct env_set *es, int cert_depth, mbedtls_x509_crt *cert)$/;"	f	signature:(struct env_set *es, int cert_depth, mbedtls_x509_crt *cert)
x509_setenv	ssl_verify_openssl.c	/^x509_setenv(struct env_set *es, int cert_depth, openvpn_x509_cert_t *peer_cert)$/;"	f	signature:(struct env_set *es, int cert_depth, openvpn_x509_cert_t *peer_cert)
x509_setenv_track	ssl_verify_backend.h	/^void x509_setenv_track(const struct x509_track *xt, struct env_set *es,$/;"	p	signature:(const struct x509_track *xt, struct env_set *es, const int depth, openvpn_x509_cert_t *x509)
x509_setenv_track	ssl_verify_mbedtls.c	/^x509_setenv_track(const struct x509_track *xt, struct env_set *es,$/;"	f	signature:(const struct x509_track *xt, struct env_set *es, const int depth, mbedtls_x509_crt *cert)
x509_setenv_track	ssl_verify_openssl.c	/^x509_setenv_track(const struct x509_track *xt, struct env_set *es, const int depth, X509 *x509)$/;"	f	signature:(const struct x509_track *xt, struct env_set *es, const int depth, X509 *x509)
x509_track	options.h	/^    const struct x509_track *x509_track;$/;"	m	struct:options	typeref:struct:options::x509_track	access:public
x509_track	ssl_common.h	/^    const struct x509_track *x509_track;$/;"	m	struct:tls_options	typeref:struct:tls_options::x509_track	access:public
x509_track	ssl_verify.h	/^struct x509_track$/;"	s
x509_track::flags	ssl_verify.h	/^    unsigned int flags;$/;"	m	struct:x509_track	access:public
x509_track::name	ssl_verify.h	/^    const char *name;$/;"	m	struct:x509_track	access:public
x509_track::next	ssl_verify.h	/^    const struct x509_track *next;$/;"	m	struct:x509_track	typeref:struct:x509_track::x509_track	access:public
x509_track::nid	ssl_verify.h	/^    int nid;$/;"	m	struct:x509_track	access:public
x509_track_add	ssl_verify_backend.h	/^void x509_track_add(const struct x509_track **ll_head, const char *name,$/;"	p	signature:(const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)
x509_track_add	ssl_verify_mbedtls.c	/^x509_track_add(const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)$/;"	f	signature:(const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)
x509_track_add	ssl_verify_openssl.c	/^x509_track_add(const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)$/;"	f	signature:(const struct x509_track **ll_head, const char *name, int msglevel, struct gc_arena *gc)
x509_username_field	options.h	/^    char *x509_username_field;$/;"	m	struct:options	access:public
x509_username_field	ssl_common.h	/^    char *x509_username_field;$/;"	m	struct:tls_options	access:public
x509_username_field_ext_supported	ssl_verify_backend.h	/^bool x509_username_field_ext_supported(const char *extname);$/;"	p	signature:(const char *extname)
x509_username_field_ext_supported	ssl_verify_openssl.c	/^bool x509_username_field_ext_supported(const char *fieldname)$/;"	f	signature:(const char *fieldname)
x509_verify_cert_eku	ssl_verify_backend.h	/^result_t x509_verify_cert_eku(openvpn_x509_cert_t *x509, const char *const expected_oid);$/;"	p	signature:(openvpn_x509_cert_t *x509, const char *const expected_oid)
x509_verify_cert_eku	ssl_verify_mbedtls.c	/^x509_verify_cert_eku(mbedtls_x509_crt *cert, const char *const expected_oid)$/;"	f	signature:(mbedtls_x509_crt *cert, const char *const expected_oid)
x509_verify_cert_eku	ssl_verify_openssl.c	/^x509_verify_cert_eku(X509 *x509, const char *const expected_oid)$/;"	f	signature:(X509 *x509, const char *const expected_oid)
x509_verify_cert_ku	ssl_verify_backend.h	/^result_t x509_verify_cert_ku(openvpn_x509_cert_t *x509, const unsigned *const expected_ku,$/;"	p	signature:(openvpn_x509_cert_t *x509, const unsigned *const expected_ku, int expected_len)
x509_verify_cert_ku	ssl_verify_mbedtls.c	/^x509_verify_cert_ku(mbedtls_x509_crt *cert, const unsigned *const expected_ku,$/;"	f	signature:(mbedtls_x509_crt *cert, const unsigned *const expected_ku, int expected_len)
x509_verify_cert_ku	ssl_verify_openssl.c	/^x509_verify_cert_ku(X509 *x509, const unsigned *const expected_ku,$/;"	f	signature:(X509 *x509, const unsigned *const expected_ku, int expected_len)
x509_verify_ns_cert_type	ssl_verify_backend.h	/^result_t x509_verify_ns_cert_type(openvpn_x509_cert_t *cert, const int usage);$/;"	p	signature:(openvpn_x509_cert_t *cert, const int usage)
x509_verify_ns_cert_type	ssl_verify_mbedtls.c	/^x509_verify_ns_cert_type(mbedtls_x509_crt *cert, const int usage)$/;"	f	signature:(mbedtls_x509_crt *cert, const int usage)
x509_verify_ns_cert_type	ssl_verify_openssl.c	/^x509_verify_ns_cert_type(openvpn_x509_cert_t *peer_cert, const int usage)$/;"	f	signature:(openvpn_x509_cert_t *peer_cert, const int usage)
x509_write_pem	ssl_verify_backend.h	/^result_t x509_write_pem(FILE *peercert_file, openvpn_x509_cert_t *peercert);$/;"	p	signature:(FILE *peercert_file, openvpn_x509_cert_t *peercert)
x509_write_pem	ssl_verify_mbedtls.c	/^x509_write_pem(FILE *peercert_file, mbedtls_x509_crt *peercert)$/;"	f	signature:(FILE *peercert_file, mbedtls_x509_crt *peercert)
x509_write_pem	ssl_verify_openssl.c	/^x509_write_pem(FILE *peercert_file, X509 *peercert)$/;"	f	signature:(FILE *peercert_file, X509 *peercert)
x_check_status	error.c	/^x_check_status(int status,$/;"	f	signature:(int status, const char *description, struct link_socket *sock, struct tuntap *tt)
x_check_status	error.h	/^void x_check_status(int status,$/;"	p	signature:(int status, const char *description, struct link_socket *sock, struct tuntap *tt)
x_cs_err_delay_ms	error.c	/^unsigned int x_cs_err_delay_ms;  \/* GLOBAL *\/$/;"	v
x_cs_info_level	error.c	/^unsigned int x_cs_info_level;    \/* GLOBAL *\/$/;"	v
x_cs_verbose_level	error.c	/^unsigned int x_cs_verbose_level; \/* GLOBAL *\/$/;"	v
x_debug_level	error.c	/^unsigned int x_debug_level; \/* GLOBAL *\/$/;"	v
x_gc_free	buffer.c	/^x_gc_free(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
x_gc_free	buffer.h	/^void x_gc_free(struct gc_arena *a);$/;"	p	signature:(struct gc_arena *a)
x_gc_freespecial	buffer.c	/^x_gc_freespecial(struct gc_arena *a)$/;"	f	signature:(struct gc_arena *a)
x_gc_freespecial	buffer.h	/^void x_gc_freespecial(struct gc_arena *a);$/;"	p	signature:(struct gc_arena *a)
x_msg	error.c	/^x_msg(const unsigned int flags, const char *format, ...)$/;"	f	signature:(const unsigned int flags, const char *format, ...)
x_msg	error.h	/^void x_msg(const unsigned int flags, const char *format, ...)$/;"	p	signature:(const unsigned int flags, const char *format, ...)
x_msg_line_num	error.c	/^int x_msg_line_num; \/* GLOBAL *\/$/;"	v
x_msg_prefix	error.c	/^const char *x_msg_prefix; \/* GLOBAL *\/$/;"	v
x_msg_va	error.c	/^x_msg_va(const unsigned int flags, const char *format, va_list arglist)$/;"	f	signature:(const unsigned int flags, const char *format, va_list arglist)
x_msg_va	error.h	/^void x_msg_va(const unsigned int flags, const char *format, va_list arglist);$/;"	p	signature:(const unsigned int flags, const char *format, va_list arglist)
x_msg_virtual_output	error.c	/^const struct virtual_output *x_msg_virtual_output; \/* GLOBAL *\/$/;"	v	typeref:struct:virtual_output
x_session_id_zero	session_id.c	/^const struct session_id x_session_id_zero;$/;"	v	typeref:struct:session_id
xid	dhcp.h	/^    uint32_t xid;      \/* transaction ID, chosen by client *\/$/;"	m	struct:dhcp	access:public
xmit_hold	ssl_common.h	/^    bool xmit_hold;$/;"	m	struct:tls_options	access:public
yiaddr	dhcp.h	/^    uint32_t yiaddr;   \/* 'your' IP address -- server's response to client *\/$/;"	m	struct:dhcp	access:public
z	schedule.c	/^static struct status z;$/;"	v	typeref:struct:status	file:
